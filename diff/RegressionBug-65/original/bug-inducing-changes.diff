diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/StringUtil.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/StringUtil.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/helper/StringUtil.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper/StringUtil.java	2024-09-08 01:36:20.177851056 +1000
@@ -10,8 +10,10 @@
  * A minimal String utility class. Designed for internal jsoup use only.
  */
 public final class StringUtil {
-    // memoised padding up to 10
-    private static final String[] padding = {"", " ", "  ", "   ", "    ", "     ", "      ", "       ", "        ", "         ", "          "};
+    // memoised padding up to 21
+    static final String[] padding = {"", " ", "  ", "   ", "    ", "     ", "      ", "       ", "        ",
+        "         ", "          ", "           ", "            ", "             ", "              ", "               ",
+        "                ", "                 ", "                  ", "                   ", "                    "};
 
     /**
      * Join a collection of strings by a separator
@@ -56,7 +58,6 @@
 
         if (width < padding.length)
             return padding[width];
-
         char[] out = new char[width];
         for (int i = 0; i < width; i++)
             out[i] = ' ';
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attribute.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attribute.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attribute.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attribute.java	2024-09-08 01:36:20.177851056 +1000
@@ -8,9 +8,8 @@
 import java.util.Map;
 
 /**
- A single key + value attribute. Keys are trimmed and normalised to lower-case.
-
- @author Jonathan Hedley, jonathan@hedley.net */
+ A single key + value attribute. (Only used for presentation.)
+ */
 public class Attribute implements Map.Entry<String, String>, Cloneable  {
     private static final String[] booleanAttributes = {
             "allowfullscreen", "async", "autofocus", "checked", "compact", "declare", "default", "defer", "disabled",
@@ -20,7 +19,8 @@
     };
 
     private String key;
-    private String value;
+    private String val;
+    Attributes parent; // used to update the holding Attributes when the key / value is changed via this interface
 
     /**
      * Create a new attribute from unencoded (raw) key and value.
@@ -29,11 +29,21 @@
      * @see #createFromEncoded
      */
     public Attribute(String key, String value) {
+        this(key, value, null);
+    }
+
+    /**
+     * Create a new attribute from unencoded (raw) key and value.
+     * @param key attribute key; case is preserved.
+     * @param val attribute value
+     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)
+     * @see #createFromEncoded*/
+    public Attribute(String key, String val, Attributes parent) {
         Validate.notNull(key);
-        Validate.notNull(value);
         this.key = key.trim();
         Validate.notEmpty(key); // trimming could potentially make empty, so validate here
-        this.value = value;
+        this.val = val;
+        this.parent = parent;
     }
 
     /**
@@ -50,7 +60,13 @@
      */
     public void setKey(String key) {
         Validate.notEmpty(key);
-        this.key = key.trim();
+        key = key.trim();
+        if (parent != null) {
+            int i = parent.indexOfKey(this.key);
+            if (i != Attributes.NotFound)
+                parent.keys[i] = key;
+        }
+        this.key = key;
     }
 
     /**
@@ -58,18 +74,22 @@
      @return the attribute value
      */
     public String getValue() {
-        return value;
+        return val;
     }
 
     /**
      Set the attribute value.
-     @param value the new attribute value; must not be null
+     @param val the new attribute value; must not be null
      */
-    public String setValue(String value) {
-        Validate.notNull(value);
-        String old = this.value;
-        this.value = value;
-        return old;
+    public String setValue(String val) {
+        String oldVal = parent.get(this.key);
+        if (parent != null) {
+            int i = parent.indexOfKey(this.key);
+            if (i != Attributes.NotFound)
+                parent.vals[i] = val;
+        }
+        this.val = val;
+        return oldVal;
     }
 
     /**
@@ -86,15 +106,19 @@
         }
         return accum.toString();
     }
-    
-    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {
+
+    protected static void html(String key, String val, Appendable accum, Document.OutputSettings out) throws IOException {
         accum.append(key);
-        if (!shouldCollapseAttribute(out)) {
+        if (!shouldCollapseAttribute(key, val, out)) {
             accum.append("=\"");
-            Entities.escape(accum, value, out, true, false, false);
+            Entities.escape(accum, Attributes.checkNotNull(val) , out, true, false, false);
             accum.append('"');
         }
     }
+    
+    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {
+        html(key, val, accum, out);
+    }
 
     /**
      Get the string representation of this attribute, implemented as {@link #html()}.
@@ -113,10 +137,14 @@
      */
     public static Attribute createFromEncoded(String unencodedKey, String encodedValue) {
         String value = Entities.unescape(encodedValue, true);
-        return new Attribute(unencodedKey, value);
+        return new Attribute(unencodedKey, value, null); // parent will get set when Put
     }
 
     protected boolean isDataAttribute() {
+        return isDataAttribute(key);
+    }
+
+    protected static boolean isDataAttribute(String key) {
         return key.startsWith(Attributes.dataPrefix) && key.length() > Attributes.dataPrefix.length();
     }
 
@@ -127,37 +155,50 @@
      * @return  Returns whether collapsible or not
      */
     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {
-        return ("".equals(value) || value.equalsIgnoreCase(key))
-                && out.syntax() == Document.OutputSettings.Syntax.html
-                && isBooleanAttribute();
+        return shouldCollapseAttribute(key, val, out);
     }
 
+    protected static boolean shouldCollapseAttribute(String key, String val, Document.OutputSettings out) {
+        // todo: optimize
+        return (val == null || "".equals(val) || val.equalsIgnoreCase(key))
+            && out.syntax() == Document.OutputSettings.Syntax.html
+            && isBooleanAttribute(key);
+    }
+
+    /**
+     * @deprecated
+     */
     protected boolean isBooleanAttribute() {
+        return Arrays.binarySearch(booleanAttributes, key) >= 0 || val == null;
+    }
+
+    /**
+     * Checks if this attribute name is defined as a boolean attribute in HTML5
+     */
+    protected static boolean isBooleanAttribute(final String key) {
         return Arrays.binarySearch(booleanAttributes, key) >= 0;
     }
 
     @Override
-    public boolean equals(Object o) {
+    public boolean equals(Object o) { // note parent not considered
         if (this == o) return true;
-        if (!(o instanceof Attribute)) return false;
-
+        if (o == null || getClass() != o.getClass()) return false;
         Attribute attribute = (Attribute) o;
-
         if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;
-        return !(value != null ? !value.equals(attribute.value) : attribute.value != null);
+        return val != null ? val.equals(attribute.val) : attribute.val == null;
     }
 
     @Override
-    public int hashCode() {
+    public int hashCode() { // note parent not considered
         int result = key != null ? key.hashCode() : 0;
-        result = 31 * result + (value != null ? value.hashCode() : 0);
+        result = 31 * result + (val != null ? val.hashCode() : 0);
         return result;
     }
 
     @Override
     public Attribute clone() {
         try {
-            return (Attribute) super.clone(); // only fields are immutable strings key and value, so no more deep copy required
+            return (Attribute) super.clone();
         } catch (CloneNotSupportedException e) {
             throw new RuntimeException(e);
         }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attributes.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attributes.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Attributes.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Attributes.java	2024-09-08 01:36:20.177851056 +1000
@@ -7,20 +7,22 @@
 import java.util.AbstractMap;
 import java.util.AbstractSet;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Iterator;
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import static org.jsoup.internal.Normalizer.lowerCase;
+
 /**
  * The attributes of an Element.
  * <p>
  * Attributes are treated as a map: there can be only one value associated with an attribute key/name.
  * </p>
  * <p>
- * Attribute name and value comparisons are  <b>case sensitive</b>. By default for HTML, attribute names are
+ * Attribute name and value comparisons are  generally <b>case sensitive</b>. By default for HTML, attribute names are
  * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by
  * name.
  * </p>
@@ -29,83 +31,120 @@
  */
 public class Attributes implements Iterable<Attribute>, Cloneable {
     protected static final String dataPrefix = "data-";
+    private static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting
+
+    // manages the key/val arrays
+    private static final int GrowthFactor = 2;
+    private static final String[] Empty = {};
+    static final int NotFound = -1;
+    private static final String EmptyString = "";
+
+    private int size = 0; // number of slots used (not capacity, which is keys.length
+    String[] keys = Empty;
+    String[] vals = Empty;
+
+    // check there's room for more
+    private void checkCapacity(int minNewSize) {
+        Validate.isTrue(minNewSize >= size);
+        int curSize = keys.length;
+        if (curSize >= minNewSize)
+            return;
+
+        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;
+        if (minNewSize > newSize)
+            newSize = minNewSize;
 
-    private LinkedHashMap<String, Attribute> attributes = null;
-    // linked hash map to preserve insertion order.
-    // null be default as so many elements have no attributes -- saves a good chunk of memory
+        keys = Arrays.copyOf(keys, newSize);
+        vals = Arrays.copyOf(vals, newSize);
+    }
+
+    int indexOfKey(String key) {
+        Validate.notNull(key);
+        for (int i = 0; i < size; i++) {
+            if (key.equals(keys[i]))
+                return i;
+        }
+        return NotFound;
+    }
+
+    private int indexOfKeyIgnoreCase(String key) {
+        Validate.notNull(key);
+        for (int i = 0; i < size; i++) {
+            if (key.equalsIgnoreCase(keys[i]))
+                return i;
+        }
+        return NotFound;
+    }
+
+    // we track boolean attributes as null in values - they're just keys. so returns empty for consumers
+    static final String checkNotNull(String val) {
+        return val == null ? EmptyString : val;
+    }
 
     /**
      Get an attribute value by key.
      @param key the (case-sensitive) attribute key
-     @return the attribute value if set; or empty string if not set.
+     @return the attribute value if set; or empty string if not set (or a boolean attribute).
      @see #hasKey(String)
      */
     public String get(String key) {
-        Validate.notEmpty(key);
-
-        if (attributes == null)
-            return "";
-
-        Attribute attr = attributes.get(key);
-        return attr != null ? attr.getValue() : "";
+        int i = indexOfKey(key);
+        return i == NotFound ? EmptyString : checkNotNull(vals[i]);
     }
 
     /**
      * Get an attribute's value by case-insensitive key
      * @param key the attribute name
-     * @return the first matching attribute value if set; or empty string if not set.
+     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).
      */
     public String getIgnoreCase(String key) {
-        Attribute attr = getAttributeIgnoreCase(key);
-        return attr != null ? attr.getValue() : "";
+        int i = indexOfKeyIgnoreCase(key);
+        return i == NotFound ? EmptyString : checkNotNull(vals[i]);
     }
 
-    private Attribute getAttributeIgnoreCase(String key) {
-        Validate.notEmpty(key);
-        if (attributes == null)
-            return null;
-
-        Attribute attr = attributes.get(key);
-        if (attr != null)
-            return attr;
-
-        for (String attrKey : attributes.keySet()) {
-            if (attrKey.equalsIgnoreCase(key))
-                return attributes.get(attrKey);
-        }
-        return null;
+    // adds without checking if this key exists
+    private void add(String key, String value) {
+        checkCapacity(size + 1);
+        keys[size] = key;
+        vals[size] = value;
+        size++;
     }
 
     /**
      * Set a new attribute, or replace an existing one by key.
-     * @param key attribute key
+     * @param key case sensitive attribute key
      * @param value attribute value
      * @return these attributes, for chaining
      */
     public Attributes put(String key, String value) {
-        Attribute attr = new Attribute(key, value);
-        put(attr);
+        int i = indexOfKey(key);
+        if (i != NotFound)
+            vals[i] = value;
+        else
+            add(key, value);
         return this;
     }
 
     void putIgnoreCase(String key, String value) {
-        Attribute oldAttr = getAttributeIgnoreCase(key);
-        if (oldAttr != null && !oldAttr.getKey().equals(key)) {
-            attributes.remove(oldAttr.getKey());
+        int i = indexOfKeyIgnoreCase(key);
+        if (i != NotFound) {
+            vals[i] = value;
+            if (!keys[i].equals(key)) // case changed, update
+                keys[i] = key;
         }
-
-        put(key, value);
+        else
+            add(key, value);
     }
 
     /**
      * Set a new boolean attribute, remove attribute if value is false.
-     * @param key attribute key
+     * @param key case <b>insensitive</b> attribute key
      * @param value attribute value
      * @return these attributes, for chaining
      */
     public Attributes put(String key, boolean value) {
         if (value)
-            put(new BooleanAttribute(key));
+            putIgnoreCase(key, null);
         else
             remove(key);
         return this;
@@ -113,26 +152,37 @@
 
     /**
      Set a new attribute, or replace an existing one by key.
-     @param attribute attribute
+     @param attribute attribute with case sensitive key
      @return these attributes, for chaining
      */
     public Attributes put(Attribute attribute) {
         Validate.notNull(attribute);
-        if (attributes == null)
-             attributes = new LinkedHashMap<>(2);
-        attributes.put(attribute.getKey(), attribute);
+        put(attribute.getKey(), attribute.getValue());
+        attribute.parent = this;
         return this;
     }
 
+    // removes and shifts up
+    private void remove(int index) {
+        Validate.isFalse(index >= size);
+        int shifted = size - index - 1;
+        if (shifted > 0) {
+            System.arraycopy(keys, index + 1, keys, index, shifted);
+            System.arraycopy(vals, index + 1, vals, index, shifted);
+        }
+        size--;
+        keys[size] = null; // release hold
+        vals[size] = null;
+    }
+
     /**
      Remove an attribute by key. <b>Case sensitive.</b>
      @param key attribute key to remove
      */
     public void remove(String key) {
-        Validate.notEmpty(key);
-        if (attributes == null)
-            return;
-        attributes.remove(key);
+        int i = indexOfKey(key);
+        if (i != NotFound)
+            remove(i);
     }
 
     /**
@@ -140,14 +190,9 @@
      @param key attribute key to remove
      */
     public void removeIgnoreCase(String key) {
-        Validate.notEmpty(key);
-        if (attributes == null)
-            return;
-        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {
-            String attrKey = it.next();
-            if (attrKey.equalsIgnoreCase(key))
-                it.remove();
-        }
+        int i = indexOfKeyIgnoreCase(key);
+        if (i != NotFound)
+            remove(i);
     }
 
     /**
@@ -156,7 +201,7 @@
      @return true if key exists, false otherwise
      */
     public boolean hasKey(String key) {
-        return attributes != null && attributes.containsKey(key);
+        return indexOfKey(key) != NotFound;
     }
 
     /**
@@ -165,13 +210,7 @@
      @return true if key exists, false otherwise
      */
     public boolean hasKeyIgnoreCase(String key) {
-        if (attributes == null)
-            return false;
-        for (String attrKey : attributes.keySet()) {
-            if (attrKey.equalsIgnoreCase(key))
-                return true;
-        }
-        return false;
+        return indexOfKeyIgnoreCase(key) != NotFound;
     }
 
     /**
@@ -179,9 +218,7 @@
      @return size
      */
     public int size() {
-        if (attributes == null)
-            return 0;
-        return attributes.size();
+        return size;
     }
 
     /**
@@ -191,31 +228,49 @@
     public void addAll(Attributes incoming) {
         if (incoming.size() == 0)
             return;
-        if (attributes == null)
-            attributes = new LinkedHashMap<>(incoming.size());
-        attributes.putAll(incoming.attributes);
+        checkCapacity(size + incoming.size);
+
+        for (Attribute attr : incoming) {
+            // todo - should this be case insensitive?
+            put(attr);
+        }
+
     }
 
     public Iterator<Attribute> iterator() {
-        if (attributes == null || attributes.isEmpty()) {
-            return Collections.<Attribute>emptyList().iterator();
-        }
+        return new Iterator<Attribute>() {
+            int i = 0;
 
-        return attributes.values().iterator();
+            @Override
+            public boolean hasNext() {
+                return i < size;
+            }
+
+            @Override
+            public Attribute next() {
+                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);
+                i++;
+                return attr;
+            }
+
+            @Override
+            public void remove() {
+                Attributes.this.remove(--i); // next() advanced, so rewind
+            }
+        };
     }
 
     /**
-     Get the attributes as a List, for iteration. Do not modify the keys of the attributes via this view, as changes
-     to keys will not be recognised in the containing set.
-     @return an view of the attributes as a List.
+     Get the attributes as a List, for iteration.
+     @return an view of the attributes as an unmodifialbe List.
      */
     public List<Attribute> asList() {
-        if (attributes == null)
-            return Collections.emptyList();
-
-        List<Attribute> list = new ArrayList<>(attributes.size());
-        for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {
-            list.add(entry.getValue());
+        ArrayList<Attribute> list = new ArrayList<>(size);
+        for (int i = 0; i < size; i++) {
+            Attribute attr = vals[i] == null ?
+                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it
+                new Attribute(keys[i], vals[i], Attributes.this);
+            list.add(attr);
         }
         return Collections.unmodifiableList(list);
     }
@@ -226,7 +281,7 @@
      * @return map of custom data attributes.
      */
     public Map<String, String> dataset() {
-        return new Dataset();
+        return new Dataset(this);
     }
 
     /**
@@ -244,14 +299,22 @@
         return accum.toString();
     }
 
-    void html(Appendable accum, Document.OutputSettings out) throws IOException {
-        if (attributes == null)
-            return;
-
-        for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {
-            Attribute attribute = entry.getValue();
-            accum.append(" ");
-            attribute.html(accum, out);
+    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {
+        final int sz = size;
+        for (int i = 0; i < sz; i++) {
+            // inlined from Attribute.html()
+            final String key = keys[i];
+            final String val = vals[i];
+            accum.append(' ').append(key);
+
+            // collapse checked=null, checked="", checked=checked; write out others
+            if (!(out.syntax() == Document.OutputSettings.Syntax.html
+                && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {
+
+                accum.append("=\"");
+                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);
+                accum.append('"');
+            }
         }
     }
 
@@ -268,11 +331,13 @@
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
-        if (!(o instanceof Attributes)) return false;
+        if (o == null || getClass() != o.getClass()) return false;
 
         Attributes that = (Attributes) o;
 
-        return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);
+        if (size != that.size) return false;
+        if (!Arrays.equals(keys, that.keys)) return false;
+        return Arrays.equals(vals, that.vals);
     }
 
     /**
@@ -281,31 +346,40 @@
      */
     @Override
     public int hashCode() {
-        return attributes != null ? attributes.hashCode() : 0;
+        int result = size;
+        result = 31 * result + Arrays.hashCode(keys);
+        result = 31 * result + Arrays.hashCode(vals);
+        return result;
     }
 
     @Override
     public Attributes clone() {
-        if (attributes == null)
-            return new Attributes();
-
         Attributes clone;
         try {
             clone = (Attributes) super.clone();
         } catch (CloneNotSupportedException e) {
             throw new RuntimeException(e);
         }
-        clone.attributes = new LinkedHashMap<>(attributes.size());
-        for (Attribute attribute: this)
-            clone.attributes.put(attribute.getKey(), attribute.clone());
+        clone.size = size;
+        keys = Arrays.copyOf(keys, size);
+        vals = Arrays.copyOf(vals, size);
         return clone;
     }
 
-    private class Dataset extends AbstractMap<String, String> {
+    /**
+     * Internal method. Lowercases all keys.
+     */
+    public void normalize() {
+        for (int i = 0; i < size; i++) {
+            keys[i] = lowerCase(keys[i]);
+        }
+    }
+
+    private static class Dataset extends AbstractMap<String, String> {
+        private final Attributes attributes;
 
-        private Dataset() {
-            if (attributes == null)
-                attributes = new LinkedHashMap<>(2);
+        private Dataset(Attributes attributes) {
+            this.attributes = attributes;
         }
 
         @Override
@@ -316,9 +390,8 @@
         @Override
         public String put(String key, String value) {
             String dataKey = dataKey(key);
-            String oldValue = hasKey(dataKey) ? attributes.get(dataKey).getValue() : null;
-            Attribute attr = new Attribute(dataKey, value);
-            attributes.put(dataKey, attr);
+            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;
+            attributes.put(dataKey, value);
             return oldValue;
         }
 
@@ -329,7 +402,7 @@
                 return new DatasetIterator();
             }
 
-           @Override
+            @Override
             public int size() {
                 int count = 0;
                 Iterator iter = new DatasetIterator();
@@ -340,7 +413,7 @@
         }
 
         private class DatasetIterator implements Iterator<Map.Entry<String, String>> {
-            private Iterator<Attribute> attrIter = attributes.values().iterator();
+            private Iterator<Attribute> attrIter = attributes.iterator();
             private Attribute attr;
             public boolean hasNext() {
                 while (attrIter.hasNext()) {
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/BooleanAttribute.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/BooleanAttribute.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/BooleanAttribute.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/BooleanAttribute.java	2024-09-08 01:36:20.177851056 +1000
@@ -2,6 +2,7 @@
 
 /**
  * A boolean attribute that is written out without any value.
+ * @deprecated just use null values (vs empty string) for booleans.
  */
 public class BooleanAttribute extends Attribute {
     /**
@@ -9,7 +10,7 @@
      * @param key attribute key
      */
     public BooleanAttribute(String key) {
-        super(key, "");
+        super(key, null);
     }
 
     @Override
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Document.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Document.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Document.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Document.java	2024-09-08 01:36:20.177851056 +1000
@@ -372,13 +372,9 @@
 
         private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;
         private Charset charset;
-        // enables the doc to be shared in multiple threads, without creating new encoders on every traverse
-        private final ThreadLocal<CharsetEncoder> encoder = new ThreadLocal<CharsetEncoder>() {
-            @Override
-            protected CharsetEncoder initialValue() {
-                return charset.newEncoder();
-            }
-        };
+        CharsetEncoder encoder; // initialized by start of OuterHtmlVisitor and cleared at end
+        Entities.CoreCharset coreCharset; // fast encoders for ascii and utf8
+
         private boolean prettyPrint = true;
         private boolean outline = false;
         private int indentAmount = 1;
@@ -430,7 +426,6 @@
          */
         public OutputSettings charset(Charset charset) {
             this.charset = charset;
-            encoder.remove();
             return this;
         }
 
@@ -444,15 +439,10 @@
             return this;
         }
 
-        CharsetEncoder encoder() {
-            CharsetEncoder ce = encoder.get();
-            // check that the charset wasn't changed since accessed in this thread
-            // (this is probably overkill for something we're not advertising as threadsafe)
-            if (!ce.charset().equals(charset)) {
-                encoder.remove();
-                ce = encoder.get(); // retrips initialValue()
-            }
-            return ce;
+        CharsetEncoder prepareEncoder() {
+            encoder = charset.newEncoder(); // created at start of OuterHtmlVisitor so each pass has own encoder, so OutputSettings can be shared among threads
+            coreCharset = Entities.CoreCharset.byName(encoder.charset().name());
+            return encoder;
         }
 
         /**
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/DocumentType.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/DocumentType.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/DocumentType.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/DocumentType.java	2024-09-08 01:36:20.177851056 +1000
@@ -1,6 +1,7 @@
 package org.jsoup.nodes;
 
 import org.jsoup.helper.StringUtil;
+import org.jsoup.helper.Validate;
 import org.jsoup.nodes.Document.OutputSettings.Syntax;
 
 import java.io.IOException;
@@ -25,6 +26,9 @@
      * @param systemId the doctype's system ID
      */
     public DocumentType(String name, String publicId, String systemId) {
+        Validate.notNull(name);
+        Validate.notNull(publicId);
+        Validate.notNull(systemId);
         attr(NAME, name);
         attr(PUBLIC_ID, publicId);
         if (has(PUBLIC_ID)) {
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Element.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Element.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Element.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Element.java	2024-09-08 01:36:20.177851056 +1000
@@ -1021,7 +1021,7 @@
                     if (accum.length() > 0 &&
                         (element.isBlock() || element.tag.getName().equals("br")) &&
                         !TextNode.lastCharIsWhitespace(accum))
-                        accum.append(" ");
+                        accum.append(' ');
                 }
             }
 
@@ -1300,7 +1300,7 @@
         return this;
     }
 
-    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
+    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {
         if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {
             if (accum instanceof StringBuilder) {
                 if (((StringBuilder) accum).length() > 0)
@@ -1309,11 +1309,8 @@
                 indent(accum, depth, out);
             }
         }
-        accum
-                .append("<")
-                .append(tagName());
-        if (hasAttributes())
-            attributes.html(accum, out);
+        accum.append('<').append(tagName());
+        if (attributes != null) attributes.html(accum, out);
 
         // selfclosing includes unknown tags, isEmpty defines tags that are always empty
         if (childNodes.isEmpty() && tag.isSelfClosing()) {
@@ -1323,7 +1320,7 @@
                 accum.append(" />"); // <img> in html, <img /> in xml
         }
         else
-            accum.append(">");
+            accum.append('>');
     }
 
 	void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
@@ -1332,7 +1329,7 @@
                     tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))
             )))
                 indent(accum, depth, out);
-            accum.append("</").append(tagName()).append(">");
+            accum.append("</").append(tagName()).append('>');
         }
     }
 
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Entities.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Entities.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Entities.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Entities.java	2024-09-08 01:36:20.177851056 +1000
@@ -161,8 +161,8 @@
         boolean lastWasWhite = false;
         boolean reachedNonWhite = false;
         final EscapeMode escapeMode = out.escapeMode();
-        final CharsetEncoder encoder = out.encoder();
-        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());
+        final CharsetEncoder encoder = out.encoder != null ? out.encoder : out.prepareEncoder();
+        final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()
         final int length = string.length();
 
         int codePoint;
@@ -278,10 +278,10 @@
         }
     }
 
-    private enum CoreCharset {
+    enum CoreCharset {
         ascii, utf, fallback;
 
-        private static CoreCharset byName(String name) {
+        static CoreCharset byName(final String name) {
             if (name.equals("US-ASCII"))
                 return ascii;
             if (name.startsWith("UTF-")) // covers UTF-8, UTF-16, et al
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Node.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Node.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Node.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Node.java	2024-09-08 01:36:20.177851056 +1000
@@ -14,8 +14,6 @@
 import java.util.LinkedList;
 import java.util.List;
 
-import static org.jsoup.internal.Normalizer.lowerCase;
-
 /**
  The base, abstract Node model. Elements, Documents, Comments etc are all Node instances.
 
@@ -69,7 +67,7 @@
         String val = attributes().getIgnoreCase(attributeKey);
         if (val.length() > 0)
             return val;
-        else if (lowerCase(attributeKey).startsWith("abs:"))
+        else if (attributeKey.startsWith("abs:"))
             return absUrl(attributeKey.substring("abs:".length()));
         else return "";
     }
@@ -582,9 +580,9 @@
      @param accum accumulator to place HTML into
      @throws IOException if appending to the given accumulator fails.
      */
-    abstract void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException;
+    abstract void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;
 
-    abstract void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException;
+    abstract void outerHtmlTail(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;
 
     /**
      * Write this node and its children to the given {@link Appendable}.
@@ -602,7 +600,7 @@
     }
 
     protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
-        accum.append("\n").append(StringUtil.padding(depth * out.indentAmount()));
+        accum.append('\n').append(StringUtil.padding(depth * out.indentAmount()));
     }
 
     /**
@@ -688,6 +686,7 @@
         OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {
             this.accum = accum;
             this.out = out;
+            out.prepareEncoder();
         }
 
         public void head(Node node, int depth) {
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/ParseSettings.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/ParseSettings.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/ParseSettings.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/ParseSettings.java	2024-09-08 01:36:20.177851056 +1000
@@ -1,6 +1,5 @@
 package org.jsoup.parser;
 
-import org.jsoup.nodes.Attribute;
 import org.jsoup.nodes.Attributes;
 
 import static org.jsoup.internal.Normalizer.lowerCase;
@@ -52,9 +51,7 @@
 
     Attributes normalizeAttributes(Attributes attributes) {
         if (!preserveAttributeCase) {
-            for (Attribute attr : attributes) {
-                attr.setKey(lowerCase(attr.getKey()));
-            }
+            attributes.normalize();
         }
         return attributes;
     }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/Token.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/Token.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/parser/Token.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/parser/Token.java	2024-09-08 01:36:20.181851084 +1000
@@ -1,9 +1,7 @@
 package org.jsoup.parser;
 
 import org.jsoup.helper.Validate;
-import org.jsoup.nodes.Attribute;
 import org.jsoup.nodes.Attributes;
-import org.jsoup.nodes.BooleanAttribute;
 
 import static org.jsoup.internal.Normalizer.lowerCase;
 
@@ -107,15 +105,14 @@
                 // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here
                 pendingAttributeName = pendingAttributeName.trim();
                 if (pendingAttributeName.length() > 0) {
-                    Attribute attribute;
+                    String value;
                     if (hasPendingAttributeValue)
-                        attribute = new Attribute(pendingAttributeName,
-                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);
+                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;
                     else if (hasEmptyAttributeValue)
-                        attribute = new Attribute(pendingAttributeName, "");
+                        value = "";
                     else
-                        attribute = new BooleanAttribute(pendingAttributeName);
-                    attributes.put(attribute);
+                        value = null;
+                    attributes.put(pendingAttributeName, value);
                 }
             }
             pendingAttributeName = null;
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/org/jsoup/helper/StringUtilTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/org/jsoup/helper/StringUtilTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/org/jsoup/helper/StringUtilTest.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/org/jsoup/helper/StringUtilTest.java	2024-09-08 01:36:20.181851084 +1000
@@ -23,6 +23,15 @@
         assertEquals(" ", StringUtil.padding(1));
         assertEquals("  ", StringUtil.padding(2));
         assertEquals("               ", StringUtil.padding(15));
+        assertEquals("                                             ", StringUtil.padding(45));
+    }
+
+    @Test public void paddingInACan() {
+        String[] padding = StringUtil.padding;
+        assertEquals(21, padding.length);
+        for (int i = 0; i < padding.length; i++) {
+            assertEquals(i, padding[i].length());
+        }
     }
 
     @Test public void isBlank() {
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/org/jsoup/nodes/AttributesTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/org/jsoup/nodes/AttributesTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/org/jsoup/nodes/AttributesTest.java	2024-09-08 01:36:20.189851141 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/org/jsoup/nodes/AttributesTest.java	2024-09-08 01:36:20.181851084 +1000
@@ -3,6 +3,7 @@
 import org.junit.Test;
 
 import java.util.Iterator;
+import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -30,8 +31,9 @@
         assertTrue(a.hasKeyIgnoreCase("tot"));
         assertEquals("There", a.getIgnoreCase("hEllo"));
 
-        assertEquals(1, a.dataset().size());
-        assertEquals("Jsoup", a.dataset().get("name"));
+        Map<String, String> dataset = a.dataset();
+        assertEquals(1, dataset.size());
+        assertEquals("Jsoup", dataset.get("name"));
         assertEquals("", a.get("tot"));
         assertEquals("a&p", a.get("Tot"));
         assertEquals("a&p", a.getIgnoreCase("tot"));
@@ -46,11 +48,55 @@
         a.put("Tot", "a&p");
         a.put("Hello", "There");
         a.put("data-name", "Jsoup");
+        assertTrue(a.hasKey("Tot"));
 
         Iterator<Attribute> iterator = a.iterator();
-        iterator.next();
+        Attribute attr = iterator.next();
+        assertEquals("Tot", attr.getKey());
         iterator.remove();
         assertEquals(2, a.size());
+        attr = iterator.next();
+        assertEquals("Hello", attr.getKey());
+        assertEquals("There", attr.getValue());
+
+        // make sure that's flowing to the underlying attributes object
+        assertEquals(2, a.size());
+        assertEquals("There", a.get("Hello"));
+        assertFalse(a.hasKey("Tot"));
+    }
+
+    @Test
+    public void testIteratorUpdateable() {
+        Attributes a = new Attributes();
+        a.put("Tot", "a&p");
+        a.put("Hello", "There");
+
+        assertFalse(a.hasKey("Foo"));
+        Iterator<Attribute> iterator = a.iterator();
+        Attribute attr = iterator.next();
+        attr.setKey("Foo");
+        attr = iterator.next();
+        attr.setKey("Bar");
+        attr.setValue("Qux");
+
+        assertEquals("a&p", a.get("Foo"));
+        assertEquals("Qux", a.get("Bar"));
+        assertFalse(a.hasKey("Tot"));
+        assertFalse(a.hasKey("Hello"));
+    }
+
+    @Test public void testIteratorHasNext() {
+        Attributes a = new Attributes();
+        a.put("Tot", "1");
+        a.put("Hello", "2");
+        a.put("data-name", "3");
+
+        int seen = 0;
+        for (Attribute attribute : a) {
+            seen++;
+            assertEquals(String.valueOf(seen), attribute.getValue());
+        }
+        assertEquals(3, seen);
     }
 
     @Test
