Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator: AviatorEvaluatorInstance.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/AviatorEvaluator.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/AviatorEvaluator.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/AviatorEvaluator.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/AviatorEvaluator.java	2024-09-08 01:36:08.329768078 +1000
@@ -17,69 +17,10 @@
 
 import java.io.OutputStream;
 import java.math.MathContext;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.FutureTask;
-import com.googlecode.aviator.asm.Opcodes;
-import com.googlecode.aviator.code.CodeGenerator;
-import com.googlecode.aviator.code.OptimizeCodeGenerator;
-import com.googlecode.aviator.code.asm.ASMCodeGenerator;
-import com.googlecode.aviator.exception.CompileExpressionErrorException;
-import com.googlecode.aviator.exception.ExpressionRuntimeException;
-import com.googlecode.aviator.lexer.ExpressionLexer;
 import com.googlecode.aviator.lexer.token.OperatorType;
 import com.googlecode.aviator.parser.AviatorClassLoader;
-import com.googlecode.aviator.parser.ExpressionParser;
-import com.googlecode.aviator.runtime.function.math.MathAbsFunction;
-import com.googlecode.aviator.runtime.function.math.MathCosFunction;
-import com.googlecode.aviator.runtime.function.math.MathLog10Function;
-import com.googlecode.aviator.runtime.function.math.MathLogFunction;
-import com.googlecode.aviator.runtime.function.math.MathPowFunction;
-import com.googlecode.aviator.runtime.function.math.MathRoundFunction;
-import com.googlecode.aviator.runtime.function.math.MathSinFunction;
-import com.googlecode.aviator.runtime.function.math.MathSqrtFunction;
-import com.googlecode.aviator.runtime.function.math.MathTanFunction;
-import com.googlecode.aviator.runtime.function.seq.SeqCompsitePredFunFunction;
-import com.googlecode.aviator.runtime.function.seq.SeqCompsitePredFunFunction.LogicOp;
-import com.googlecode.aviator.runtime.function.seq.SeqCountFunction;
-import com.googlecode.aviator.runtime.function.seq.SeqEveryFunction;
-import com.googlecode.aviator.runtime.function.seq.SeqFilterFunction;
-import com.googlecode.aviator.runtime.function.seq.SeqIncludeFunction;
-import com.googlecode.aviator.runtime.function.seq.SeqMakePredicateFunFunction;
-import com.googlecode.aviator.runtime.function.seq.SeqMapFunction;
-import com.googlecode.aviator.runtime.function.seq.SeqNotAnyFunction;
-import com.googlecode.aviator.runtime.function.seq.SeqReduceFunction;
-import com.googlecode.aviator.runtime.function.seq.SeqSomeFunction;
-import com.googlecode.aviator.runtime.function.seq.SeqSortFunction;
-import com.googlecode.aviator.runtime.function.string.StringContainsFunction;
-import com.googlecode.aviator.runtime.function.string.StringEndsWithFunction;
-import com.googlecode.aviator.runtime.function.string.StringIndexOfFunction;
-import com.googlecode.aviator.runtime.function.string.StringJoinFunction;
-import com.googlecode.aviator.runtime.function.string.StringLengthFunction;
-import com.googlecode.aviator.runtime.function.string.StringReplaceAllFunction;
-import com.googlecode.aviator.runtime.function.string.StringReplaceFirstFunction;
-import com.googlecode.aviator.runtime.function.string.StringSplitFunction;
-import com.googlecode.aviator.runtime.function.string.StringStartsWithFunction;
-import com.googlecode.aviator.runtime.function.string.StringSubStringFunction;
-import com.googlecode.aviator.runtime.function.system.BinaryFunction;
-import com.googlecode.aviator.runtime.function.system.Date2StringFunction;
-import com.googlecode.aviator.runtime.function.system.DoubleFunction;
-import com.googlecode.aviator.runtime.function.system.LongFunction;
-import com.googlecode.aviator.runtime.function.system.NowFunction;
-import com.googlecode.aviator.runtime.function.system.PrintFunction;
-import com.googlecode.aviator.runtime.function.system.PrintlnFunction;
-import com.googlecode.aviator.runtime.function.system.RandomFunction;
-import com.googlecode.aviator.runtime.function.system.StrFunction;
-import com.googlecode.aviator.runtime.function.system.String2DateFunction;
-import com.googlecode.aviator.runtime.function.system.SysDateFunction;
-import com.googlecode.aviator.runtime.type.AviatorBoolean;
 import com.googlecode.aviator.runtime.type.AviatorFunction;
-import com.googlecode.aviator.runtime.type.AviatorNil;
 
 
 /**
@@ -90,10 +31,6 @@
  */
 public final class AviatorEvaluator {
 
-  // The classloader to define generated class
-  @Deprecated
-  private static AviatorClassLoader aviatorClassLoader;
-
   /**
    * Optimized for compile speed
    */
@@ -107,28 +44,72 @@
   /**
    * Aviator version
    */
-  public static final String VERSION = "2.1.1";
+  public static final String VERSION = "3.0.0";
 
   /**
-   * Generated java class version,default 1.6
+   * The global evaluator's functions map.
+   *
+   * @deprecated please use instance's field.
+   * @see AviatorEvaluatorInstance#getFuncMap()
    */
-  public static int BYTECODE_VER = Opcodes.V1_6;
+  @Deprecated
+  public static final Map<String, Object> FUNC_MAP = getInstance().getFuncMap();
 
-  private static OutputStream traceOutputStream = System.out;
+  /**
+   * The global evaluator's operators map.
+   *
+   * @deprecated please use instance's field.
+   * @see AviatorEvaluatorInstance#getOpsMap()
+   */
+  @Deprecated
+  public static final Map<OperatorType, AviatorFunction> OPS_MAP = getInstance().getOpsMap();
 
-  private static final ConcurrentHashMap<Options, Object> options =
-      new ConcurrentHashMap<Options, Object>();
-  /** function missing callback */
-  private static FunctionMissing functionMissing;
+  /**
+   * The global evaluator's byte code version.
+   *
+   * @deprecated
+   * @see AviatorEvaluatorInstance#getBytecodeVersion()
+   */
+  @Deprecated
+  public static int BYTECODE_VER = getInstance().getBytecodeVersion();
+
+  /**
+   * Create a aviator evaluator instance.
+   *
+   * @return
+   */
+  public static AviatorEvaluatorInstance newInstance() {
+    return new AviatorEvaluatorInstance();
+  }
 
+  private static class StaticHolder {
+    private static AviatorEvaluatorInstance INSTANCE = new AviatorEvaluatorInstance();
+  }
+
+  public static AviatorEvaluatorInstance getInstance() {
+    return StaticHolder.INSTANCE;
+  }
+
+  /**
+   * Adds a function loader.
+   *
+   * @see FunctionLoader
+   * @since 4.0.0
+   * @param loader
+   */
+  public static void addFunctionLoader(FunctionLoader loader) {
+    getInstance().addFunctionLoader(loader);
+  }
 
   /**
-   * Set a function missing callback.
-   * @since 3.3.1
-   * @param funcMissing
+   * Removes a function loader.
+   *
+   * @see FunctionLoader
+   * @since 4.0.0
+   * @param loader
    */
-  public static void setFunctionMissing(FunctionMissing funcMissing) {
-    functionMissing = funcMissing;
+  public static void removeFunctionLoader(FunctionLoader loader) {
+    getInstance().removeFunctionLoader(loader);
   }
 
   /**
@@ -139,7 +120,7 @@
    */
   @Deprecated
   public static void setTrace(boolean t) {
-    setOption(Options.TRACE, t);
+    getInstance().setOption(Options.TRACE, t);
   }
 
 
@@ -152,13 +133,7 @@
    * @param val
    */
   public static void setOption(Options opt, Object val) {
-    if (opt == null || val == null) {
-      throw new IllegalArgumentException("Option and value should not be null.");
-    }
-    if (!opt.isValidValue(val)) {
-      throw new IllegalArgumentException("Invalid value for option:" + opt.name());
-    }
-    options.put(opt, val);
+    getInstance().setOption(opt, val);
   }
 
 
@@ -168,13 +143,8 @@
    * @param opt
    * @return
    */
-  @SuppressWarnings("unchecked")
   public static <T> T getOption(Options opt) {
-    Object val = options.get(opt);
-    if (val == null) {
-      val = opt.getDefaultValue();
-    }
-    return (T) val;
+    return getInstance().getOption(opt);
   }
 
 
@@ -184,7 +154,7 @@
    * @return
    */
   public static OutputStream getTraceOutputStream() {
-    return traceOutputStream;
+    return getInstance().getTraceOutputStream();
   }
 
 
@@ -197,7 +167,7 @@
    */
   @Deprecated
   public static MathContext getMathContext() {
-    return getOption(Options.MATH_CONTEXT);
+    return getInstance().getOption(Options.MATH_CONTEXT);
   }
 
 
@@ -210,10 +180,7 @@
    */
   @Deprecated
   public static void setMathContext(MathContext mathContext) {
-    if (mathContext == null) {
-      throw new IllegalArgumentException("null mathContext");
-    }
-    setOption(Options.MATH_CONTEXT, mathContext);
+    getInstance().setOption(Options.MATH_CONTEXT, mathContext);
   }
 
 
@@ -223,109 +190,9 @@
    * @param traceOutputStream
    */
   public static void setTraceOutputStream(OutputStream traceOutputStream) {
-    AviatorEvaluator.traceOutputStream = traceOutputStream;
+    getInstance().setTraceOutputStream(traceOutputStream);
   }
 
-  static {
-    aviatorClassLoader = AccessController.doPrivileged(new PrivilegedAction<AviatorClassLoader>() {
-
-      @Override
-      public AviatorClassLoader run() {
-        return new AviatorClassLoader(AviatorEvaluator.class.getClassLoader());
-      }
-
-    });
-  }
-
-  public final static Map<String, Object> FUNC_MAP = new HashMap<String, Object>();
-
-  public final static Map<OperatorType, AviatorFunction> OPS_MAP =
-      new HashMap<OperatorType, AviatorFunction>();
-
-  static {
-    // Load internal functions
-    // load sys lib
-    addFunction(new SysDateFunction());
-    addFunction(new PrintlnFunction());
-    addFunction(new PrintFunction());
-    addFunction(new RandomFunction());
-    addFunction(new NowFunction());
-    addFunction(new LongFunction());
-    addFunction(new DoubleFunction());
-    addFunction(new StrFunction());
-    addFunction(new Date2StringFunction());
-    addFunction(new String2DateFunction());
-    addFunction(new BinaryFunction(OperatorType.ADD));
-    addFunction(new BinaryFunction(OperatorType.SUB));
-    addFunction(new BinaryFunction(OperatorType.MULT));
-    addFunction(new BinaryFunction(OperatorType.DIV));
-    addFunction(new BinaryFunction(OperatorType.MOD));
-    addFunction(new BinaryFunction(OperatorType.NEG));
-    addFunction(new BinaryFunction(OperatorType.NOT));
-    addFunction(new BinaryFunction(OperatorType.BIT_AND));
-    addFunction(new BinaryFunction(OperatorType.BIT_OR));
-    addFunction(new BinaryFunction(OperatorType.BIT_XOR));
-    addFunction(new BinaryFunction(OperatorType.BIT_NOT));
-
-    // load string lib
-    addFunction(new StringContainsFunction());
-    addFunction(new StringIndexOfFunction());
-    addFunction(new StringStartsWithFunction());
-    addFunction(new StringEndsWithFunction());
-    addFunction(new StringSubStringFunction());
-    addFunction(new StringLengthFunction());
-    addFunction(new StringSplitFunction());
-    addFunction(new StringJoinFunction());
-    addFunction(new StringReplaceFirstFunction());
-    addFunction(new StringReplaceAllFunction());
-
-    // load math lib
-    addFunction(new MathAbsFunction());
-    addFunction(new MathRoundFunction());
-    addFunction(new MathPowFunction());
-    addFunction(new MathSqrtFunction());
-    addFunction(new MathLog10Function());
-    addFunction(new MathLogFunction());
-    addFunction(new MathSinFunction());
-    addFunction(new MathCosFunction());
-    addFunction(new MathTanFunction());
-
-    // seq lib
-    addFunction(new SeqMapFunction());
-    addFunction(new SeqReduceFunction());
-    addFunction(new SeqFilterFunction());
-    addFunction(new SeqSortFunction());
-    addFunction(new SeqIncludeFunction());
-    addFunction(new SeqCountFunction());
-    addFunction(new SeqEveryFunction());
-    addFunction(new SeqNotAnyFunction());
-    addFunction(new SeqSomeFunction());
-    addFunction(new SeqMakePredicateFunFunction("seq.eq", OperatorType.EQ));
-    addFunction(new SeqMakePredicateFunFunction("seq.neq", OperatorType.NEQ));
-    addFunction(new SeqMakePredicateFunFunction("seq.lt", OperatorType.LT));
-    addFunction(new SeqMakePredicateFunFunction("seq.le", OperatorType.LE));
-    addFunction(new SeqMakePredicateFunFunction("seq.gt", OperatorType.GT));
-    addFunction(new SeqMakePredicateFunFunction("seq.ge", OperatorType.GE));
-    addFunction(new SeqCompsitePredFunFunction("seq.and", LogicOp.AND));
-    addFunction(new SeqCompsitePredFunFunction("seq.or", LogicOp.OR));
-    addFunction(new SeqMakePredicateFunFunction("seq.true", OperatorType.EQ, AviatorBoolean.TRUE));
-    addFunction(
-        new SeqMakePredicateFunFunction("seq.false", OperatorType.EQ, AviatorBoolean.FALSE));
-    addFunction(new SeqMakePredicateFunFunction("seq.nil", OperatorType.EQ, AviatorNil.NIL));
-    addFunction(new SeqMakePredicateFunFunction("seq.exists", OperatorType.NEQ, AviatorNil.NIL));
-    // load custom functions.
-    CustomFunctionLoader.load();
-  }
-
-  /**
-   * Compiled Expression cache
-   */
-  private final static ConcurrentHashMap<String/* text expression */, FutureTask<Expression>/*
-                                                                                             * Compiled
-                                                                                             * expression
-                                                                                             * task
-                                                                                             */> cacheExpressions =
-      new ConcurrentHashMap<String, FutureTask<Expression>>();
 
 
   /**
@@ -339,15 +206,12 @@
    */
   @Deprecated
   public static void setOptimize(int value) {
-    if (value != COMPILE && value != EVAL) {
-      throw new IllegalArgumentException("Invlaid optimize option value");
-    }
-    setOption(Options.OPTIMIZE_LEVEL, value);
+    getInstance().setOption(Options.OPTIMIZE_LEVEL, value);
   }
 
 
   public static void setBYTECODE_VER(int nversion) {
-    BYTECODE_VER = nversion;
+    getInstance().setBytecodeVersion(nversion);
   }
 
 
@@ -360,7 +224,7 @@
    * Clear all cached compiled expression
    */
   public static void clearExpressionCache() {
-    cacheExpressions.clear();
+    getInstance().clearExpressionCache();
   }
 
 
@@ -370,7 +234,7 @@
    * @return
    */
   public static AviatorClassLoader getAviatorClassLoader() {
-    return getAviatorClassLoader(false);
+    return getInstance().getAviatorClassLoader();
   }
 
 
@@ -380,11 +244,7 @@
    * @return
    */
   public static AviatorClassLoader getAviatorClassLoader(boolean cached) {
-    if (cached) {
-      return aviatorClassLoader;
-    } else {
-      return new AviatorClassLoader(Thread.currentThread().getContextClassLoader());
-    }
+    return getInstance().getAviatorClassLoader(cached);
   }
 
 
@@ -394,12 +254,31 @@
    * @param function
    */
   public static void addFunction(AviatorFunction function) {
-    final String name = function.getName();
-    if (FUNC_MAP.containsKey(name)) {
-      System.out.println("[Aviator WARN] The function '" + name
-          + "' is already exists, but is replaced with new one.");
-    }
-    FUNC_MAP.put(name, function);
+    getInstance().addFunction(function);
+  }
+
+  /**
+   * Define a function by name and expression.
+   *
+   * @param name the function name
+   * @param expression the expression to be executed and it's result must be a function.
+   * @since 4.0.0
+   */
+  public void defineFunction(String name, String expression) {
+    getInstance().defineFunction(name, expression);
+  }
+
+
+  /**
+   * Define a function by name and expression with the execution env.
+   *
+   * @param name the function name
+   * @param expression the expression to be executed and it's result must be a function.
+   * @param env the expression execution env
+   * @since 4.0.0
+   */
+  public void defineFunction(String name, String expression, Map<String, Object> env) {
+    getInstance().defineFunction(name, expression, env);
   }
 
 
@@ -410,7 +289,7 @@
    * @return
    */
   public static AviatorFunction removeFunction(String name) {
-    return (AviatorFunction) FUNC_MAP.remove(name);
+    return getInstance().removeFunction(name);
   }
 
 
@@ -421,14 +300,7 @@
    * @return
    */
   public static AviatorFunction getFunction(String name) {
-    AviatorFunction function = (AviatorFunction) FUNC_MAP.get(name);
-    if (function == null && functionMissing != null) {
-      function = functionMissing.onFunctionMissing(name);
-    }
-    if (function == null) {
-      throw new ExpressionRuntimeException("Could not find function named '" + name + "'");
-    }
-    return function;
+    return getInstance().getFunction(name);
   }
 
   /**
@@ -437,7 +309,7 @@
    * @param function
    */
   public static void addOpFunction(OperatorType opType, AviatorFunction function) {
-    OPS_MAP.put(opType, function);
+    getInstance().addOpFunction(opType, function);
   }
 
 
@@ -450,7 +322,7 @@
    * @return
    */
   public static AviatorFunction getOpFunction(OperatorType opType) {
-    return OPS_MAP.get(opType);
+    return getInstance().getOpFunction(opType);
   }
 
   /**
@@ -461,7 +333,7 @@
    * @return
    */
   public static AviatorFunction removeOpFunction(OperatorType opType) {
-    return OPS_MAP.remove(opType);
+    return getInstance().removeOpFunction(opType);
   }
 
 
@@ -472,7 +344,7 @@
    * @return
    */
   public static boolean containsFunction(String name) {
-    return FUNC_MAP.containsKey(name);
+    return getInstance().containsFunction(name);
   }
 
   /**
@@ -482,7 +354,7 @@
    * @return
    */
   public static AviatorFunction removeFunction(AviatorFunction function) {
-    return removeFunction(function.getName());
+    return getInstance().removeFunction(function);
   }
 
 
@@ -505,12 +377,7 @@
    * @return
    */
   public static Expression getCachedExpression(String expression) {
-    FutureTask<Expression> task = cacheExpressions.get(expression);
-    if (task != null) {
-      return getCompiledExpression(expression, task);
-    } else {
-      return null;
-    }
+    return getInstance().getCachedExpression(expression);
   }
 
 
@@ -522,78 +389,7 @@
    * @return
    */
   public static Expression compile(final String expression, final boolean cached) {
-    if (expression == null || expression.trim().length() == 0) {
-      throw new CompileExpressionErrorException("Blank expression");
-    }
-
-    if (cached) {
-      FutureTask<Expression> task = cacheExpressions.get(expression);
-      if (task != null) {
-        return getCompiledExpression(expression, task);
-      }
-      task = new FutureTask<Expression>(new Callable<Expression>() {
-        @Override
-        public Expression call() throws Exception {
-          return innerCompile(expression, cached);
-        }
-
-      });
-      FutureTask<Expression> existedTask = cacheExpressions.putIfAbsent(expression, task);
-      if (existedTask == null) {
-        existedTask = task;
-        existedTask.run();
-      }
-      return getCompiledExpression(expression, existedTask);
-
-    } else {
-      return innerCompile(expression, cached);
-    }
-
-  }
-
-
-  private static Expression getCompiledExpression(final String expression,
-      FutureTask<Expression> task) {
-    try {
-      return task.get();
-    } catch (Exception e) {
-      cacheExpressions.remove(expression);
-      throw new CompileExpressionErrorException("Compile expression failure:" + expression, e);
-    }
-  }
-
-
-  private static Expression innerCompile(final String expression, boolean cached) {
-    ExpressionLexer lexer = new ExpressionLexer(expression);
-    CodeGenerator codeGenerator = newCodeGenerator(cached);
-    ExpressionParser parser = new ExpressionParser(lexer, codeGenerator);
-    Expression exp = parser.parse();
-    if ((boolean) getOption(Options.TRACE_EVAL)) {
-      ((BaseExpression) exp).setExpression(expression);
-    }
-    return exp;
-  }
-
-
-  private static int getOptimizeLevel() {
-    return getOption(Options.OPTIMIZE_LEVEL);
-  }
-
-
-  private static CodeGenerator newCodeGenerator(boolean cached) {
-    switch (getOptimizeLevel()) {
-      case COMPILE:
-        ASMCodeGenerator asmCodeGenerator = new ASMCodeGenerator(getAviatorClassLoader(cached),
-            traceOutputStream, (Boolean) getOption(Options.TRACE));
-        asmCodeGenerator.start();
-        return asmCodeGenerator;
-      case EVAL:
-        return new OptimizeCodeGenerator(getAviatorClassLoader(cached), traceOutputStream,
-            (Boolean) getOption(Options.TRACE));
-      default:
-        throw new IllegalArgumentException("Unknow option " + getOptimizeLevel());
-    }
-
+    return getInstance().compile(expression, cached);
   }
 
 
@@ -617,29 +413,7 @@
    * @return
    */
   public static Object exec(String expression, Object... values) {
-    if (getOptimizeLevel() != EVAL) {
-      throw new IllegalStateException("Aviator evaluator is not in EVAL mode.");
-    }
-    Expression compiledExpression = compile(expression, true);
-    if (compiledExpression != null) {
-      List<String> vars = compiledExpression.getVariableNames();
-      if (!vars.isEmpty()) {
-        int valLen = values == null ? 0 : values.length;
-        if (valLen != vars.size()) {
-          throw new IllegalArgumentException("Expect " + vars.size() + " values,but has " + valLen);
-        }
-        Map<String, Object> env = new HashMap<String, Object>();
-        int i = 0;
-        for (String var : vars) {
-          env.put(var, values[i++]);
-        }
-        return compiledExpression.execute(env);
-      } else {
-        return compiledExpression.execute();
-      }
-    } else {
-      throw new ExpressionRuntimeException("Null compiled expression for " + expression);
-    }
+    return getInstance().exec(expression, values);
   }
 
 
@@ -651,12 +425,7 @@
    * @param cached Whether to cache the compiled result,make true to cache it.
    */
   public static Object execute(String expression, Map<String, Object> env, boolean cached) {
-    Expression compiledExpression = compile(expression, cached);
-    if (compiledExpression != null) {
-      return compiledExpression.execute(env);
-    } else {
-      throw new ExpressionRuntimeException("Null compiled expression for " + expression);
-    }
+    return getInstance().execute(expression, env, cached);
   }
 
 
@@ -678,7 +447,7 @@
    * @param expression
    */
   public static void invalidateCache(String expression) {
-    cacheExpressions.remove(expression);
+    getInstance().invalidateCache(expression);
   }
 
 
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/BaseExpression.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/BaseExpression.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/BaseExpression.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/BaseExpression.java	2024-09-08 01:36:08.329768078 +1000
@@ -3,6 +3,8 @@
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Map;
+import com.googlecode.aviator.utils.Env;
 
 
 /**
@@ -16,11 +18,12 @@
   private List<String> varNames;
   private List<String> varFullNames;
   private String expression;
+  protected AviatorEvaluatorInstance instance;
 
-
-  public BaseExpression(List<String> varNames) {
+  public BaseExpression(AviatorEvaluatorInstance instance, List<String> varNames) {
     super();
     this.varFullNames = varNames;
+    this.instance = instance;
     LinkedHashSet<String> tmp = new LinkedHashSet<String>(varNames.size());
     // process nested names
     for (String name : varNames) {
@@ -75,4 +78,11 @@
     return this.varNames;
   }
 
+
+  protected Env newEnv(Map<String, Object> map) {
+    Env env = new Env(map);
+    env.setInstance(this.instance);
+    return env;
+  }
+
 }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/ClassExpression.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/ClassExpression.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/ClassExpression.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/ClassExpression.java	2024-09-08 01:36:08.329768078 +1000
@@ -19,7 +19,10 @@
 import java.util.List;
 import java.util.Map;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
-import com.googlecode.aviator.runtime.op.OperationRuntime;
+import com.googlecode.aviator.runtime.LambdaFunctionBootstrap;
+import com.googlecode.aviator.runtime.RuntimeUtils;
+import com.googlecode.aviator.runtime.function.LambdaFunction;
+import com.googlecode.aviator.utils.Env;
 
 
 /**
@@ -30,10 +33,28 @@
  */
 public abstract class ClassExpression extends BaseExpression {
 
-  public ClassExpression(List<String> varNames) {
-    super(varNames);
+  protected Map<String, LambdaFunctionBootstrap> lambdaBootstraps;
+
+
+  public Map<String, LambdaFunctionBootstrap> getLambdaBootstraps() {
+    return lambdaBootstraps;
+  }
+
+  public void setLambdaBootstraps(Map<String, LambdaFunctionBootstrap> lambdaBootstraps) {
+    this.lambdaBootstraps = lambdaBootstraps;
   }
 
+  public ClassExpression(AviatorEvaluatorInstance instance, List<String> varNames) {
+    super(instance, varNames);
+  }
+
+  public LambdaFunction newLambda(Env env, String name) {
+    LambdaFunctionBootstrap bootstrap = this.lambdaBootstraps.get(name);
+    if (bootstrap == null) {
+      throw new ExpressionRuntimeException("Lambda " + name + " not found");
+    }
+    return bootstrap.newInstance(env);
+  }
 
   /*
    * (non-Javadoc)
@@ -41,26 +62,26 @@
    * @see com.googlecode.aviator.IExpression#execute(java.util.Map)
    */
   @Override
-  public Object execute(Map<String, Object> env) {
-    if (env == null) {
-      env = Collections.emptyMap();
-    }
-
-    if (OperationRuntime.isTracedEval()) {
-      OperationRuntime.printTrace("Tracing: " + this.getExpression());
+  public Object execute(Map<String, Object> map) {
+    if (map == null) {
+      map = Collections.emptyMap();
     }
+    Env env = newEnv(map);
     try {
-      return this.execute0(env);
+      Object result = this.execute0(env);
+      if (RuntimeUtils.isTracedEval(env)) {
+        RuntimeUtils.printTrace(env, "Result : " + result);
+      }
+      return result;
     } catch (ExpressionRuntimeException e) {
       throw e;
     } catch (Throwable e) {
       throw new ExpressionRuntimeException("Execute expression error", e);
     }
-
   }
 
 
-  public abstract Object execute0(Map<String, Object> env);
+  public abstract Object execute0(Env env);
 
 
   /**
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator: ClassPathConfigFunctionLoader.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java	2024-09-08 01:36:08.329768078 +1000
@@ -39,32 +39,42 @@
 import static com.googlecode.aviator.asm.Opcodes.INVOKESTATIC;
 import static com.googlecode.aviator.asm.Opcodes.INVOKEVIRTUAL;
 import static com.googlecode.aviator.asm.Opcodes.NEW;
+import static com.googlecode.aviator.asm.Opcodes.POP;
 import static com.googlecode.aviator.asm.Opcodes.PUTFIELD;
 import static com.googlecode.aviator.asm.Opcodes.RETURN;
 import static com.googlecode.aviator.asm.Opcodes.SWAP;
 import java.io.OutputStream;
 import java.lang.reflect.Constructor;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
-import java.util.LinkedHashMap;
+import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Stack;
 import java.util.concurrent.atomic.AtomicLong;
-import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.AviatorEvaluatorInstance;
+import com.googlecode.aviator.ClassExpression;
 import com.googlecode.aviator.Expression;
+import com.googlecode.aviator.Options;
 import com.googlecode.aviator.asm.ClassWriter;
 import com.googlecode.aviator.asm.Label;
 import com.googlecode.aviator.asm.MethodVisitor;
 import com.googlecode.aviator.asm.Opcodes;
 import com.googlecode.aviator.code.CodeGenerator;
+import com.googlecode.aviator.code.LambdaGenerator;
 import com.googlecode.aviator.exception.CompileExpressionErrorException;
+import com.googlecode.aviator.exception.ExpressionRuntimeException;
 import com.googlecode.aviator.lexer.token.NumberToken;
 import com.googlecode.aviator.lexer.token.OperatorType;
 import com.googlecode.aviator.lexer.token.Token;
+import com.googlecode.aviator.lexer.token.Token.TokenType;
 import com.googlecode.aviator.lexer.token.Variable;
 import com.googlecode.aviator.parser.AviatorClassLoader;
+import com.googlecode.aviator.parser.Parser;
+import com.googlecode.aviator.runtime.LambdaFunctionBootstrap;
 import com.googlecode.aviator.runtime.op.OperationRuntime;
+import com.googlecode.aviator.utils.Env;
 import com.googlecode.aviator.utils.TypeUtils;
 
 
@@ -75,7 +85,14 @@
  *
  */
 public class ASMCodeGenerator implements CodeGenerator {
-  private static final String FIELD_PREFIX = "var_";
+
+  private static final String FIELD_PREFIX = "f";
+  // evaluator instance
+  private AviatorEvaluatorInstance instance;
+  /**
+   * Compile environment only has the *instance*.
+   */
+  private Env compileEnv;
   // Class Writer to generate class
   // private final ClassWriter clazzWriter;
   // Trace visitor
@@ -88,6 +105,10 @@
   private final String className;
   // Class loader to define generated class
   private final AviatorClassLoader classLoader;
+  // lambda function generator
+  private LambdaGenerator lambdaGenerator;
+  // parser
+  private Parser parser;
 
   private static final AtomicLong CLASS_COUNTER = new AtomicLong();
 
@@ -101,22 +122,36 @@
 
   private int fieldCounter = 0;
 
-  private final Map<String/* variable name */, String/* inner var name */> innerVarMap =
-      new HashMap<String, String>();
-
-  private final Map<String/* method name */, String/* inner method name */> innerMethodMap =
-      new HashMap<String, String>();
+  private Map<String/* variable name */, String/* inner var name */> innerVars =
+      Collections.emptyMap();
+  private Map<String/* method name */, String/* inner method name */> innerMethodMap =
+      Collections.emptyMap();
 
-  private Map<String, Integer/* counter */> varTokens = new LinkedHashMap<String, Integer>();
-  private Map<String, Integer/* counter */> methodTokens = new HashMap<String, Integer>();
+  private Map<String, Integer/* counter */> varTokens = Collections.emptyMap();
+  private Map<String, Integer/* counter */> methodTokens = Collections.emptyMap();
 
   private final Map<Label, Map<String/* inner name */, Integer/* local index */>> labelNameIndexMap =
-      new HashMap<Label, Map<String, Integer>>();
+      new IdentityHashMap<Label, Map<String, Integer>>();
+
+  /**
+   * Compiled lambda functions.
+   */
+  private Map<String, LambdaFunctionBootstrap> lambdaBootstraps;
 
   private static final Label START_LABEL = new Label();
 
   private Label currentLabel = START_LABEL;
 
+  /**
+   * parent code generator when compiling lambda.
+   */
+  private CodeGenerator parentCodeGenerator;
+
+  @Override
+  public void setParser(Parser parser) {
+    this.parser = parser;
+  }
+
 
   private void setMaxStacks(int newMaxStacks) {
     if (newMaxStacks > this.maxStacks) {
@@ -125,8 +160,12 @@
   }
 
 
-  public ASMCodeGenerator(AviatorClassLoader classLoader, OutputStream traceOut, boolean trace) {
+  public ASMCodeGenerator(AviatorEvaluatorInstance instance, AviatorClassLoader classLoader,
+      OutputStream traceOut, boolean trace) {
     this.classLoader = classLoader;
+    this.instance = instance;
+    this.compileEnv = new Env();
+    this.compileEnv.setInstance(this.instance);
     // Generate inner class name
     this.className = "Script_" + System.currentTimeMillis() + "_" + CLASS_COUNTER.getAndIncrement();
     // Auto compute frames
@@ -141,6 +180,17 @@
   }
 
 
+
+  public AviatorClassLoader getClassLoader() {
+    return classLoader;
+  }
+
+
+  LambdaGenerator getLambdaGenerator() {
+    return lambdaGenerator;
+  }
+
+
   public void start() {
     this.makeConstructor();
     this.startVisitMethodCode();
@@ -149,8 +199,8 @@
 
   private void startVisitMethodCode() {
     this.mv = this.classWriter.visitMethod(ACC_PUBLIC + +ACC_FINAL, "execute0",
-        "(Ljava/util/Map;)Ljava/lang/Object;",
-        "(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;)Ljava/lang/Object;", null);
+        "(Lcom/googlecode/aviator/utils/Env;)Ljava/lang/Object;",
+        "(Lcom/googlecode/aviator/utils/Env;)Ljava/lang/Object;", null);
     this.mv.visitCode();
   }
 
@@ -189,15 +239,16 @@
    */
   private void makeConstructor() {
     {
-      this.mv =
-          this.classWriter.visitMethod(ACC_PUBLIC, "<init>", "(Ljava/util/List;)V", null, null);
+      this.mv = this.classWriter.visitMethod(ACC_PUBLIC, "<init>",
+          "(Lcom/googlecode/aviator/AviatorEvaluatorInstance;Ljava/util/List;)V", null, null);
       this.mv.visitCode();
       this.mv.visitVarInsn(ALOAD, 0);
       this.mv.visitVarInsn(ALOAD, 1);
+      this.mv.visitVarInsn(ALOAD, 2);
       this.mv.visitMethodInsn(INVOKESPECIAL, "com/googlecode/aviator/ClassExpression", "<init>",
-          "(Ljava/util/List;)V");
-      if (!this.innerVarMap.isEmpty()) {
-        for (Map.Entry<String, String> entry : this.innerVarMap.entrySet()) {
+          "(Lcom/googlecode/aviator/AviatorEvaluatorInstance;Ljava/util/List;)V");
+      if (!this.innerVars.isEmpty()) {
+        for (Map.Entry<String, String> entry : this.innerVars.entrySet()) {
           String outterName = entry.getKey();
           String innerName = entry.getValue();
           this.mv.visitVarInsn(ALOAD, 0);
@@ -216,8 +267,9 @@
           String outterName = entry.getKey();
           String innerName = entry.getValue();
           this.mv.visitVarInsn(ALOAD, 0);
+          this.mv.visitVarInsn(ALOAD, 1);
           this.mv.visitLdcInsn(outterName);
-          this.mv.visitMethodInsn(INVOKESTATIC, "com/googlecode/aviator/AviatorEvaluator",
+          this.mv.visitMethodInsn(INVOKEVIRTUAL, "com/googlecode/aviator/AviatorEvaluatorInstance",
               "getFunction",
               "(Ljava/lang/String;)Lcom/googlecode/aviator/runtime/type/AviatorFunction;");
           this.mv.visitFieldInsn(PUTFIELD, this.className, innerName,
@@ -233,7 +285,7 @@
 
 
   private void visitClass() {
-    this.classWriter.visit(AviatorEvaluator.BYTECODE_VER, ACC_PUBLIC + ACC_SUPER, this.className,
+    this.classWriter.visit(instance.getBytecodeVersion(), ACC_PUBLIC + ACC_SUPER, this.className,
         null, "com/googlecode/aviator/ClassExpression", null);
   }
 
@@ -360,7 +412,7 @@
 
 
   private void visitRightBranch(int ints, OperatorType opType) {
-    if (!OperationRuntime.hasRuntimeContext(opType)) {
+    if (!OperationRuntime.hasRuntimeContext(this.compileEnv, opType)) {
       this.loadEnv();
       String first = "TRUE";
       String second = "FALSE";
@@ -439,6 +491,13 @@
   }
 
 
+  @Override
+  public void onTernaryEnd(Token<?> lookhead) {
+    while (--this.operandsCount > 0) {
+      this.mv.visitInsn(POP);
+    }
+  }
+
   private Label popLabel1() {
     return this.l1stack.pop();
   }
@@ -484,7 +543,7 @@
 
 
   private void visitLeftBranch(int ints, OperatorType opType) {
-    if (!OperationRuntime.hasRuntimeContext(opType)) {
+    if (!OperationRuntime.hasRuntimeContext(this.compileEnv, opType)) {
       this.visitBoolean();
       Label l0 = this.makeLabel();
       this.pushLabel0(l0);
@@ -524,7 +583,7 @@
 
 
   private void visitCompare(int ints, OperatorType opType) {
-    if (!OperationRuntime.hasRuntimeContext(opType)) {
+    if (!OperationRuntime.hasRuntimeContext(this.compileEnv, opType)) {
       this.mv.visitMethodInsn(INVOKEVIRTUAL, "com/googlecode/aviator/runtime/type/AviatorObject",
           "compare", "(Lcom/googlecode/aviator/runtime/type/AviatorObject;Ljava/util/Map;)I");
       Label l0 = this.makeLabel();
@@ -593,7 +652,7 @@
   }
 
   private void visitBinOperator(OperatorType opType, String methodName) {
-    if (!OperationRuntime.hasRuntimeContext(opType)) {
+    if (!OperationRuntime.hasRuntimeContext(this.compileEnv, opType)) {
       // swap arguments for regular-expression match operator.
       if (opType == OperatorType.MATCH) {
         this.mv.visitInsn(SWAP);
@@ -618,7 +677,7 @@
     this.mv.visitTypeInsn(CHECKCAST, "com/googlecode/aviator/runtime/type/AviatorObject");
     this.loadEnv();
 
-    if (!OperationRuntime.hasRuntimeContext(opType)) {
+    if (!OperationRuntime.hasRuntimeContext(this.compileEnv, opType)) {
       this.mv.visitMethodInsn(INVOKEVIRTUAL, "com/googlecode/aviator/runtime/type/AviatorObject",
           methodName, "(Ljava/util/Map;)Lcom/googlecode/aviator/runtime/type/AviatorObject;");
     } else {
@@ -666,10 +725,18 @@
 
     byte[] bytes = this.classWriter.toByteArray();
     try {
-      Class<?> defineClass = ClassDefiner.defineClass(this.className, bytes, this.classLoader);
-      Constructor<?> constructor = defineClass.getConstructor(List.class);
-      return (Expression) constructor.newInstance(new ArrayList<String>(this.varTokens.keySet()));
+      Class<?> defineClass =
+          ClassDefiner.defineClass(this.className, Expression.class, bytes, this.classLoader);
+      Constructor<?> constructor =
+          defineClass.getConstructor(AviatorEvaluatorInstance.class, List.class);
+      ClassExpression exp = (ClassExpression) constructor.newInstance(this.instance,
+          new ArrayList<String>(this.varTokens.keySet()));
+      exp.setLambdaBootstraps(lambdaBootstraps);
+      return exp;
     } catch (Exception e) {
+      if (e.getCause() instanceof ExpressionRuntimeException) {
+        throw (ExpressionRuntimeException) e.getCause();
+      }
       throw new CompileExpressionErrorException("define class error", e);
     }
   }
@@ -703,10 +770,13 @@
           this.mv.visitMethodInsn(INVOKESTATIC, "com/googlecode/aviator/runtime/type/AviatorBigInt",
               "valueOf", "(Ljava/lang/String;)Lcom/googlecode/aviator/runtime/type/AviatorBigInt;");
         } else if (TypeUtils.isDecimal(number)) {
+          this.loadEnv();
+          // this.pushOperand();
           this.mv.visitLdcInsn(numberToken.getLexeme());
           this.mv.visitMethodInsn(INVOKESTATIC,
               "com/googlecode/aviator/runtime/type/AviatorDecimal", "valueOf",
-              "(Ljava/lang/String;)Lcom/googlecode/aviator/runtime/type/AviatorDecimal;");
+              "(Ljava/util/Map;Ljava/lang/String;)Lcom/googlecode/aviator/runtime/type/AviatorDecimal;");
+          this.popOperand();
         } else if (TypeUtils.isDouble(number)) {
           this.mv.visitLdcInsn(number);
           this.mv.visitMethodInsn(INVOKESTATIC, "com/googlecode/aviator/runtime/type/AviatorDouble",
@@ -760,7 +830,7 @@
           this.pushOperand();
         } else {
           String outterVarName = variable.getLexeme();
-          String innerVarName = this.innerVarMap.get(outterVarName);
+          String innerVarName = this.innerVars.get(outterVarName);
           if (innerVarName != null) {
             // Is it stored in local?
             Map<String, Integer> name2Index = this.labelNameIndexMap.get(this.currentLabel);
@@ -811,12 +881,18 @@
   }
 
 
+  public void setLambdaBootstraps(Map<String, LambdaFunctionBootstrap> lambdaBootstraps) {
+    this.lambdaBootstraps = lambdaBootstraps;
+  }
+
+
   public void initVariables(Map<String, Integer/* counter */> varTokens) {
     this.varTokens = varTokens;
+    this.innerVars = new HashMap<String, String>(varTokens.size());
     for (String outterVarName : varTokens.keySet()) {
       // Use inner variable name instead of outter variable name
       String innerVarName = this.getInnerName(outterVarName);
-      this.innerVarMap.put(outterVarName, innerVarName);
+      this.innerVars.put(outterVarName, innerVarName);
       this.classWriter.visitField(ACC_PRIVATE + ACC_FINAL, innerVarName,
           "Lcom/googlecode/aviator/runtime/type/AviatorJavaType;", null, null).visitEnd();
 
@@ -826,13 +902,13 @@
 
   public void initMethods(Map<String, Integer/* counter */> methods) {
     this.methodTokens = methods;
+    this.innerMethodMap = new HashMap<String, String>(methods.size());
     for (String outterMethodName : methods.keySet()) {
       // Use inner method name instead of outter method name
       String innerMethodName = this.getInnerName(outterMethodName);
       this.innerMethodMap.put(outterMethodName, innerMethodName);
       this.classWriter.visitField(ACC_PRIVATE + ACC_FINAL, innerMethodName,
           "Lcom/googlecode/aviator/runtime/type/AviatorFunction;", null, null).visitEnd();
-
     }
   }
 
@@ -842,7 +918,7 @@
   }
 
 
-  private String getInvokeMethodDesc(int paramCount) {
+  private static String getInvokeMethodDesc(int paramCount) {
     StringBuilder sb = new StringBuilder("(Ljava/util/Map;");
     if (paramCount <= 20) {
       for (int i = 0; i < paramCount; i++) {
@@ -890,7 +966,7 @@
       }
     }
     this.mv.visitMethodInsn(INVOKEINTERFACE, "com/googlecode/aviator/runtime/type/AviatorFunction",
-        "call", this.getInvokeMethodDesc(parameterCount));
+        "call", getInvokeMethodDesc(parameterCount));
 
     this.popOperand(); // method object
     this.popOperand(); // env map
@@ -976,7 +1052,7 @@
 
   @Override
   public void onArrayIndexEnd(Token<?> lookhead) {
-    if (!OperationRuntime.hasRuntimeContext(OperatorType.INDEX)) {
+    if (!OperationRuntime.hasRuntimeContext(this.compileEnv, OperatorType.INDEX)) {
       this.mv.visitMethodInsn(INVOKEVIRTUAL, "com/googlecode/aviator/runtime/type/AviatorObject",
           "getElement",
           "(Ljava/util/Map;Lcom/googlecode/aviator/runtime/type/AviatorObject;)Lcom/googlecode/aviator/runtime/type/AviatorObject;");
@@ -1000,14 +1076,78 @@
   }
 
 
+
+  @Override
+  public void onLambdaDefineStart(Token<?> lookhead) {
+    if (this.lambdaGenerator == null) {
+      // TODO cache?
+      this.lambdaGenerator = new LambdaGenerator(instance, this, this.parser, this.classLoader);
+      this.lambdaGenerator.setScopeInfo(this.parser.enterScope());
+    } else {
+      throw new CompileExpressionErrorException("Compile lambda error");
+    }
+  }
+
+  @Override
+  public void onLambdaArgument(Token<?> lookhead) {
+    this.lambdaGenerator.addArgument(lookhead.getLexeme());
+  }
+
+  @Override
+  public void onLambdaBodyStart(Token<?> lookhead) {
+    parentCodeGenerator = this.parser.getCodeGenerator();
+    this.parser.setCodeGenerator(this.lambdaGenerator);
+  }
+
+  @Override
+  public void onLambdaBodyEnd(Token<?> lookhead) {
+    this.lambdaGenerator.compileCallMethod();
+    LambdaFunctionBootstrap bootstrap = this.lambdaGenerator.getLmabdaBootstrap();
+    if (this.lambdaBootstraps == null) {
+      lambdaBootstraps = new HashMap<String, LambdaFunctionBootstrap>();
+    }
+    this.lambdaBootstraps.put(bootstrap.getName(), bootstrap);
+    genNewLambdaCode(bootstrap);
+    this.parser.restoreScope(this.lambdaGenerator.getScopeInfo());
+    this.lambdaGenerator = null;
+    this.parser.setCodeGenerator(this.parentCodeGenerator);
+  }
+
+
+  public void genNewLambdaCode(LambdaFunctionBootstrap bootstrap) {
+    this.mv.visitVarInsn(ALOAD, 0);
+    this.loadEnv();
+    this.mv.visitLdcInsn(bootstrap.getName());
+    this.mv.visitMethodInsn(INVOKEVIRTUAL, this.className, "newLambda",
+        "(Lcom/googlecode/aviator/utils/Env;Ljava/lang/String;)Lcom/googlecode/aviator/runtime/function/LambdaFunction;");
+    this.pushOperand();
+    this.pushOperand();
+    this.popOperand();
+    this.popOperand();
+  }
+
   @Override
   public void onMethodName(Token<?> lookhead) {
-    String outtterMethodName = lookhead.getLexeme();
-    String innerMethodName = this.innerMethodMap.get(outtterMethodName);
-    if (innerMethodName != null) {
-      this.loadAviatorFunction(outtterMethodName, innerMethodName);
+    String outtterMethodName = "lambda";
+    if (lookhead.getType() != TokenType.Delegate) {
+      outtterMethodName = lookhead.getLexeme();
+      String innerMethodName = this.innerMethodMap.get(outtterMethodName);
+      if (innerMethodName != null) {
+        this.loadAviatorFunction(outtterMethodName, innerMethodName);
+      } else {
+        this.createAviatorFunctionObject(outtterMethodName);
+      }
     } else {
-      this.createAviatorFunctionObject(outtterMethodName);
+      this.loadEnv();
+      this.mv.visitMethodInsn(INVOKESTATIC, "com/googlecode/aviator/runtime/RuntimeUtils",
+          "getFunction",
+          "(Ljava/lang/Object;Ljava/util/Map;)Lcom/googlecode/aviator/runtime/type/AviatorFunction;");
+      this.popOperand();
+    }
+    if (this.instance.getOption(Options.TRACE_EVAL)) {
+      this.mv.visitMethodInsn(INVOKESTATIC, "com/googlecode/aviator/runtime/function/TraceFunction",
+          "wrapTrace",
+          "(Lcom/googlecode/aviator/runtime/type/AviatorFunction;)Lcom/googlecode/aviator/runtime/type/AviatorFunction;");
     }
     this.loadEnv();
     this.methodMetaDataStack.push(new MethodMetaData(outtterMethodName));
@@ -1068,10 +1208,13 @@
 
 
   private void createAviatorFunctionObject(String methodName) {
+    this.loadEnv();
     this.pushOperand();
     this.mv.visitLdcInsn(methodName);
-    this.mv.visitMethodInsn(INVOKESTATIC, "com/googlecode/aviator/AviatorEvaluator", "getFunction",
-        "(Ljava/lang/String;)Lcom/googlecode/aviator/runtime/type/AviatorFunction;");
+    this.mv.visitMethodInsn(INVOKESTATIC, "com/googlecode/aviator/runtime/RuntimeUtils",
+        "getFunction",
+        "(Ljava/util/Map;Ljava/lang/String;)Lcom/googlecode/aviator/runtime/type/AviatorFunction;");
+    this.popOperand();
     this.popOperand();
     this.pushOperand();
   }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/asm/ClassDefiner.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/asm/ClassDefiner.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/asm/ClassDefiner.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/asm/ClassDefiner.java	2024-09-08 01:36:08.329768078 +1000
@@ -4,7 +4,6 @@
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.reflect.Field;
-import com.googlecode.aviator.Expression;
 import com.googlecode.aviator.parser.AviatorClassLoader;
 
 /**
@@ -41,17 +40,32 @@
     }
   }
 
+  private static boolean isPreferClassLoaderDefinerByDefault() {
+    String version = (System.getProperty("java.version"));
+    try {
+      return version != null && version.startsWith("1.7");
+    } catch (Throwable e) {
+      return false;
+    }
+  }
+
   private static boolean preferClassLoader =
-      Boolean.valueOf(System.getProperty("aviator.preferClassloaderDefiner", "false"));
+      Boolean.valueOf(System.getProperty("aviator.preferClassloaderDefiner",
+          String.valueOf(isPreferClassLoaderDefinerByDefault())));
+
+  static {
+    if (preferClassLoader) {
+      System.out.println("[Aviator WARN] aviator.preferClassloaderDefiner=" + preferClassLoader);
+    }
+  }
 
   private static int errorTimes = 0;
 
-  public static final Class<?> defineClass(String className, byte[] bytes,
+  public static final Class<?> defineClass(String className, Class<?> clazz, byte[] bytes,
       AviatorClassLoader classLoader) throws NoSuchFieldException, IllegalAccessException {
     if (!preferClassLoader && DEFINE_CLASS_HANDLE != null) {
       try {
-        Class<?> defineClass =
-            (Class<?>) DEFINE_CLASS_HANDLE.invokeExact(Expression.class, bytes, EMPTY_OBJS);
+        Class<?> defineClass = (Class<?>) DEFINE_CLASS_HANDLE.invokeExact(clazz, bytes, EMPTY_OBJS);
         return defineClass;
       } catch (Throwable e) {
         // fallback to class loader mode.
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/CodeGenerator.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/CodeGenerator.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/CodeGenerator.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/CodeGenerator.java	2024-09-08 01:36:08.329768078 +1000
@@ -17,16 +17,19 @@
 
 import com.googlecode.aviator.Expression;
 import com.googlecode.aviator.lexer.token.Token;
+import com.googlecode.aviator.parser.Parser;
 
 
 /**
  * Code generator interface
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public interface CodeGenerator {
 
+  public void setParser(Parser parser);
+
   public void onShiftRight(Token<?> lookhead);
 
 
@@ -74,6 +77,8 @@
 
   public void onTernaryRight(Token<?> lookhead);
 
+  public void onTernaryEnd(Token<?> lookhead);
+
 
   public void onJoinLeft(Token<?> lookhead);
 
@@ -110,27 +115,27 @@
 
   public void onNeg(Token<?> lookhead);
 
-
   public Expression getResult();
 
-
   public void onConstant(Token<?> lookhead);
 
-
   public void onMethodName(Token<?> lookhead);
 
-
   public void onMethodParameter(Token<?> lookhead);
 
-
   public void onMethodInvoke(Token<?> lookhead);
 
+  public void onLambdaDefineStart(Token<?> lookhead);
 
-  public void onArray(Token<?> lookhead);
+  public void onLambdaArgument(Token<?> lookhead);
 
+  public void onLambdaBodyStart(Token<?> lookhead);
 
-  public void onArrayIndexStart(Token<?> token);
+  public void onLambdaBodyEnd(Token<?> lookhead);
 
+  public void onArray(Token<?> lookhead);
+
+  public void onArrayIndexStart(Token<?> token);
 
   public void onArrayIndexEnd(Token<?> lookhead);
 
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code: LambdaGenerator.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/OptimizeCodeGenerator.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/OptimizeCodeGenerator.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/code/OptimizeCodeGenerator.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/code/OptimizeCodeGenerator.java	2024-09-08 01:36:08.329768078 +1000
@@ -22,10 +22,12 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import com.googlecode.aviator.AviatorEvaluator;
+import java.util.regex.Pattern;
+import com.googlecode.aviator.AviatorEvaluatorInstance;
 import com.googlecode.aviator.Expression;
 import com.googlecode.aviator.LiteralExpression;
 import com.googlecode.aviator.code.asm.ASMCodeGenerator;
+import com.googlecode.aviator.exception.CompileExpressionErrorException;
 import com.googlecode.aviator.lexer.token.DelegateToken;
 import com.googlecode.aviator.lexer.token.DelegateToken.DelegateTokenType;
 import com.googlecode.aviator.lexer.token.NumberToken;
@@ -36,13 +38,18 @@
 import com.googlecode.aviator.lexer.token.Token;
 import com.googlecode.aviator.lexer.token.Token.TokenType;
 import com.googlecode.aviator.lexer.token.Variable;
+import com.googlecode.aviator.parser.AviatorClassLoader;
+import com.googlecode.aviator.parser.Parser;
+import com.googlecode.aviator.runtime.LambdaFunctionBootstrap;
 import com.googlecode.aviator.runtime.op.OperationRuntime;
 import com.googlecode.aviator.runtime.type.AviatorBoolean;
 import com.googlecode.aviator.runtime.type.AviatorNil;
 import com.googlecode.aviator.runtime.type.AviatorNumber;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 import com.googlecode.aviator.runtime.type.AviatorPattern;
+import com.googlecode.aviator.runtime.type.AviatorRuntimeJavaType;
 import com.googlecode.aviator.runtime.type.AviatorString;
+import com.googlecode.aviator.utils.Env;
 
 
 /**
@@ -52,19 +59,38 @@
  *
  */
 public class OptimizeCodeGenerator implements CodeGenerator {
-  private final ASMCodeGenerator asmCodeGenerator;
+  private ASMCodeGenerator codeGen;
 
   private final List<Token<?>> tokenList = new ArrayList<Token<?>>();
 
+  private LambdaGenerator lambdaGenerator;
+
+  private CodeGenerator parentCodeGenerator;
+
   private boolean trace = false;
+  private AviatorEvaluatorInstance instance;
+  // the expression parser
+  private Parser parser;
+
+  /**
+   * Compiled lambda functions.
+   */
+  private Map<String, LambdaFunctionBootstrap> lambdaBootstraps;
 
 
-  public OptimizeCodeGenerator(ClassLoader classLoader, OutputStream traceOutStream,
-      boolean trace) {
-    this.asmCodeGenerator =
-        new ASMCodeGenerator(AviatorEvaluator.getAviatorClassLoader(), traceOutStream, trace);
+  public OptimizeCodeGenerator(AviatorEvaluatorInstance instance, ClassLoader classLoader,
+      OutputStream traceOutStream, boolean trace) {
+    this.instance = instance;
+    this.codeGen =
+        new ASMCodeGenerator(instance, (AviatorClassLoader) classLoader, traceOutStream, trace);
     this.trace = trace;
+  }
+
 
+  @Override
+  public void setParser(Parser parser) {
+    this.parser = parser;
+    this.codeGen.setParser(parser);
   }
 
 
@@ -168,7 +194,9 @@
 
       }
       // execute it now
-      AviatorObject result = OperationRuntime.eval(args, operatorType);
+      Env env = new Env();
+      env.setInstance(this.instance);
+      AviatorObject result = OperationRuntime.eval(env, args, operatorType);
       // set result as token to tokenList for next executing
       this.tokenList.set(operatorIndex, this.getTokenFromOperand(result));
       return 1;
@@ -221,6 +249,26 @@
   private Token<?> getTokenFromOperand(AviatorObject operand) {
     Token<?> token = null;
     switch (operand.getAviatorType()) {
+      case JavaType:
+        if (operand instanceof AviatorRuntimeJavaType) {
+          Object val = operand.getValue(null);
+          if (val == null) {
+            token = Variable.NIL;
+          } else if (val instanceof Number) {
+            token = new NumberToken((Number) val, val.toString());
+          } else if (val instanceof String || val instanceof Character) {
+            token = new StringToken(val.toString(), -1);
+          } else if (val instanceof Pattern) {
+            token = new PatternToken(((Pattern) val).pattern(), -1);
+          } else if (val instanceof Boolean) {
+            token = (boolean) val ? Variable.TRUE : Variable.FALSE;
+          } else {
+            throw new CompileExpressionErrorException("Invalid operand:" + operand.desc(null));
+          }
+        } else {
+          throw new CompileExpressionErrorException("Invalid operand:" + operand.desc(null));
+        }
+        break;
       case Boolean:
         token = operand.booleanValue(null) ? Variable.TRUE : Variable.FALSE;
         break;
@@ -314,6 +362,9 @@
           DelegateToken delegateToken = (DelegateToken) token;
           if (delegateToken.getDelegateTokenType() == DelegateTokenType.Method_Name) {
             Token<?> realToken = delegateToken.getToken();
+            if (realToken == null) {
+              continue;
+            }
             if (realToken.getType() == TokenType.Variable) {
               String methodName = token.getLexeme();
               if (!methods.containsKey(methodName)) {
@@ -342,25 +393,27 @@
     // Last token is a literal token,then return a LiteralExpression
     if (this.tokenList.size() <= 1) {
       if (this.tokenList.isEmpty()) {
-        return new LiteralExpression(null, new ArrayList<String>(variables.keySet()));
+        return new LiteralExpression(instance, null, new ArrayList<String>(variables.keySet()));
       }
       final Token<?> lastToken = this.tokenList.get(0);
       if (this.isLiteralToken(lastToken)) {
-        return new LiteralExpression(this.getAviatorObjectFromToken(lastToken).getValue(null),
+        return new LiteralExpression(instance,
+            this.getAviatorObjectFromToken(lastToken).getValue(null),
             new ArrayList<String>(variables.keySet()));
       }
     }
 
     // get result from asm
-    return this.asmCodeGenerator.getResult();
+    return this.codeGen.getResult();
   }
 
 
   private void callASM(Map<String, Integer/* counter */> variables,
       Map<String, Integer/* counter */> methods) {
-    this.asmCodeGenerator.initVariables(variables);
-    this.asmCodeGenerator.initMethods(methods);
-    this.asmCodeGenerator.start();
+    this.codeGen.initVariables(variables);
+    this.codeGen.initMethods(methods);
+    this.codeGen.setLambdaBootstraps(lambdaBootstraps);
+    this.codeGen.start();
 
     for (int i = 0; i < this.tokenList.size(); i++) {
       Token<?> token = this.tokenList.get(i);
@@ -370,82 +423,82 @@
 
           switch (op.getOperatorType()) {
             case ADD:
-              this.asmCodeGenerator.onAdd(token);
+              this.codeGen.onAdd(token);
               break;
             case SUB:
-              this.asmCodeGenerator.onSub(token);
+              this.codeGen.onSub(token);
               break;
             case MULT:
-              this.asmCodeGenerator.onMult(token);
+              this.codeGen.onMult(token);
               break;
             case DIV:
-              this.asmCodeGenerator.onDiv(token);
+              this.codeGen.onDiv(token);
               break;
             case MOD:
-              this.asmCodeGenerator.onMod(token);
+              this.codeGen.onMod(token);
               break;
             case EQ:
-              this.asmCodeGenerator.onEq(token);
+              this.codeGen.onEq(token);
               break;
             case NEQ:
-              this.asmCodeGenerator.onNeq(token);
+              this.codeGen.onNeq(token);
               break;
             case LT:
-              this.asmCodeGenerator.onLt(token);
+              this.codeGen.onLt(token);
               break;
             case LE:
-              this.asmCodeGenerator.onLe(token);
+              this.codeGen.onLe(token);
               break;
             case GT:
-              this.asmCodeGenerator.onGt(token);
+              this.codeGen.onGt(token);
               break;
             case GE:
-              this.asmCodeGenerator.onGe(token);
+              this.codeGen.onGe(token);
               break;
             case NOT:
-              this.asmCodeGenerator.onNot(token);
+              this.codeGen.onNot(token);
               break;
             case NEG:
-              this.asmCodeGenerator.onNeg(token);
+              this.codeGen.onNeg(token);
               break;
             case AND:
-              this.asmCodeGenerator.onAndRight(token);
+              this.codeGen.onAndRight(token);
               break;
             case OR:
-              this.asmCodeGenerator.onJoinRight(token);
+              this.codeGen.onJoinRight(token);
               break;
             case FUNC:
-              this.asmCodeGenerator.onMethodInvoke(token);
+              this.codeGen.onMethodInvoke(token);
               break;
             case INDEX:
-              this.asmCodeGenerator.onArrayIndexEnd(token);
+              this.codeGen.onArrayIndexEnd(token);
               break;
             case MATCH:
-              this.asmCodeGenerator.onMatch(token);
+              this.codeGen.onMatch(token);
               break;
             case TERNARY:
-              this.asmCodeGenerator.onTernaryRight(token);
+              this.codeGen.onTernaryRight(token);
               break;
             case BIT_AND:
-              this.asmCodeGenerator.onBitAnd(token);
+              this.codeGen.onBitAnd(token);
               break;
             case BIT_OR:
-              this.asmCodeGenerator.onBitOr(token);
+              this.codeGen.onBitOr(token);
               break;
             case BIT_XOR:
-              this.asmCodeGenerator.onBitXor(token);
+              this.codeGen.onBitXor(token);
               break;
             case BIT_NOT:
-              this.asmCodeGenerator.onBitNot(token);
+              this.codeGen.onBitNot(token);
               break;
             case SHIFT_LEFT:
-              this.asmCodeGenerator.onShiftLeft(token);
+              this.codeGen.onShiftLeft(token);
               break;
             case SHIFT_RIGHT:
-              this.asmCodeGenerator.onShiftRight(token);
+              this.codeGen.onShiftRight(token);
               break;
             case U_SHIFT_RIGHT:
-              this.asmCodeGenerator.onUnsignedShiftRight(token);
+              this.codeGen.onUnsignedShiftRight(token);
               break;
           }
           break;
@@ -454,34 +507,40 @@
           final Token<?> realToken = delegateToken.getToken();
           switch (delegateToken.getDelegateTokenType()) {
             case And_Left:
-              this.asmCodeGenerator.onAndLeft(realToken);
+              this.codeGen.onAndLeft(realToken);
               break;
             case Join_Left:
-              this.asmCodeGenerator.onJoinLeft(realToken);
+              this.codeGen.onJoinLeft(realToken);
               break;
             case Array:
-              this.asmCodeGenerator.onArray(realToken);
+              this.codeGen.onArray(realToken);
               break;
             case Index_Start:
-              this.asmCodeGenerator.onArrayIndexStart(realToken);
+              this.codeGen.onArrayIndexStart(realToken);
               break;
             case Ternary_Boolean:
-              this.asmCodeGenerator.onTernaryBoolean(realToken);
+              this.codeGen.onTernaryBoolean(realToken);
               break;
             case Ternary_Left:
-              this.asmCodeGenerator.onTernaryLeft(realToken);
+              this.codeGen.onTernaryLeft(realToken);
               break;
             case Method_Name:
-              this.asmCodeGenerator.onMethodName(realToken);
+              this.codeGen.onMethodName(realToken);
               break;
             case Method_Param:
-              this.asmCodeGenerator.onMethodParameter(realToken);
+              this.codeGen.onMethodParameter(realToken);
+              break;
+            case Lambda_New:
+              this.codeGen.genNewLambdaCode(delegateToken.getLambdaFunctionBootstrap());
+              break;
+            case Ternay_End:
+              this.codeGen.onTernaryEnd(realToken);
               break;
           }
           break;
 
         default:
-          this.asmCodeGenerator.onConstant(token);
+          this.codeGen.onConstant(token);
           break;
       }
 
@@ -646,6 +705,51 @@
   }
 
 
+
+  @Override
+  public void onLambdaDefineStart(Token<?> lookhead) {
+    if (this.lambdaGenerator == null) {
+      // TODO cache?
+      this.lambdaGenerator =
+          new LambdaGenerator(instance, this, this.parser, this.codeGen.getClassLoader());
+      this.lambdaGenerator.setScopeInfo(this.parser.enterScope());
+    } else {
+      throw new CompileExpressionErrorException("Compile lambda error");
+    }
+  }
+
+
+  @Override
+  public void onLambdaArgument(Token<?> lookhead) {
+    this.lambdaGenerator.addArgument(lookhead.getLexeme());
+  }
+
+
+  @Override
+  public void onLambdaBodyStart(Token<?> lookhead) {
+    parentCodeGenerator = this.parser.getCodeGenerator();
+    this.parser.setCodeGenerator(this.lambdaGenerator);
+  }
+
+
+  @Override
+  public void onLambdaBodyEnd(Token<?> lookhead) {
+    this.lambdaGenerator.compileCallMethod();
+    LambdaFunctionBootstrap bootstrap = this.lambdaGenerator.getLmabdaBootstrap();
+    if (this.lambdaBootstraps == null) {
+      lambdaBootstraps = new HashMap<String, LambdaFunctionBootstrap>();
+    }
+    this.lambdaBootstraps.put(bootstrap.getName(), bootstrap);
+    DelegateToken token = new DelegateToken(lookhead == null ? -1 : lookhead.getStartIndex(),
+        lookhead, DelegateTokenType.Lambda_New);
+    token.setLambdaFunctionBootstrap(bootstrap);
+    this.tokenList.add(token);
+    this.parser.restoreScope(this.lambdaGenerator.getScopeInfo());
+    this.lambdaGenerator = null;
+    this.parser.setCodeGenerator(this.parentCodeGenerator);
+  }
+
+
   @Override
   public void onMod(Token<?> lookhead) {
     this.tokenList
@@ -717,6 +821,13 @@
   }
 
 
+  @Override
+  public void onTernaryEnd(Token<?> lookhead) {
+    this.tokenList.add(new DelegateToken(lookhead == null ? -1 : lookhead.getStartIndex(), lookhead,
+        DelegateTokenType.Ternay_End));
+  }
+
+
   @Override
   public void onBitAnd(Token<?> lookhead) {
     this.tokenList.add(
Only in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator: CustomFunctionLoader.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/Expression.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/Expression.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/Expression.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/Expression.java	2024-09-08 01:36:08.329768078 +1000
@@ -34,7 +34,7 @@
    * @param env Binding variable environment
    * @return
    */
-  public abstract Object execute(Map<String, Object> env);
+  Object execute(Map<String, Object> env);
 
 
   /**
@@ -42,7 +42,7 @@
    * 
    * @return
    */
-  public abstract Object execute();
+  Object execute();
 
 
   /**
@@ -52,7 +52,7 @@
    * @see com.googlecode.aviator.AviatorEvaluator#EVAL
    * @return
    */
-  public List<String> getVariableNames();
+  List<String> getVariableNames();
 
 
   /**
@@ -61,6 +61,6 @@
    * 
    * @return
    */
-  public List<String> getVariableFullNames();
+  List<String> getVariableFullNames();
 
 }
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator: FunctionLoader.java
Only in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator: FunctionMissing.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java	2024-09-08 01:36:08.329768078 +1000
@@ -21,7 +21,7 @@
 import java.text.CharacterIterator;
 import java.text.StringCharacterIterator;
 import java.util.Stack;
-import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.AviatorEvaluatorInstance;
 import com.googlecode.aviator.Options;
 import com.googlecode.aviator.exception.CompileExpressionErrorException;
 import com.googlecode.aviator.exception.ExpressionSyntaxErrorException;
@@ -47,15 +47,22 @@
   private final SymbolTable symbolTable;
   // Tokens buffer
   private final Stack<Token<?>> tokenBuffer = new Stack<Token<?>>();
+  private AviatorEvaluatorInstance instance;
+  private String expression;
+  private MathContext mathContext;
+  private boolean parseFloatIntoDecimal;
 
-
-  public ExpressionLexer(String expression) {
+  public ExpressionLexer(AviatorEvaluatorInstance instance, String expression) {
     this.iterator = new StringCharacterIterator(expression);
+    this.expression = expression;
     this.symbolTable = new SymbolTable();
     this.peek = this.iterator.current();
+    this.instance = instance;
+    this.mathContext = this.instance.getOption(Options.MATH_CONTEXT);
+    this.parseFloatIntoDecimal =
+        this.instance.getOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL);
   }
 
-
   /**
    * Push back token
    *
@@ -231,16 +238,12 @@
           || this.peek == 'e' || this.peek == 'M' || this.peek == 'N');
       Number value;
       if (isBigDecimal) {
-        value = new BigDecimal(this.getBigNumberLexeme(sb),
-            (MathContext) AviatorEvaluator.getOption(Options.MATH_CONTEXT));
+        value = new BigDecimal(this.getBigNumberLexeme(sb), this.mathContext);
       } else if (isBigInt) {
         value = new BigInteger(this.getBigNumberLexeme(sb));
       } else if (hasDot) {
-        boolean alwaysUseDecimalAsDouble =
-            AviatorEvaluator.getOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL);
-        if (alwaysUseDecimalAsDouble) {
-          value = new BigDecimal(sb.toString(),
-              (MathContext) AviatorEvaluator.getOption(Options.MATH_CONTEXT));
+        if (this.parseFloatIntoDecimal) {
+          value = new BigDecimal(sb.toString(), this.mathContext);
         } else {
           value = dval;
         }
@@ -322,9 +325,12 @@
     return token;
   }
 
+  public String getScanString() {
+    return this.expression.substring(0, this.iterator.getIndex());
+  }
 
   private Token<?> reserverVar(String lexeme, Variable variable) {
-    // If it is a reserved word(true or false)
+    // If it is a reserved word(true/false/nil/lambda)
     if (this.symbolTable.contains(lexeme)) {
       return this.symbolTable.getVariable(lexeme);
     } else {
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/SymbolTable.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/SymbolTable.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/SymbolTable.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/SymbolTable.java	2024-09-08 01:36:08.329768078 +1000
@@ -22,9 +22,9 @@
 
 /**
  * Symbol table
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public class SymbolTable {
 
@@ -35,12 +35,13 @@
     reserve("true", Variable.TRUE);
     reserve("false", Variable.FALSE);
     reserve("nil", Variable.NIL);
+    reserve("lambda", Variable.LAMBDA);
   }
 
 
   /**
    * Reserve variable
-   * 
+   *
    * @param name
    * @param value
    */
@@ -51,7 +52,7 @@
 
   /**
    * Check variable has been reserved?
-   * 
+   *
    * @param name
    * @return
    */
@@ -62,7 +63,7 @@
 
   /**
    * Get symbold table
-   * 
+   *
    * @return
    */
   public Map<String, Variable> getTable() {
@@ -72,7 +73,7 @@
 
   /**
    * Get variable by name
-   * 
+   *
    * @param name
    * @return
    */
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/token/DelegateToken.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/token/DelegateToken.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/token/DelegateToken.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/token/DelegateToken.java	2024-09-08 01:36:08.329768078 +1000
@@ -1,21 +1,37 @@
 package com.googlecode.aviator.lexer.token;
 
 import java.util.Map;
+import com.googlecode.aviator.runtime.LambdaFunctionBootstrap;
 
 
 /**
  * Delegate token,wrap a token with special syntax structure
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public class DelegateToken extends AbstractToken<Token<?>> {
 
   private final Token<?> token;
   private final DelegateTokenType delegateTokenType;
+  private LambdaFunctionBootstrap lambdaFunctionBootstrap;
+
+
+
+  public LambdaFunctionBootstrap getLambdaFunctionBootstrap() {
+    return lambdaFunctionBootstrap;
+  }
+
+
+  public void setLambdaFunctionBootstrap(LambdaFunctionBootstrap lambdaFunctionBootstrap) {
+    this.lambdaFunctionBootstrap = lambdaFunctionBootstrap;
+  }
+
 
   public static enum DelegateTokenType {
-    And_Left, Join_Left, Ternary_Boolean, Ternary_Left, Array, Index_Start, Method_Name, Method_Param
+    And_Left, Join_Left, Ternary_Boolean, Ternary_Left, Array, Index_Start, //
+    Method_Name, Method_Param, Lambda_New, //
+    Ternay_End
   }
 
 
@@ -36,11 +52,13 @@
   }
 
 
+  @Override
   public com.googlecode.aviator.lexer.token.Token.TokenType getType() {
     return TokenType.Delegate;
   }
 
 
+  @Override
   public Token<?> getValue(Map<String, Object> env) {
     return this.token;
   }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/token/Variable.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/token/Variable.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/lexer/token/Variable.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/lexer/token/Variable.java	2024-09-08 01:36:08.329768078 +1000
@@ -20,12 +20,15 @@
 
 /**
  * Variable token
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public class Variable extends AbstractToken<Object> {
 
+  public static final String INSTANCE_VAR = "__instance__";
+  public static final String ENV_VAR = "__env__";
+
   public boolean isQuote() {
     return quote;
   }
@@ -74,11 +77,26 @@
   };
 
 
+  /**
+   * Lambda keyword
+   */
+  public static final Variable LAMBDA = new Variable("lambda", -1) {
+
+    @Override
+    public Object getValue(Map<String, Object> env) {
+      return false;
+    }
+
+  };
+
+
+  @Override
   public com.googlecode.aviator.lexer.token.Token.TokenType getType() {
     return TokenType.Variable;
   }
 
 
+  @Override
   public Object getValue(Map<String, Object> env) {
     if (env != null) {
       return env.get(this.lexeme);
@@ -95,7 +113,11 @@
 
   @Override
   public String toString() {
-    return "[type='string',lexeme='$" + getLexeme() + "',index=" + this.getStartIndex() + "]";
+    String index = ",index=" + getStartIndex();
+    if (getStartIndex() == -1) {
+      index = "";
+    }
+    return "[type='variable',lexeme='" + getLexeme() + "'" + index + "]";
   }
 
 }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/LiteralExpression.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/LiteralExpression.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/LiteralExpression.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/LiteralExpression.java	2024-09-08 01:36:08.329768078 +1000
@@ -17,7 +17,8 @@
  **/
 import java.util.List;
 import java.util.Map;
-import com.googlecode.aviator.runtime.op.OperationRuntime;
+import com.googlecode.aviator.runtime.RuntimeUtils;
+import com.googlecode.aviator.utils.Env;
 
 
 /**
@@ -31,16 +32,19 @@
   private final Object result;
 
 
-  public LiteralExpression(Object result, List<String> varNames) {
-    super(varNames);
+  public LiteralExpression(AviatorEvaluatorInstance instance, Object result,
+      List<String> varNames) {
+    super(instance, varNames);
     this.result = result;
   }
 
 
   @Override
-  public Object execute(Map<String, Object> env) {
-    if (OperationRuntime.isTracedEval()) {
-      OperationRuntime.printTrace("Tracing: " + this.getExpression());
+  public Object execute(Map<String, Object> map) {
+    Env env = newEnv(map);
+    if (RuntimeUtils.isTracedEval(env)) {
+      RuntimeUtils.printTrace(env, "Tracing: " + this.getExpression());
+      RuntimeUtils.printTrace(env, "Result : " + this.getExpression());
     }
     return this.result;
   }
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/parser: DepthState.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/parser/ExpressionParser.java	2024-09-08 01:36:08.329768078 +1000
@@ -16,26 +16,29 @@
 package com.googlecode.aviator.parser;
 
 import java.util.HashSet;
+import java.util.LinkedList;
 import java.util.Set;
-import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.AviatorEvaluatorInstance;
 import com.googlecode.aviator.Expression;
 import com.googlecode.aviator.code.CodeGenerator;
 import com.googlecode.aviator.exception.ExpressionSyntaxErrorException;
 import com.googlecode.aviator.lexer.ExpressionLexer;
 import com.googlecode.aviator.lexer.token.CharToken;
+import com.googlecode.aviator.lexer.token.DelegateToken;
+import com.googlecode.aviator.lexer.token.DelegateToken.DelegateTokenType;
 import com.googlecode.aviator.lexer.token.PatternToken;
 import com.googlecode.aviator.lexer.token.Token;
-import com.googlecode.aviator.lexer.token.Variable;
 import com.googlecode.aviator.lexer.token.Token.TokenType;
+import com.googlecode.aviator.lexer.token.Variable;
 
 
 /**
  * Syntex parser for expression
- * 
+ *
  * @author dennis
- * 
+ *
  */
-public class ExpressionParser {
+public class ExpressionParser implements Parser {
   private final ExpressionLexer lexer;
 
   static final Set<String> RESERVED_WORDS = new HashSet<String>();
@@ -51,37 +54,96 @@
 
   private Token<?> prevToken;
 
-  private final CodeGenerator codeGenerator;
+  private CodeGenerator codeGenerator;
 
-  // Paren depth
   private int parenDepth = 0;
 
   private int bracketDepth = 0;
 
+  private int lambdaDepth = 0;
+
+  private LinkedList<DepthState> depthState = new LinkedList<DepthState>();
+
+
   private boolean inPattern = false;
 
+  private AviatorEvaluatorInstance instance;
+
+
+  /*
+   * (non-Javadoc)
+   *
+   * @see com.googlecode.aviator.parser.Parser#getCodeGenerator()
+   */
+  @Override
+  public CodeGenerator getCodeGenerator() {
+    return codeGenerator;
+  }
+
+  /*
+   * (non-Javadoc)
+   *
+   * @see com.googlecode.aviator.parser.Parser#setCodeGenerator(com.googlecode.aviator.code.
+   * CodeGenerator)
+   */
+  @Override
+  public void setCodeGenerator(CodeGenerator codeGenerator) {
+    this.codeGenerator = codeGenerator;
+  }
 
-  public ExpressionParser(ExpressionLexer lexer, CodeGenerator codeGenerator) {
+  /*
+   * (non-Javadoc)
+   *
+   * @see com.googlecode.aviator.parser.Parser#enterScope()
+   */
+  @Override
+  public ScopeInfo enterScope() {
+    ScopeInfo info = new ScopeInfo(parenDepth, bracketDepth, lambdaDepth, depthState);
+    this.parenDepth = 0;
+    this.bracketDepth = 0;
+    this.lambdaDepth = 0;
+    this.depthState = new LinkedList<DepthState>();
+    return info;
+  }
+
+  /*
+   * (non-Javadoc)
+   *
+   * @see com.googlecode.aviator.parser.Parser#restoreScope(com.googlecode.aviator.parser.
+   * ExpressionParser.DepthInfo)
+   */
+  @Override
+  public void restoreScope(ScopeInfo info) {
+    this.parenDepth = info.parenDepth;
+    this.bracketDepth = info.bracketDepth;
+    this.lambdaDepth = info.lambdaDepth;
+    this.depthState = info.depthState;
+  }
+
+  public ExpressionParser(AviatorEvaluatorInstance instance, ExpressionLexer lexer,
+      CodeGenerator codeGenerator) {
     super();
+    this.instance = instance;
     this.lexer = lexer;
     this.lookhead = this.lexer.scan();
     if (this.lookhead == null) {
       throw new ExpressionSyntaxErrorException("Blank expression");
     }
     this.codeGenerator = codeGenerator;
+    this.codeGenerator.setParser(this);
   }
 
 
   public void ternary() {
     this.join();
-    if (this.lookhead == null || this.expectLexeme(":") || this.expectLexeme(",")) {
+    if (this.lookhead == null || this.expectChar(':') || this.expectChar(',')) {
       return;
     }
-    if (this.expectLexeme("?")) {
+    if (this.expectChar('?')) {
       this.move(true);
       this.codeGenerator.onTernaryBoolean(this.lookhead);
       this.ternary();
-      if (this.expectLexeme(":")) {
+      if (this.expectChar(':')) {
         this.move(true);
         this.codeGenerator.onTernaryLeft(this.lookhead);
         this.ternary();
@@ -89,25 +151,6 @@
       } else {
         this.reportSyntaxError("expect ':'");
       }
-    } else {
-      if (this.expectLexeme(")")) {
-        if (this.parenDepth > 0) {
-          return;
-        } else {
-          this.reportSyntaxError("Insert '(' to complete Expression");
-        }
-      }
-      if (this.expectLexeme("]")) {
-        if (this.bracketDepth > 0) {
-          return;
-        } else {
-          this.reportSyntaxError("Insert '[' to complete Expression");
-        }
-      }
-      if (!this.expectLexeme("(") && !this.expectLexeme("[")) {
-        this.reportSyntaxError("illegal expression");
-      }
-
     }
   }
 
@@ -128,9 +171,7 @@
       } else {
         if (this.lookhead == null) {
           break;
-        }
-
-        else {
+        } else {
           break;
         }
       }
@@ -140,21 +181,20 @@
 
 
   private boolean isJoinToken() {
-    return this.expectLexeme("|");
+    return this.expectChar('|');
   }
 
 
-  private boolean expectLexeme(String s) {
+  private boolean expectChar(char ch) {
     if (this.lookhead == null) {
       return false;
     }
-    return this.lookhead.getType() == TokenType.Char
-        && ((CharToken) this.lookhead).getLexeme().equals(s);
+    return this.lookhead.getType() == TokenType.Char && ((CharToken) this.lookhead).getCh() == ch;
   }
 
 
   private boolean isAndToken() {
-    return this.expectLexeme("&");
+    return this.expectChar('&');
   }
 
 
@@ -179,7 +219,7 @@
   public void xor() {
     this.bitAnd();
     while (true) {
-      if (this.expectLexeme("^")) {
+      if (this.expectChar('^')) {
         this.move(true);
         this.bitAnd();
         this.codeGenerator.onBitXor(this.lookhead);
@@ -232,13 +272,13 @@
   public void equality() {
     this.rel();
     while (true) {
-      if (this.expectLexeme("=")) {
+      if (this.expectChar('=')) {
         this.move(true);
-        if (this.expectLexeme("=")) {
+        if (this.expectChar('=')) {
           this.move(true);
           this.rel();
           this.codeGenerator.onEq(this.lookhead);
-        } else if (this.expectLexeme("~")) {
+        } else if (this.expectChar('~')) {
           // It is a regular expression
           this.move(true);
           this.rel();
@@ -246,9 +286,9 @@
         } else {
           this.reportSyntaxError("Aviator doesn't support assignment");
         }
-      } else if (this.expectLexeme("!")) {
+      } else if (this.expectChar('!')) {
         this.move(true);
-        if (this.expectLexeme("=")) {
+        if (this.expectChar('=')) {
           this.move(true);
           this.rel();
           this.codeGenerator.onNeq(this.lookhead);
@@ -265,9 +305,9 @@
   public void rel() {
     this.shift();
     while (true) {
-      if (this.expectLexeme("<")) {
+      if (this.expectChar('<')) {
         this.move(true);
-        if (this.expectLexeme("=")) {
+        if (this.expectChar('=')) {
           this.move(true);
           this.expr();
           this.codeGenerator.onLe(this.lookhead);
@@ -275,9 +315,9 @@
           this.expr();
           this.codeGenerator.onLt(this.lookhead);
         }
-      } else if (this.expectLexeme(">")) {
+      } else if (this.expectChar('>')) {
         this.move(true);
-        if (this.expectLexeme("=")) {
+        if (this.expectChar('=')) {
           this.move(true);
           this.expr();
           this.codeGenerator.onGe(this.lookhead);
@@ -295,9 +335,9 @@
   public void shift() {
     this.expr();
     while (true) {
-      if (this.expectLexeme("<")) {
+      if (this.expectChar('<')) {
         this.move(true);
-        if (this.expectLexeme("<")) {
+        if (this.expectChar('<')) {
           this.move(true);
           this.expr();
           this.codeGenerator.onShiftLeft(this.lookhead);
@@ -305,11 +345,11 @@
           this.back();
           break;
         }
-      } else if (this.expectLexeme(">")) {
+      } else if (this.expectChar('>')) {
         this.move(true);
-        if (this.expectLexeme(">")) {
+        if (this.expectChar('>')) {
           this.move(true);
-          if (this.expectLexeme(">")) {
+          if (this.expectChar('>')) {
             this.move(true);
             this.expr();
             this.codeGenerator.onUnsignedShiftRight(this.lookhead);
@@ -332,11 +372,11 @@
   public void expr() {
     this.term();
     while (true) {
-      if (this.expectLexeme("+")) {
+      if (this.expectChar('+')) {
         this.move(true);
         this.term();
         this.codeGenerator.onAdd(this.lookhead);
-      } else if (this.expectLexeme("-")) {
+      } else if (this.expectChar('-')) {
         this.move(true);
         this.term();
         this.codeGenerator.onSub(this.lookhead);
@@ -350,15 +390,15 @@
   public void term() {
     this.unary();
     while (true) {
-      if (this.expectLexeme("*")) {
+      if (this.expectChar('*')) {
         this.move(true);
         this.unary();
         this.codeGenerator.onMult(this.lookhead);
-      } else if (this.expectLexeme("/")) {
+      } else if (this.expectChar('/')) {
         this.move(true);
         this.unary();
         this.codeGenerator.onDiv(this.lookhead);
-      } else if (this.expectLexeme("%")) {
+      } else if (this.expectChar('%')) {
         this.move(true);
         this.unary();
         this.codeGenerator.onMod(this.lookhead);
@@ -370,30 +410,30 @@
 
 
   public void unary() {
-    if (this.expectLexeme("!")) {
+    if (this.expectChar('!')) {
       this.move(true);
       // check if it is a seq function call,"!" as variable
-      if (this.expectLexeme(",") || this.expectLexeme(")")) {
+      if (this.expectChar(',') || this.expectChar(')')) {
         this.back();
         this.factor();
       } else {
         this.unary();
         this.codeGenerator.onNot(this.lookhead);
       }
-    } else if (this.expectLexeme("-")) {
+    } else if (this.expectChar('-')) {
       this.move(true);
       // check if it is a seq function call,"!" as variable
-      if (this.expectLexeme(",") || this.expectLexeme(")")) {
+      if (this.expectChar(',') || this.expectChar(')')) {
         this.back();
         this.factor();
       } else {
         this.unary();
         this.codeGenerator.onNeg(this.lookhead);
       }
-    } else if (this.expectLexeme("~")) {
+    } else if (this.expectChar('~')) {
       this.move(true);
       // check if it is a seq function call,"~" as variable
-      if (this.expectLexeme(",") || this.expectLexeme(")")) {
+      if (this.expectChar(',') || this.expectChar(')')) {
         this.back();
         this.factor();
       } else {
@@ -403,6 +443,36 @@
     } else {
       this.factor();
     }
+
+    while (expectChar('[') || expectChar('(')) {
+      if (expectChar('[')) {
+        // (...)[index]
+        arrayAccess();
+      } else if (expectChar('(')) {
+        // May be call chain, such as "s(1)(2)(3)"
+        this.parenDepth++;
+        this.depthState.add(DepthState.Parent);
+        this.codeGenerator.onMethodName(new DelegateToken(this.lookhead.getStartIndex(),
+            this.lookhead, DelegateTokenType.Method_Name));
+        this.move(true);
+        if (!this.expectChar(')')) {
+          this.ternary();
+          this.codeGenerator.onMethodParameter(this.lookhead);
+          while (this.expectChar(',')) {
+            this.move(true);
+            this.ternary();
+            this.codeGenerator.onMethodParameter(this.lookhead);
+          }
+        }
+        if (this.expectChar(')')) {
+          this.parenDepth--;
+          this.depthState.removeLast();
+          this.move(true);
+          this.codeGenerator.onMethodInvoke(this.lookhead);
+        }
+      }
+    }
+
   }
 
   public static final CharToken LEFT_PAREN = new CharToken('(', -1);
@@ -416,38 +486,34 @@
     CharToken charToken = (CharToken) token;
 
     this.move(true);
-    if (this.expectLexeme(",") || this.expectLexeme(")")) {
+    if (this.expectChar(',') || this.expectChar(')')) {
       this.back();
       String lexeme = String.valueOf(charToken.getCh());
       if (lexeme.equals("-")) {
         lexeme = "-sub";
       }
-      return AviatorEvaluator.containsFunction(lexeme);
+      return this.instance.containsFunction(lexeme);
     } else {
       this.back();
       return false;
     }
   }
 
-
   public void factor() {
     if (this.lookhead == null) {
       this.reportSyntaxError("invalid value");
     }
-    if (this.expectLexeme("(")) {
+    if (this.expectChar('(')) {
       this.parenDepth++;
+      this.depthState.add(DepthState.Parent);
       this.move(true);
       this.ternary();
-      if (!this.expectLexeme(")")) {
-        this.reportSyntaxError("insert ')' to complete Expression");
-      } else {
+      if (this.expectChar(')')) {
         this.move(true);
+        this.parenDepth--;
+        this.depthState.removeLast();
       }
-      this.parenDepth--;
-      // (...)[index]
-      if (expectLexeme("[")) {
-        arrayAccess();
-      }
+
     } else if (this.lookhead.getType() == TokenType.Number
         || this.lookhead.getType() == TokenType.String
         || this.lookhead.getType() == TokenType.Variable || this.lookhead == Variable.TRUE
@@ -458,25 +524,27 @@
       // binary operation as variable for seq functions
       if (this.lookhead.getType() == TokenType.Char) {
         CharToken charToken = (CharToken) this.lookhead;
+        if (!ExpressionLexer.isBinaryOP(charToken.getCh())) {
+          this.reportSyntaxError("Unexpect char '" + charToken.getCh() + "'");
+        }
         // make it as variable
         this.lookhead = new Variable(charToken.getLexeme(), charToken.getStartIndex());
       }
       this.move(true);
       // function
       Token<?> prev = this.prevToken;
-      if (prev.getType() == TokenType.Variable && this.expectLexeme("(")) {
-        this.method();
-        // method.invoke()[index]
-        if (expectLexeme("[")) {
-          arrayAccess();
+      if (prev.getType() == TokenType.Variable && this.expectChar('(')) {
+        if (prev == Variable.LAMBDA) {
+          this.lambda();
+        } else {
+          this.method();
         }
-      } else if (prev.getType() == TokenType.Variable || prev.getLexeme().equals(")")) {
-        // var[index]
-        arrayAccess();
+      } else if (prev.getType() == TokenType.Variable) {
+        this.arrayAccess();
       } else {
         this.codeGenerator.onConstant(prev);
       }
-    } else if (this.expectLexeme("/")) {
+    } else if (this.expectChar('/')) {
       this.pattern();
     } else {
       this.reportSyntaxError("invalid value");
@@ -485,10 +553,76 @@
   }
 
 
+  private void lambda() {
+    this.lambdaDepth++;
+    this.depthState.add(DepthState.Lambda);
+    this.codeGenerator.onLambdaDefineStart(this.prevToken);
+    this.parenDepth++;
+    this.depthState.add(DepthState.Parent);
+    this.move(true);
+    if (!this.expectChar(')')) {
+      lambdaArgument();
+
+      while (this.expectChar(',')) {
+        this.move(true);
+        lambdaArgument();
+      }
+    }
+    if (this.expectChar(')')) {
+      this.parenDepth--;
+      this.depthState.removeLast();
+      this.move(true);
+      if (this.expectChar('-')) {
+        this.move(true);
+        if (this.expectChar('>')) {
+          this.codeGenerator.onLambdaBodyStart(lookhead);
+          this.move(true);
+          this.statement();
+          if (this.lookhead != null && this.lookhead.getType() == TokenType.Variable
+              && this.lookhead.getLexeme().equals("end")) {
+            this.codeGenerator.onLambdaBodyEnd(lookhead);
+            this.lambdaDepth--;
+            this.depthState.removeLast();
+
+            this.move(true);
+          } else {
+            reportSyntaxError("Expect lambda 'end', but is: '" + currentTokenLexeme() + "'");
+          }
+        } else {
+          // TODO may be a method call lambda(x,y)
+          reportSyntaxError("Expect lambda body, but is: '" + currentTokenLexeme() + "'");
+        }
+      } else {
+        // TODO may be a method call lambda(x,y)
+        reportSyntaxError("Expect lambda body, but is: '" + currentTokenLexeme() + "'");
+      }
+    }
+  }
+
+  private String currentTokenLexeme() {
+    return this.lookhead == null ? "END_OF_STRING" : this.lookhead.getLexeme();
+  }
+
+
+  private void lambdaArgument() {
+    if (this.lookhead.getType() == TokenType.Variable) {
+      if (!isJavaIdentifier(this.lookhead.getLexeme())) {
+        this.reportSyntaxError("Illegal argument name: " + currentTokenLexeme() + ",index="
+            + this.lookhead.getStartIndex());
+      }
+      this.codeGenerator.onLambdaArgument(this.lookhead);
+      this.move(true);
+    } else {
+      this.reportSyntaxError("Expect argument name,but is: " + currentTokenLexeme() + ",index="
+          + this.lookhead.getStartIndex());
+    }
+  }
+
+
   private void arrayAccess() {
     // check if it is a array index access
     boolean hasArray = false;
-    while (this.expectLexeme("[")) {
+    while (this.expectChar('[')) {
       if (!hasArray) {
         this.codeGenerator.onArray(this.prevToken);
         this.move(true);
@@ -499,23 +633,24 @@
       this.codeGenerator.onArrayIndexStart(this.prevToken);
       array();
     }
-    if (!hasArray)
+    if (!hasArray) {
       this.codeGenerator.onConstant(this.prevToken);
+    }
   }
 
 
   private void array() {
     this.bracketDepth++;
+    this.depthState.add(DepthState.Bracket);
     if (RESERVED_WORDS.contains(this.prevToken.getLexeme())) {
       throw new ExpressionSyntaxErrorException(
           this.prevToken.getLexeme() + " could not use [] operator");
     }
 
     this.ternary();
-    if (!this.expectLexeme("]")) {
-      this.reportSyntaxError("insert ']' to complete Expression");
-    } else {
+    if (this.expectChar(']')) {
       this.bracketDepth--;
+      this.depthState.removeLast();
       this.move(true);
       this.codeGenerator.onArrayIndexEnd(this.lookhead);
     }
@@ -534,33 +669,34 @@
     }
   }
 
-
   private void method() {
-    this.parenDepth++;
-    this.codeGenerator.onMethodName(this.prevToken);
-    this.move(true);
-    if (!this.expectLexeme(")")) {
-      this.ternary();
-      this.codeGenerator.onMethodParameter(this.lookhead);
-      while (this.expectLexeme(",")) {
-        this.move(true);
+    if (this.expectChar('(')) {
+      this.parenDepth++;
+      this.depthState.add(DepthState.Parent);
+      this.codeGenerator.onMethodName(this.prevToken);
+      this.move(true);
+      if (!this.expectChar(')')) {
         this.ternary();
         this.codeGenerator.onMethodParameter(this.lookhead);
+        while (this.expectChar(',')) {
+          this.move(true);
+          this.ternary();
+          this.codeGenerator.onMethodParameter(this.lookhead);
+        }
+      }
+      if (this.expectChar(')')) {
+        this.parenDepth--;
+        this.depthState.removeLast();
+        this.move(true);
+        this.codeGenerator.onMethodInvoke(this.lookhead);
       }
-    }
-    if (!this.expectLexeme(")")) {
-      this.reportSyntaxError("insert ')' to complete expression");
-    } else {
-      this.parenDepth--;
-      this.move(true);
-      this.codeGenerator.onMethodInvoke(this.lookhead);
     }
   }
 
 
   /**
    * Test whether a given string is a valid Java identifier.
-   * 
+   *
    * @param id string which should be checked
    * @return <code>true</code> if a valid identifier
    */
@@ -596,7 +732,7 @@
     this.inPattern = true;
     StringBuffer sb = new StringBuffer();
     while (this.lookhead != null) {
-      while (!this.expectLexeme("/")) {
+      while (!this.expectChar('/')) {
         sb.append(this.lookhead.getLexeme());
         this.move(false);
       }
@@ -618,11 +754,15 @@
 
 
   private void reportSyntaxError(String message) {
-    throw new ExpressionSyntaxErrorException("Syntax error:" + message + " at "
-        + this.lexer.getCurrentIndex() + ", current token: " + this.lookhead);
+    int index = this.lookhead != null && this.lookhead.getStartIndex() > 0
+        ? this.lookhead.getStartIndex() : this.lexer.getCurrentIndex();
+    throw new ExpressionSyntaxErrorException(
+        "Syntax error:" + message + " at " + index + ", current token: " + this.lookhead
+            + ". Parsing expression: `" + this.lexer.getScanString() + "^^`");
   }
 
 
+
   public void move(boolean analyse) {
     if (this.lookhead != null) {
       this.prevToken = this.lookhead;
@@ -641,18 +781,49 @@
 
 
   public Expression parse() {
-    this.ternary();
-    if (this.parenDepth > 0) {
-      this.reportSyntaxError("insert ')' to complete Expression");
-    }
-    if (this.bracketDepth > 0) {
-      this.reportSyntaxError("insert ']' to complete Expression");
-    }
+    statement();
     if (this.lookhead != null) {
       // The lookhead should be null, it's the end.
-      this.reportSyntaxError("Unexpect token '" + this.lookhead.getLexeme() + "'");
+      this.reportSyntaxError("Unexpect token '" + currentTokenLexeme() + "'");
     }
     return this.codeGenerator.getResult();
   }
 
+
+  private void statement() {
+    this.ternary();
+    this.ensureDepthState();
+    while (this.expectChar(';')) {
+      this.codeGenerator.onTernaryEnd(lookhead);
+      this.move(true);
+      this.ternary();
+      this.ensureDepthState();
+    }
+  }
+
+
+  private void ensureDepthState() {
+    DepthState state = this.depthState.peekLast();
+    if (state != null) {
+      back();
+      switch (state) {
+        case Parent:
+          if (this.parenDepth > 0) {
+            this.reportSyntaxError("insert ')' to complete Expression");
+          }
+          break;
+        case Bracket:
+          if (this.bracketDepth > 0) {
+            this.reportSyntaxError("insert ']' to complete Expression");
+          }
+          break;
+        case Lambda:
+          if (this.lambdaDepth > 0) {
+            this.reportSyntaxError("insert 'end' to complete lambda Expression");
+          }
+          break;
+      }
+    }
+  }
+
 }
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/parser: Parser.java
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/parser: ScopeInfo.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/function/AbstractFunction.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function/AbstractFunction.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/function/AbstractFunction.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function/AbstractFunction.java	2024-09-08 01:36:08.329768078 +1000
@@ -3,61 +3,86 @@
 import java.util.Map;
 import com.googlecode.aviator.runtime.type.AviatorFunction;
 import com.googlecode.aviator.runtime.type.AviatorObject;
+import com.googlecode.aviator.runtime.type.AviatorType;
 
 
 /**
  * Abstract function implementation
- * 
+ *
  * @author boyan
  * @Date 2011-7-12
- * 
+ *
  */
-public abstract class AbstractFunction implements AviatorFunction {
+public abstract class AbstractFunction extends AviatorObject implements AviatorFunction {
   public AviatorObject throwArity(int n) {
     String name = this.getName();
     throw new IllegalArgumentException("Wrong number of args (" + n + ") passed to: " + name);
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env) {
     return this.throwArity(0);
   }
 
 
+  @Override
+  public int compare(AviatorObject other, Map<String, Object> env) {
+    throw new UnsupportedOperationException("Lambda function can't be compared.");
+  }
+
+
+  @Override
+  public AviatorType getAviatorType() {
+    return AviatorType.Lambda;
+  }
+
+  @Override
+  public Object getValue(Map<String, Object> env) {
+    return this;
+  }
+
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1) {
     return this.throwArity(1);
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2) {
     return this.throwArity(2);
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3) {
     return this.throwArity(3);
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4) {
     return this.throwArity(4);
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5) {
     return this.throwArity(5);
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6) {
     return this.throwArity(6);
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7) {
@@ -65,6 +90,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8) {
@@ -72,6 +98,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9) {
@@ -79,6 +106,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10) {
@@ -86,6 +114,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10,
@@ -94,6 +123,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10,
@@ -102,6 +132,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10,
@@ -110,6 +141,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10,
@@ -118,6 +150,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10,
@@ -127,6 +160,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10,
@@ -136,6 +170,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10,
@@ -145,6 +180,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10,
@@ -154,6 +190,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10,
@@ -164,6 +201,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10,
@@ -174,6 +212,7 @@
   }
 
 
+  @Override
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2,
       AviatorObject arg3, AviatorObject arg4, AviatorObject arg5, AviatorObject arg6,
       AviatorObject arg7, AviatorObject arg8, AviatorObject arg9, AviatorObject arg10,
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/function/FunctionUtils.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function/FunctionUtils.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/function/FunctionUtils.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function/FunctionUtils.java	2024-09-08 01:36:08.329768078 +1000
@@ -16,8 +16,9 @@
 package com.googlecode.aviator.runtime.function;
 
 import java.util.Map;
-import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.AviatorEvaluatorInstance;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.runtime.RuntimeUtils;
 import com.googlecode.aviator.runtime.type.AviatorFunction;
 import com.googlecode.aviator.runtime.type.AviatorJavaType;
 import com.googlecode.aviator.runtime.type.AviatorObject;
@@ -27,12 +28,19 @@
 
 /**
  * Function helper
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public class FunctionUtils {
 
+  /**
+   * Get string value from env.
+   *
+   * @param arg the var name
+   * @param env
+   * @return
+   */
   public static final String getStringValue(AviatorObject arg, Map<String, Object> env) {
     String result = null;
 
@@ -49,7 +57,13 @@
     return result;
   }
 
-
+  /**
+   * get a object from env
+   *
+   * @param arg the var name
+   * @param env
+   * @return
+   */
   public static Object getJavaObject(AviatorObject arg, Map<String, Object> env) {
     if (arg.getAviatorType() != AviatorType.JavaType) {
       throw new ExpressionRuntimeException(arg.desc(env) + " is not a javaType");
@@ -58,14 +72,31 @@
   }
 
 
+  /**
+   * Get a function from env in follow orders:
+   * <ul>
+   * <li>arg value</li>
+   * <li>env</li>
+   * <li>current evaluator instance.</li>
+   * </ul>
+   *
+   * @param arg
+   * @param env
+   * @param arity
+   * @return
+   */
   public static AviatorFunction getFunction(AviatorObject arg, Map<String, Object> env, int arity) {
-    if (arg.getAviatorType() != AviatorType.JavaType) {
+    if (arg.getAviatorType() != AviatorType.JavaType
+        && arg.getAviatorType() != AviatorType.Lambda) {
       throw new ExpressionRuntimeException(arg.desc(env) + " is not a function");
     }
     // Runtime type.
     if (arg instanceof AviatorRuntimeJavaType && arg.getValue(env) instanceof AviatorFunction) {
       return (AviatorFunction) arg.getValue(env);
     }
+    if (arg instanceof AviatorFunction) {
+      return (AviatorFunction) arg;
+    }
     // resolve by name.
     // special processing for "-" operator
     String name = ((AviatorJavaType) arg).getName();
@@ -81,12 +112,20 @@
       rt = (AviatorFunction) env.get(name);
     }
     if (rt == null) {
-      rt = AviatorEvaluator.getFunction(name);
+      AviatorEvaluatorInstance instance = RuntimeUtils.getInstance(env);
+      rt = instance.getFunction(name);
     }
     return rt;
   }
 
 
+  /**
+   * Get a number from env.
+   *
+   * @param arg1 the var
+   * @param env
+   * @return
+   */
   public static final Number getNumberValue(AviatorObject arg1, Map<String, Object> env) {
     return (Number) arg1.getValue(env);
   }
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function: LambdaFunction.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/function/math/MathAbsFunction.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function/math/MathAbsFunction.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/function/math/MathAbsFunction.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function/math/MathAbsFunction.java	2024-09-08 01:36:08.329768078 +1000
@@ -18,7 +18,7 @@
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Map;
-import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.runtime.RuntimeUtils;
 import com.googlecode.aviator.runtime.function.AbstractFunction;
 import com.googlecode.aviator.runtime.function.FunctionUtils;
 import com.googlecode.aviator.runtime.type.AviatorBigInt;
@@ -31,9 +31,9 @@
 
 /**
  * math.abs(d) function
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public class MathAbsFunction extends AbstractFunction {
 
@@ -41,7 +41,7 @@
   public AviatorObject call(Map<String, Object> env, AviatorObject arg1) {
     Number number = FunctionUtils.getNumberValue(arg1, env);
     if (TypeUtils.isDecimal(number)) {
-      return new AviatorDecimal(((BigDecimal) number).abs(AviatorEvaluator.getMathContext()));
+      return new AviatorDecimal(((BigDecimal) number).abs(RuntimeUtils.getMathContext(env)));
     } else if (TypeUtils.isBigInt(number)) {
       return new AviatorBigInt(((BigInteger) number).abs());
     } else if (TypeUtils.isDouble(number)) {
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/function/math/MathLogFunction.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function/math/MathLogFunction.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/function/math/MathLogFunction.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function/math/MathLogFunction.java	2024-09-08 01:36:08.329768078 +1000
@@ -28,9 +28,9 @@
 
 /**
  * math.log(d) function
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public class MathLogFunction extends AbstractFunction {
 
@@ -39,9 +39,9 @@
 
     Number num = FunctionUtils.getNumberValue(arg1, env);
     if (TypeUtils.isDecimal(num)) {
-      return new AviatorDecimal(TypeUtils.ln((BigDecimal) num));
+      return new AviatorDecimal(TypeUtils.ln(env, (BigDecimal) num));
     } else if (TypeUtils.isBigInt(num)) {
-      return new AviatorDecimal(TypeUtils.ln(new BigDecimal((BigInteger) num)));
+      return new AviatorDecimal(TypeUtils.ln(env, new BigDecimal((BigInteger) num)));
     } else {
       return new AviatorDouble(Math.log(num.doubleValue()));
     }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/function/seq/SeqFilterFunction.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function/seq/SeqFilterFunction.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/function/seq/SeqFilterFunction.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function/seq/SeqFilterFunction.java	2024-09-08 01:36:08.329768078 +1000
@@ -16,7 +16,11 @@
 package com.googlecode.aviator.runtime.function.seq;
 
 import java.lang.reflect.Array;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
 import com.googlecode.aviator.runtime.function.AbstractFunction;
 import com.googlecode.aviator.runtime.function.FunctionUtils;
@@ -28,9 +32,9 @@
 
 /**
  * filter(seq,predicate) to filter seq by predicate
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public class SeqFilterFunction extends AbstractFunction {
 
@@ -68,7 +72,7 @@
         result = (Map<Object, Object>) clazz.newInstance();
       } catch (Throwable t) {
         // ignore
-        result = new HashMap<>();
+        result = new HashMap<Object, Object>();
       }
       Map<?, ?> map = (Map<?, ?>) first;
       for (Map.Entry<?, ?> entry : map.entrySet()) {
@@ -95,6 +99,7 @@
   }
 
 
+  @Override
   public String getName() {
     return "filter";
   }
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function/system: BooleanFunction.java
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/function: TraceFunction.java
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime: LambdaFunctionBootstrap.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/op/OperationRuntime.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/op/OperationRuntime.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/op/OperationRuntime.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/op/OperationRuntime.java	2024-09-08 01:36:08.333768107 +1000
@@ -1,10 +1,9 @@
 package com.googlecode.aviator.runtime.op;
 
 import java.util.Map;
-import com.googlecode.aviator.AviatorEvaluator;
-import com.googlecode.aviator.Options;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
 import com.googlecode.aviator.lexer.token.OperatorType;
+import com.googlecode.aviator.runtime.RuntimeUtils;
 import com.googlecode.aviator.runtime.type.AviatorFunction;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 
@@ -41,27 +40,28 @@
    * @param opType
    * @return
    */
-  public static AviatorObject eval(AviatorObject[] args, OperatorType opType) {
-    AviatorFunction func = AviatorEvaluator.getOpFunction(opType);
-    AviatorObject ret = eval0(args, opType, func);
-    if (isTracedEval()) {
+  public static AviatorObject eval(Map<String, Object> env, AviatorObject[] args,
+      OperatorType opType) {
+    AviatorFunction func = RuntimeUtils.getInstance(env).getOpFunction(opType);
+    AviatorObject ret = eval0(env, args, opType, func);
+    if (RuntimeUtils.isTracedEval(env)) {
       trace(null, opType, ret, args);
     }
     return ret;
   }
 
-  private static AviatorObject eval0(AviatorObject[] args, OperatorType opType,
-      AviatorFunction func) {
+  private static AviatorObject eval0(Map<String, Object> env, AviatorObject[] args,
+      OperatorType opType, AviatorFunction func) {
     if (func == null) {
-      return opType.eval(args, null);
+      return opType.eval(args, env);
     } else {
       switch (args.length) {
         case 1:
-          return func.call(null, args[0]);
+          return func.call(env, args[0]);
         case 2:
-          return func.call(null, args[0], args[1]);
+          return func.call(env, args[0], args[1]);
         case 3:
-          return func.call(null, args[0], args[1], args[2]);
+          return func.call(env, args[0], args[1], args[2]);
       }
       throw new ExpressionRuntimeException("Too many arguments.");
     }
@@ -77,9 +77,9 @@
    */
   public static AviatorObject eval(AviatorObject arg, Map<String, Object> env,
       OperatorType opType) {
-    AviatorFunction func = AviatorEvaluator.getOpFunction(opType);
+    AviatorFunction func = RuntimeUtils.getInstance(env).getOpFunction(opType);
     AviatorObject ret = eval0(arg, env, opType, func);
-    if (isTracedEval()) {
+    if (RuntimeUtils.isTracedEval(env)) {
       trace(env, opType, ret, arg);
     }
     return ret;
@@ -123,9 +123,9 @@
   public static AviatorObject eval(AviatorObject left, AviatorObject right, Map<String, Object> env,
       OperatorType opType) {
 
-    AviatorFunction func = AviatorEvaluator.getOpFunction(opType);
+    AviatorFunction func = RuntimeUtils.getInstance(env).getOpFunction(opType);
     AviatorObject ret = eval0(left, right, env, opType, func);
-    if (isTracedEval()) {
+    if (RuntimeUtils.isTracedEval(env)) {
       trace(env, opType, ret, left, right);
     }
     return ret;
@@ -143,8 +143,9 @@
     }
   }
 
-  public static final boolean hasRuntimeContext(OperatorType opType) {
-    return AviatorEvaluator.OPS_MAP.containsKey(opType) || isTracedEval();
+  public static final boolean hasRuntimeContext(Map<String, Object> env, OperatorType opType) {
+    return RuntimeUtils.getInstance(env).getOpsMap().containsKey(opType)
+        || RuntimeUtils.isTracedEval(env);
   }
 
   private static final String WHITE_SPACE = " ";
@@ -155,25 +156,18 @@
 
     switch (args.length) {
       case 1:
-        printTrace(TRACE_PREFIX + opType.token + args[0].desc(env) + " => " + result.desc(env));
+        RuntimeUtils.printTrace(env,
+            TRACE_PREFIX + opType.token + args[0].desc(env) + " => " + result.desc(env));
         break;
       case 2:
-        printTrace(TRACE_PREFIX + args[0].desc(env) + WHITE_SPACE + opType.token + WHITE_SPACE
-            + args[1].desc(env) + " => " + result.desc(env));
+        RuntimeUtils.printTrace(env, TRACE_PREFIX + args[0].desc(env) + WHITE_SPACE + opType.token
+            + WHITE_SPACE + args[1].desc(env) + " => " + result.desc(env));
         break;
       case 3:
-        printTrace(
+        RuntimeUtils.printTrace(env,
             TRACE_PREFIX + args[0].desc(env) + WHITE_SPACE + "?" + WHITE_SPACE + args[0].desc(env)
                 + WHITE_SPACE + ":" + WHITE_SPACE + args[1].desc(env) + " => " + result.desc(env));
         break;
     }
   }
-
-  public static void printTrace(String msg) {
-    System.out.println("[Aviator TRACE] " + msg);
-  }
-
-  public static boolean isTracedEval() {
-    return (boolean) AviatorEvaluator.getOption(Options.TRACE_EVAL);
-  }
 }
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime: RuntimeUtils.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorBigInt.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorBigInt.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorBigInt.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorBigInt.java	2024-09-08 01:36:08.333768107 +1000
@@ -2,15 +2,15 @@
 
 import java.math.BigInteger;
 import java.util.Map;
-import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.runtime.RuntimeUtils;
 
 
 /**
  * Aviator Big Integer
- * 
+ *
  * @since 2.3.0
  * @author dennis<killme2008@gmail.com>
- * 
+ *
  */
 public class AviatorBigInt extends AviatorLong {
 
@@ -58,11 +58,11 @@
 
 
   @Override
-  public AviatorObject innerSub(AviatorNumber other) {
+  public AviatorObject innerSub(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Decimal:
         return AviatorDecimal.valueOf(
-            this.toDecimal().subtract(other.toDecimal(), AviatorEvaluator.getMathContext()));
+            this.toDecimal(env).subtract(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
       case Double:
         return AviatorDouble.valueOf(this.doubleValue() - other.doubleValue());
       default:
@@ -72,11 +72,11 @@
 
 
   @Override
-  public AviatorObject innerMult(AviatorNumber other) {
+  public AviatorObject innerMult(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Decimal:
         return AviatorDecimal.valueOf(
-            this.toDecimal().multiply(other.toDecimal(), AviatorEvaluator.getMathContext()));
+            this.toDecimal(env).multiply(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
       case Double:
         return AviatorDouble.valueOf(this.doubleValue() * other.doubleValue());
       default:
@@ -86,11 +86,11 @@
 
 
   @Override
-  public AviatorObject innerMod(AviatorNumber other) {
+  public AviatorObject innerMod(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Decimal:
         return AviatorDecimal.valueOf(
-            this.toDecimal().remainder(other.toDecimal(), AviatorEvaluator.getMathContext()));
+            this.toDecimal(env).remainder(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
       case Double:
         return AviatorDouble.valueOf(this.doubleValue() % other.doubleValue());
       default:
@@ -100,11 +100,11 @@
 
 
   @Override
-  public AviatorObject innerDiv(AviatorNumber other) {
+  public AviatorObject innerDiv(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Decimal:
-        return AviatorDecimal
-            .valueOf(this.toDecimal().divide(other.toDecimal(), AviatorEvaluator.getMathContext()));
+        return AviatorDecimal.valueOf(
+            this.toDecimal(env).divide(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
       case Double:
         return AviatorDouble.valueOf(this.doubleValue() / other.doubleValue());
       default:
@@ -114,11 +114,11 @@
 
 
   @Override
-  public AviatorNumber innerAdd(AviatorNumber other) {
+  public AviatorNumber innerAdd(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Decimal:
-        return AviatorDecimal
-            .valueOf(this.toDecimal().add(other.toDecimal(), AviatorEvaluator.getMathContext()));
+        return AviatorDecimal.valueOf(
+            this.toDecimal(env).add(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
       case Double:
         return AviatorDouble.valueOf(this.doubleValue() + other.doubleValue());
       default:
@@ -128,10 +128,10 @@
 
 
   @Override
-  public int innerCompare(AviatorNumber other) {
+  public int innerCompare(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Decimal:
-        return this.toDecimal().compareTo(other.toDecimal());
+        return this.toDecimal(env).compareTo(other.toDecimal(env));
       case Double:
         return Double.compare(this.doubleValue(), other.doubleValue());
       default:
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorDecimal.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorDecimal.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorDecimal.java	2024-09-08 01:36:08.341768162 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorDecimal.java	2024-09-08 01:36:08.333768107 +1000
@@ -2,15 +2,15 @@
 
 import java.math.BigDecimal;
 import java.util.Map;
-import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.runtime.RuntimeUtils;
 
 
 /**
  * Aviator Big Decimal
- * 
+ *
  * @since 2.3.0
  * @author dennis<killme2008@gmail.com>
- * 
+ *
  */
 public class AviatorDecimal extends AviatorNumber {
 
@@ -24,84 +24,84 @@
   }
 
 
-  public static final AviatorDecimal valueOf(String d) {
-    return new AviatorDecimal(new BigDecimal(d, AviatorEvaluator.getMathContext()));
+  public static final AviatorDecimal valueOf(Map<String, Object> env, String d) {
+    return new AviatorDecimal(new BigDecimal(d, RuntimeUtils.getMathContext(env)));
   }
 
 
   @Override
-  public AviatorObject innerSub(AviatorNumber other) {
+  public AviatorObject innerSub(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Double:
         return AviatorDouble.valueOf(this.doubleValue() - other.doubleValue());
       default:
         return AviatorDecimal.valueOf(
-            this.toDecimal().subtract(other.toDecimal(), AviatorEvaluator.getMathContext()));
+            this.toDecimal(env).subtract(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
     }
   }
 
 
   @Override
   public AviatorObject neg(Map<String, Object> env) {
-    return AviatorDecimal.valueOf(this.toDecimal().negate());
+    return AviatorDecimal.valueOf(this.toDecimal(env).negate());
   }
 
 
   @Override
-  public AviatorObject innerMult(AviatorNumber other) {
+  public AviatorObject innerMult(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Double:
         return AviatorDouble.valueOf(this.doubleValue() * other.doubleValue());
       default:
         return AviatorDecimal.valueOf(
-            this.toDecimal().multiply(other.toDecimal(), AviatorEvaluator.getMathContext()));
+            this.toDecimal(env).multiply(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
     }
   }
 
 
   @Override
-  public AviatorObject innerMod(AviatorNumber other) {
+  public AviatorObject innerMod(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Double:
         return AviatorDouble.valueOf(this.doubleValue() % other.doubleValue());
       default:
         return AviatorDecimal.valueOf(
-            this.toDecimal().remainder(other.toDecimal(), AviatorEvaluator.getMathContext()));
+            this.toDecimal(env).remainder(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
     }
   }
 
 
   @Override
-  public AviatorObject innerDiv(AviatorNumber other) {
+  public AviatorObject innerDiv(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Double:
         return AviatorDouble.valueOf(this.doubleValue() / other.doubleValue());
       default:
-        return AviatorDecimal
-            .valueOf(this.toDecimal().divide(other.toDecimal(), AviatorEvaluator.getMathContext()));
+        return AviatorDecimal.valueOf(
+            this.toDecimal(env).divide(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
     }
   }
 
 
   @Override
-  public AviatorNumber innerAdd(AviatorNumber other) {
+  public AviatorNumber innerAdd(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Double:
         return AviatorDouble.valueOf(this.doubleValue() + other.doubleValue());
       default:
-        return AviatorDecimal
-            .valueOf(this.toDecimal().add(other.toDecimal(), AviatorEvaluator.getMathContext()));
+        return AviatorDecimal.valueOf(
+            this.toDecimal(env).add(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
     }
   }
 
 
   @Override
-  public int innerCompare(AviatorNumber other) {
+  public int innerCompare(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case Double:
         return Double.compare(this.doubleValue(), other.doubleValue());
       default:
-        return this.toDecimal().compareTo(other.toDecimal());
+        return this.toDecimal(env).compareTo(other.toDecimal(env));
     }
 
   }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorDouble.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorDouble.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorDouble.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorDouble.java	2024-09-08 01:36:08.333768107 +1000
@@ -20,9 +20,9 @@
 
 /**
  * Aviator double type
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public class AviatorDouble extends AviatorNumber {
 
@@ -42,7 +42,7 @@
 
 
   @Override
-  public int innerCompare(AviatorNumber other) {
+  public int innerCompare(Map<String, Object> env, AviatorNumber other) {
     return Double.compare(this.number.doubleValue(), other.doubleValue());
   }
 
@@ -54,25 +54,25 @@
 
 
   @Override
-  public AviatorObject innerDiv(AviatorNumber other) {
+  public AviatorObject innerDiv(Map<String, Object> env, AviatorNumber other) {
     return new AviatorDouble(this.number.doubleValue() / other.doubleValue());
   }
 
 
   @Override
-  public AviatorNumber innerAdd(AviatorNumber other) {
+  public AviatorNumber innerAdd(Map<String, Object> env, AviatorNumber other) {
     return new AviatorDouble(this.number.doubleValue() + other.doubleValue());
   }
 
 
   @Override
-  public AviatorObject innerMod(AviatorNumber other) {
+  public AviatorObject innerMod(Map<String, Object> env, AviatorNumber other) {
     return new AviatorDouble(this.number.doubleValue() % other.doubleValue());
   }
 
 
   @Override
-  public AviatorObject innerMult(AviatorNumber other) {
+  public AviatorObject innerMult(Map<String, Object> env, AviatorNumber other) {
     return new AviatorDouble(this.number.doubleValue() * other.doubleValue());
   }
 
@@ -84,7 +84,7 @@
 
 
   @Override
-  public AviatorObject innerSub(AviatorNumber other) {
+  public AviatorObject innerSub(Map<String, Object> env, AviatorNumber other) {
     return new AviatorDouble(this.number.doubleValue() - other.doubleValue());
   }
 }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorJavaType.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorJavaType.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorJavaType.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorJavaType.java	2024-09-08 01:36:08.333768107 +1000
@@ -477,8 +477,8 @@
   @Override
   public String desc(Map<String, Object> env) {
     Object value = this.getValue(env);
-    return this.getAviatorType() + "(" + value + ", "
-        + (value == null ? "null" : value.getClass().getSimpleName()) + ")";
+    return "<" + this.getAviatorType() + ", " + value + ", "
+        + (value == null ? "null" : value.getClass().getSimpleName()) + ">";
   }
 
 }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorLong.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorLong.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorLong.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorLong.java	2024-09-08 01:36:08.333768107 +1000
@@ -16,16 +16,16 @@
 package com.googlecode.aviator.runtime.type;
 
 import java.util.Map;
-import com.googlecode.aviator.AviatorEvaluator;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.runtime.RuntimeUtils;
 import com.googlecode.aviator.utils.TypeUtils;
 
 
 /**
  * Aviator long type
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public class AviatorLong extends AviatorNumber {
 
@@ -69,12 +69,12 @@
 
 
   @Override
-  public int innerCompare(AviatorNumber other) {
+  public int innerCompare(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case BigInt:
         return this.toBigInt().compareTo(other.toBigInt());
       case Decimal:
-        return this.toDecimal().compareTo(other.toDecimal());
+        return this.toDecimal(env).compareTo(other.toDecimal(env));
       case Long:
         return TypeUtils.comapreLong(this.longValue(), other.longValue());
       case Double:
@@ -86,13 +86,13 @@
 
 
   @Override
-  public AviatorObject innerDiv(AviatorNumber other) {
+  public AviatorObject innerDiv(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case BigInt:
         return AviatorBigInt.valueOf(this.toBigInt().divide(other.toBigInt()));
       case Decimal:
-        return AviatorDecimal
-            .valueOf(this.toDecimal().divide(other.toDecimal(), AviatorEvaluator.getMathContext()));
+        return AviatorDecimal.valueOf(
+            this.toDecimal(env).divide(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
       case Long:
         return AviatorLong.valueOf(this.number.longValue() / other.longValue());
       default:
@@ -102,13 +102,13 @@
 
 
   @Override
-  public AviatorObject innerAdd(AviatorNumber other) {
+  public AviatorObject innerAdd(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case BigInt:
         return AviatorBigInt.valueOf(this.toBigInt().add(other.toBigInt()));
       case Decimal:
-        return AviatorDecimal
-            .valueOf(this.toDecimal().add(other.toDecimal(), AviatorEvaluator.getMathContext()));
+        return AviatorDecimal.valueOf(
+            this.toDecimal(env).add(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
       case Long:
         return AviatorLong.valueOf(this.number.longValue() + other.longValue());
       default:
@@ -118,13 +118,13 @@
 
 
   @Override
-  public AviatorObject innerMod(AviatorNumber other) {
+  public AviatorObject innerMod(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case BigInt:
         return AviatorBigInt.valueOf(this.toBigInt().mod(other.toBigInt()));
       case Decimal:
         return AviatorDecimal.valueOf(
-            this.toDecimal().remainder(other.toDecimal(), AviatorEvaluator.getMathContext()));
+            this.toDecimal(env).remainder(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
       case Long:
         return AviatorLong.valueOf(this.number.longValue() % other.longValue());
       default:
@@ -134,13 +134,13 @@
 
 
   @Override
-  public AviatorObject innerMult(AviatorNumber other) {
+  public AviatorObject innerMult(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case BigInt:
         return AviatorBigInt.valueOf(this.toBigInt().multiply(other.toBigInt()));
       case Decimal:
         return AviatorDecimal.valueOf(
-            this.toDecimal().multiply(other.toDecimal(), AviatorEvaluator.getMathContext()));
+            this.toDecimal(env).multiply(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
       case Long:
         return AviatorLong.valueOf(this.number.longValue() * other.longValue());
       default:
@@ -338,13 +338,13 @@
 
 
   @Override
-  public AviatorObject innerSub(AviatorNumber other) {
+  public AviatorObject innerSub(Map<String, Object> env, AviatorNumber other) {
     switch (other.getAviatorType()) {
       case BigInt:
         return AviatorBigInt.valueOf(this.toBigInt().subtract(other.toBigInt()));
       case Decimal:
         return AviatorDecimal.valueOf(
-            this.toDecimal().subtract(other.toDecimal(), AviatorEvaluator.getMathContext()));
+            this.toDecimal(env).subtract(other.toDecimal(env), RuntimeUtils.getMathContext(env)));
       case Long:
         return AviatorLong.valueOf(this.number.longValue() - other.longValue());
       default:
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorNumber.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorNumber.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorNumber.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorNumber.java	2024-09-08 01:36:08.333768107 +1000
@@ -18,16 +18,16 @@
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Map;
-import com.googlecode.aviator.AviatorEvaluator;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.runtime.RuntimeUtils;
 import com.googlecode.aviator.utils.TypeUtils;
 
 
 /**
  * Aviator number type
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public abstract class AviatorNumber extends AviatorObject {
   protected Number number;
@@ -75,12 +75,12 @@
       case Decimal:
       case Long:
       case Double:
-        return this.innerAdd((AviatorNumber) other);
+        return this.innerAdd(env, (AviatorNumber) other);
       case JavaType:
         AviatorJavaType otherJavaType = (AviatorJavaType) other;
         final Object otherValue = otherJavaType.getValue(env);
         if (otherValue instanceof Number) {
-          return this.innerAdd(AviatorNumber.valueOf(otherValue));
+          return this.innerAdd(env, AviatorNumber.valueOf(otherValue));
         } else if (otherValue instanceof String) {
           return new AviatorString(this.number.toString() + otherValue);
         } else {
@@ -100,12 +100,12 @@
       case Decimal:
       case Long:
       case Double:
-        return this.innerSub((AviatorNumber) other);
+        return this.innerSub(env, (AviatorNumber) other);
       case JavaType:
         AviatorJavaType otherJavaType = (AviatorJavaType) other;
         final Object otherValue = otherJavaType.getValue(env);
         if (otherValue instanceof Number) {
-          return this.innerSub(AviatorNumber.valueOf(otherValue));
+          return this.innerSub(env, AviatorNumber.valueOf(otherValue));
         } else {
           return super.sub(other, env);
         }
@@ -123,12 +123,12 @@
       case Decimal:
       case Long:
       case Double:
-        return this.innerMod((AviatorNumber) other);
+        return this.innerMod(env, (AviatorNumber) other);
       case JavaType:
         AviatorJavaType otherJavaType = (AviatorJavaType) other;
         final Object otherValue = otherJavaType.getValue(env);
         if (otherValue instanceof Number) {
-          return this.innerMod(AviatorNumber.valueOf(otherValue));
+          return this.innerMod(env, AviatorNumber.valueOf(otherValue));
         } else {
           return super.mod(other, env);
         }
@@ -145,12 +145,12 @@
       case Decimal:
       case Long:
       case Double:
-        return this.innerDiv((AviatorNumber) other);
+        return this.innerDiv(env, (AviatorNumber) other);
       case JavaType:
         AviatorJavaType otherJavaType = (AviatorJavaType) other;
         final Object otherValue = otherJavaType.getValue(env);
         if (otherValue instanceof Number) {
-          return this.innerDiv(AviatorNumber.valueOf(otherValue));
+          return this.innerDiv(env, AviatorNumber.valueOf(otherValue));
         } else {
           return super.div(other, env);
         }
@@ -168,12 +168,12 @@
       case Decimal:
       case Long:
       case Double:
-        return this.innerMult((AviatorNumber) other);
+        return this.innerMult(env, (AviatorNumber) other);
       case JavaType:
         AviatorJavaType otherJavaType = (AviatorJavaType) other;
         final Object otherValue = otherJavaType.getValue(env);
         if (otherValue instanceof Number) {
-          return this.innerMult(AviatorNumber.valueOf(otherValue));
+          return this.innerMult(env, AviatorNumber.valueOf(otherValue));
         } else {
           return super.mult(other, env);
         }
@@ -194,7 +194,7 @@
       case Decimal:
       case Long:
       case Double:
-        return this.innerCompare((AviatorNumber) other);
+        return this.innerCompare(env, (AviatorNumber) other);
       case JavaType:
         AviatorJavaType otherJavaType = (AviatorJavaType) other;
         final Object otherValue = otherJavaType.getValue(env);
@@ -202,7 +202,7 @@
           return 1;
         }
         if (otherValue instanceof Number) {
-          return this.innerCompare(AviatorNumber.valueOf(otherValue));
+          return this.innerCompare(env, AviatorNumber.valueOf(otherValue));
         } else {
           throw new ExpressionRuntimeException("Could not compare " + this + " with " + other);
         }
@@ -215,22 +215,22 @@
   }
 
 
-  public abstract AviatorObject innerSub(AviatorNumber other);
+  public abstract AviatorObject innerSub(Map<String, Object> env, AviatorNumber other);
 
 
-  public abstract AviatorObject innerMult(AviatorNumber other);
+  public abstract AviatorObject innerMult(Map<String, Object> env, AviatorNumber other);
 
 
-  public abstract AviatorObject innerMod(AviatorNumber other);
+  public abstract AviatorObject innerMod(Map<String, Object> env, AviatorNumber other);
 
 
-  public abstract AviatorObject innerDiv(AviatorNumber other);
+  public abstract AviatorObject innerDiv(Map<String, Object> env, AviatorNumber other);
 
 
-  public abstract AviatorObject innerAdd(AviatorNumber other);
+  public abstract AviatorObject innerAdd(Map<String, Object> env, AviatorNumber other);
 
 
-  public abstract int innerCompare(AviatorNumber other);
+  public abstract int innerCompare(Map<String, Object> env, AviatorNumber other);
 
 
   public long longValue() {
@@ -247,13 +247,13 @@
   }
 
 
-  public final BigDecimal toDecimal() {
+  public final BigDecimal toDecimal(Map<String, Object> env) {
     if (TypeUtils.isDecimal(this.number)) {
       return (BigDecimal) this.number;
     } else if (TypeUtils.isBigInt(this.number)) {
       return new BigDecimal(this.toBigInt());
     } else {
-      return new BigDecimal(this.number.doubleValue(), AviatorEvaluator.getMathContext());
+      return new BigDecimal(this.number.doubleValue(), RuntimeUtils.getMathContext(env));
     }
   }
 }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorObject.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorObject.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorObject.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorObject.java	2024-09-08 01:36:08.333768107 +1000
@@ -22,9 +22,9 @@
 
 /**
  * Aviator root object
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public abstract class AviatorObject {
   public abstract int compare(AviatorObject other, Map<String, Object> env);
@@ -35,7 +35,7 @@
 
   /**
    * Returns true if the aviator object is null.
-   * 
+   *
    * @since 3.0.0
    * @return
    */
@@ -61,7 +61,7 @@
 
 
   public String desc(Map<String, Object> env) {
-    return this.getAviatorType() + "(" + this.getValue(env) + ")";
+    return "<" + this.getAviatorType() + ", " + this.getValue(env) + ">";
   }
 
 
@@ -166,7 +166,7 @@
 
   /**
    * Access array or list element
-   * 
+   *
    * @param env
    * @param indexObject
    * @return
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorPattern.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorPattern.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorPattern.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorPattern.java	2024-09-08 01:36:08.333768107 +1000
@@ -19,9 +19,9 @@
 import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import com.googlecode.aviator.AviatorEvaluator;
 import com.googlecode.aviator.Options;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.runtime.RuntimeUtils;
 import com.googlecode.aviator.utils.TypeUtils;
 
 
@@ -74,7 +74,8 @@
         AviatorString aviatorString = (AviatorString) other;
         Matcher m = this.pattern.matcher(aviatorString.lexeme);
         if (m.matches()) {
-          boolean captureGroups = AviatorEvaluator.getOption(Options.PUT_CAPTURING_GROUPS_INTO_ENV);
+          boolean captureGroups =
+              RuntimeUtils.getInstance(env).getOption(Options.PUT_CAPTURING_GROUPS_INTO_ENV);
           if (captureGroups && env != null && env != Collections.EMPTY_MAP) {
             int groupCount = m.groupCount();
             for (int i = 0; i <= groupCount; i++) {
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorRuntimeJavaType.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorRuntimeJavaType.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorRuntimeJavaType.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorRuntimeJavaType.java	2024-09-08 01:36:08.333768107 +1000
@@ -20,16 +20,22 @@
 
 /**
  * Aviator runtime java type,used by when generate runtime result.
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public class AviatorRuntimeJavaType extends AviatorJavaType {
   private final Object object;
 
+  public static AviatorObject valueOf(Object object) {
+    if (object instanceof AviatorObject) {
+      return (AviatorObject) object;
+    }
+    return new AviatorRuntimeJavaType(object);
+  }
 
   public AviatorRuntimeJavaType(Object object) {
-    super("unknow");
+    super("unknown");
     this.object = object;
   }
 
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorType.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorType.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/runtime/type/AviatorType.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/runtime/type/AviatorType.java	2024-09-08 01:36:08.333768107 +1000
@@ -17,10 +17,10 @@
 
 /**
  * Aviator types
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public enum AviatorType {
-  Long, Double, String, JavaType, Boolean, Pattern, Nil, Method, BigInt, Decimal;
+  Long, Double, String, JavaType, Boolean, Pattern, Nil, Method, BigInt, Decimal, Lambda;
 }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/script/AviatorScriptEngine.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/script/AviatorScriptEngine.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/script/AviatorScriptEngine.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/script/AviatorScriptEngine.java	2024-09-08 01:36:08.333768107 +1000
@@ -10,11 +10,12 @@
 import javax.script.ScriptException;
 import javax.script.SimpleBindings;
 import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.AviatorEvaluatorInstance;
 
 
 /**
  * Aviator Expression engine
- * 
+ *
  * @author libinsong1204@gmail.com
  * @date 2011-1-18 上午11:03:34
  * @version
@@ -24,38 +25,46 @@
   // 缓存编译结果
   private boolean cached = true;
   private final AviatorScriptEngineFactory factory;
+  private AviatorEvaluatorInstance evaluator;
 
 
   public AviatorScriptEngine(AviatorScriptEngineFactory factory) {
     this.factory = factory;
+    this.evaluator = AviatorEvaluator.newInstance();
   }
 
 
+  @Override
   public CompiledScript compile(String script) throws ScriptException {
-    return new CompiledAviatorScript(this, AviatorEvaluator.compile(script, this.cached));
+    return new CompiledAviatorScript(this, evaluator.compile(script, this.cached));
   }
 
 
+  @Override
   public CompiledScript compile(Reader script) throws ScriptException {
     throw new UnsupportedOperationException();
   }
 
 
+  @Override
   public Bindings createBindings() {
     return new SimpleBindings();
   }
 
 
+  @Override
   public Object eval(String script, ScriptContext context) throws ScriptException {
     return this.compile(script).eval(context);
   }
 
 
+  @Override
   public Object eval(Reader reader, ScriptContext context) throws ScriptException {
     throw new UnsupportedOperationException();
   }
 
 
+  @Override
   public ScriptEngineFactory getFactory() {
     return this.factory;
   }
Only in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/spring: SpringContextFunctionMissing.java
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/spring: SringContextFunctionLoader.java
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/utils: Env.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/utils/TypeUtils.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/utils/TypeUtils.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/googlecode/aviator/utils/TypeUtils.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/googlecode/aviator/utils/TypeUtils.java	2024-09-08 01:36:08.333768107 +1000
@@ -17,14 +17,16 @@
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import com.googlecode.aviator.AviatorEvaluator;
+import java.math.MathContext;
+import java.util.Map;
+import com.googlecode.aviator.runtime.RuntimeUtils;
 
 
 /**
  * Java type to aviator type utilities
- * 
+ *
  * @author boyan
- * 
+ *
  */
 public class TypeUtils {
 
@@ -58,39 +60,41 @@
 
 
   public static int comapreLong(long x, long y) {
-    if (x > y)
+    if (x > y) {
       return 1;
-    else if (x < y)
+    } else if (x < y) {
       return -1;
-    else
+    } else {
       return 0;
+    }
   }
 
 
   /**
    * newton method to get natural logarithm
-   * 
+   *
    * @param x
    * @return
    */
-  public static BigDecimal ln(BigDecimal x) {
+  public static BigDecimal ln(Map<String, Object> env, BigDecimal x) {
     if (x.equals(BigDecimal.ONE)) {
       return BigDecimal.ZERO;
     }
 
     x = x.subtract(BigDecimal.ONE);
     BigDecimal ret = new BigDecimal(NEWTON_METHOD_REPEATS + 1);
+    MathContext mathContext = RuntimeUtils.getMathContext(env);
     for (long i = NEWTON_METHOD_REPEATS; i >= 0; i--) {
       BigDecimal N = new BigDecimal(i / 2 + 1).pow(2);
-      N = N.multiply(x, AviatorEvaluator.getMathContext());
-      ret = N.divide(ret, AviatorEvaluator.getMathContext());
+      N = N.multiply(x, mathContext);
+      ret = N.divide(ret, mathContext);
 
       N = new BigDecimal(i + 1);
-      ret = ret.add(N, AviatorEvaluator.getMathContext());
+      ret = ret.add(N, mathContext);
 
     }
 
-    ret = x.divide(ret, AviatorEvaluator.getMathContext());
+    ret = x.divide(ret, mathContext);
     return ret;
   }
 
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator: AviatorEvaluatorInstanceUnitTest.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/code/asm/ASMCodeGeneratorUnitTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/code/asm/ASMCodeGeneratorUnitTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/code/asm/ASMCodeGeneratorUnitTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/code/asm/ASMCodeGeneratorUnitTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -15,7 +15,10 @@
  **/
 package com.googlecode.aviator.code.asm;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 import java.lang.reflect.InvocationTargetException;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
@@ -24,13 +27,20 @@
 import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
+import com.googlecode.aviator.AviatorEvaluator;
 import com.googlecode.aviator.Expression;
+import com.googlecode.aviator.code.CodeGenerator;
+import com.googlecode.aviator.code.LambdaGenerator;
 import com.googlecode.aviator.lexer.token.NumberToken;
 import com.googlecode.aviator.lexer.token.OperatorType;
 import com.googlecode.aviator.lexer.token.PatternToken;
 import com.googlecode.aviator.lexer.token.StringToken;
 import com.googlecode.aviator.lexer.token.Variable;
 import com.googlecode.aviator.parser.AviatorClassLoader;
+import com.googlecode.aviator.parser.Parser;
+import com.googlecode.aviator.parser.ScopeInfo;
+import com.googlecode.aviator.runtime.function.LambdaFunction;
+import com.googlecode.aviator.runtime.type.AviatorJavaType;
 
 
 public class ASMCodeGeneratorUnitTest {
@@ -41,12 +51,14 @@
   public void setUp() {
     final AviatorClassLoader classloader =
         AccessController.doPrivileged(new PrivilegedAction<AviatorClassLoader>() {
+          @Override
           public AviatorClassLoader run() {
             return new AviatorClassLoader(Thread.currentThread().getContextClassLoader());
           }
         });
 
-    this.codeGenerator = new ASMCodeGenerator(classloader, System.out, true);
+    this.codeGenerator =
+        new ASMCodeGenerator(AviatorEvaluator.newInstance(), classloader, System.out, true);
     this.codeGenerator.start();
   }
 
@@ -498,6 +510,50 @@
     assertTrue(result instanceof Date);
   }
 
+  @Test
+  public void testOnLambdaDefine() throws Exception {
+    this.codeGenerator.setParser(new Parser() {
+
+      @Override
+      public void setCodeGenerator(CodeGenerator codeGenerator) {
+
+      }
+
+      @Override
+      public void restoreScope(ScopeInfo info) {
+
+      }
+
+      @Override
+      public CodeGenerator getCodeGenerator() {
+        return codeGenerator;
+      }
+
+      @Override
+      public ScopeInfo enterScope() {
+        return null;
+      }
+    });
+    assertNull(this.codeGenerator.getLambdaGenerator());
+    this.codeGenerator.onLambdaDefineStart(new Variable("lambda", 0));
+    LambdaGenerator lambdaGenerator = this.codeGenerator.getLambdaGenerator();
+    assertNotNull(lambdaGenerator);
+    codeGenerator.onLambdaArgument(new Variable("x", 1));
+    codeGenerator.onLambdaArgument(new Variable("y", 2));
+    codeGenerator.onLambdaBodyStart(new Variable(">", 3));
+    lambdaGenerator.onConstant(new Variable("x", 4));
+    lambdaGenerator.onConstant(new Variable("y", 5));
+    lambdaGenerator.onAdd(null);
+    codeGenerator.onLambdaBodyEnd(new Variable("end", 7));
+    HashMap<String, Object> env = new HashMap<String, Object>();
+    env.put("x", 2);
+    env.put("y", 3);
+    Object result = this.eval(env);
+    assertTrue(result instanceof LambdaFunction);
+    assertEquals(5, ((LambdaFunction) result)
+        .call(env, new AviatorJavaType("x"), new AviatorJavaType("y")).getValue(env));
+    assertNull(this.codeGenerator.getLambdaGenerator());
+  }
 
   @Test
   public void testOnMethod_withTwoArguments() throws Exception {
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/example/SimpleExample.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/example/SimpleExample.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/example/SimpleExample.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/example/SimpleExample.java	2024-09-08 01:36:08.333768107 +1000
@@ -1,12 +1,34 @@
 package com.googlecode.aviator.example;
 
+import java.util.HashMap;
+import java.util.Map;
 import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.Options;
+import com.googlecode.aviator.runtime.function.LambdaFunction;
 
 
 public class SimpleExample {
   public static void main(String[] args) {
-    String s = (String) AviatorEvaluator.execute("'\"你好\\''");
+    AviatorEvaluator.setOption(Options.TRACE_EVAL, true);
+    Map<String, Object> env = new HashMap<>();
+    int[][] value = new int[10][10];
+    for (int i = 0; i < 10; i++) {
+      for (int j = 0; j < 10; j++) {
+        value[i][j] = i * j - 10;
+        System.out.print(value[i][j] + " ");
+      }
+      System.out.println();
+    }
+    env.put("d", 100);
+    env.put("x", 4);
+    env.put("4", "test");
+    env.put("y", 5);
+    LambdaFunction s = (LambdaFunction) AviatorEvaluator.execute(
+        "lambda(x) -> println(#__env__);lambda(y) -> println(#__env__);lambda(z) ->println(#__env__); x +y +z+d end end end",
+        env);
+    AviatorEvaluator.getInstance().getFuncMap().put("s", s);
+    env.put("z", 6);
 
-    System.out.println(s);
+    System.out.println(AviatorEvaluator.execute("s(1)(2)(3)", env));
   }
 }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/lexer/ExpressionLexerUnitTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/lexer/ExpressionLexerUnitTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/lexer/ExpressionLexerUnitTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/lexer/ExpressionLexerUnitTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -21,8 +21,10 @@
 import static org.junit.Assert.assertTrue;
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import org.junit.Before;
 import org.junit.Test;
 import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.AviatorEvaluatorInstance;
 import com.googlecode.aviator.Options;
 import com.googlecode.aviator.exception.CompileExpressionErrorException;
 import com.googlecode.aviator.lexer.token.Token;
@@ -32,11 +34,17 @@
 
 public class ExpressionLexerUnitTest {
   private ExpressionLexer lexer;
+  private AviatorEvaluatorInstance instance;
+
+  @Before
+  public void setup() {
+    this.instance = AviatorEvaluator.newInstance();
+  }
 
 
   @Test
   public void testSimpleExpression() {
-    this.lexer = new ExpressionLexer("1+2");
+    this.lexer = new ExpressionLexer(this.instance, "1+2");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(1, token.getValue(null));
@@ -58,7 +66,7 @@
 
   @Test
   public void testParseBigNumber() {
-    this.lexer = new ExpressionLexer("92233720368547758071");
+    this.lexer = new ExpressionLexer(this.instance, "92233720368547758071");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(new BigInteger("92233720368547758071"), token.getValue(null));
@@ -68,7 +76,7 @@
 
   @Test
   public void testParseHexNumber() {
-    this.lexer = new ExpressionLexer("0X0a2B");
+    this.lexer = new ExpressionLexer(this.instance, "0X0a2B");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(2603, token.getValue(null));
@@ -78,7 +86,7 @@
 
   @Test
   public void testParseBigInteger() {
-    this.lexer = new ExpressionLexer("3N");
+    this.lexer = new ExpressionLexer(this.instance, "3N");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(new BigInteger("3"), token.getValue(null));
@@ -88,7 +96,7 @@
 
   @Test
   public void testParseScientificNotation1() {
-    this.lexer = new ExpressionLexer("3e2");
+    this.lexer = new ExpressionLexer(this.instance, "3e2");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(300.0, token.getValue(null));
@@ -98,19 +106,19 @@
 
   @Test
   public void testParseScientificNotationBiggerSmaller() {
-    this.lexer = new ExpressionLexer("3e10");
+    this.lexer = new ExpressionLexer(this.instance, "3e10");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(3e10, token.getValue(null));
     assertEquals(0, token.getStartIndex());
 
-    this.lexer = new ExpressionLexer("3e100");
+    this.lexer = new ExpressionLexer(this.instance, "3e100");
     token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(3e100, token.getValue(null));
     assertEquals(0, token.getStartIndex());
 
-    this.lexer = new ExpressionLexer("3e-100");
+    this.lexer = new ExpressionLexer(this.instance, "3e-100");
     token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(3e-100, token.getValue(null));
@@ -120,7 +128,7 @@
 
   @Test
   public void testParseScientificNotation2() {
-    this.lexer = new ExpressionLexer("3E2");
+    this.lexer = new ExpressionLexer(this.instance, "3E2");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(300.0, token.getValue(null));
@@ -130,7 +138,7 @@
 
   @Test
   public void testParseScientificNotation3() {
-    this.lexer = new ExpressionLexer("3e-1");
+    this.lexer = new ExpressionLexer(this.instance, "3e-1");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(0.3, token.getValue(null));
@@ -140,7 +148,7 @@
 
   @Test
   public void testParseScientificNotation4() {
-    this.lexer = new ExpressionLexer("3E-2");
+    this.lexer = new ExpressionLexer(this.instance, "3E-2");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(0.03, token.getValue(null));
@@ -150,7 +158,7 @@
 
   @Test
   public void testParseScientificNotation5() {
-    this.lexer = new ExpressionLexer("3E2M");
+    this.lexer = new ExpressionLexer(this.instance, "3E2M");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(new BigDecimal("300"), token.getValue(null));
@@ -160,7 +168,7 @@
 
   @Test
   public void testParseScientificNotation6() {
-    this.lexer = new ExpressionLexer("3e-1M");
+    this.lexer = new ExpressionLexer(this.instance, "3e-1M");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(new BigDecimal("0.3"), token.getValue(null));
@@ -170,14 +178,14 @@
 
   @Test(expected = CompileExpressionErrorException.class)
   public void testParseScientificNotation7() {
-    this.lexer = new ExpressionLexer("3e3N");
+    this.lexer = new ExpressionLexer(this.instance, "3e3N");
     Token<?> token = this.lexer.scan();
   }
 
 
   @Test
   public void testParseScientificNotation8() {
-    this.lexer = new ExpressionLexer("2.3456e3");
+    this.lexer = new ExpressionLexer(this.instance, "2.3456e3");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(2345.6, token.getValue(null));
@@ -187,7 +195,7 @@
 
   @Test(expected = NumberFormatException.class)
   public void testIllegalNumber1() {
-    this.lexer = new ExpressionLexer("3EM+2");
+    this.lexer = new ExpressionLexer(this.instance, "3EM+2");
     while (this.lexer.scan() != null) {
       ;
     }
@@ -196,7 +204,7 @@
 
   @Test
   public void testParseBigDecimal() {
-    this.lexer = new ExpressionLexer("3.2M");
+    this.lexer = new ExpressionLexer(this.instance, "3.2M");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(new BigDecimal("3.2"), token.getValue(null));
@@ -206,7 +214,7 @@
 
   @Test
   public void testParseNumbers() {
-    this.lexer = new ExpressionLexer("3N .2M 1 2.3  4.33M");
+    this.lexer = new ExpressionLexer(this.instance, "3N .2M 1 2.3  4.33M");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(new BigInteger("3"), token.getValue(null));
@@ -237,22 +245,22 @@
   @Test
   public void testParseDoubleAsDecimal() {
     try {
-      AviatorEvaluator.setOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL, true);
-      this.lexer = new ExpressionLexer("3.2");
+      this.instance.setOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL, true);
+      this.lexer = new ExpressionLexer(this.instance, "3.2");
       Token<?> token = this.lexer.scan();
       assertEquals(TokenType.Number, token.getType());
       assertTrue(token.getValue(null) instanceof BigDecimal);
       assertEquals(new BigDecimal("3.2"), token.getValue(null));
       assertEquals(0, token.getStartIndex());
     } finally {
-      AviatorEvaluator.setOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL, false);
+      this.instance.setOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL, false);
     }
   }
 
 
   @Test
   public void testParseLikeHexNumber() {
-    this.lexer = new ExpressionLexer("0344");
+    this.lexer = new ExpressionLexer(this.instance, "0344");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(344, token.getValue(null));
@@ -262,7 +270,7 @@
 
   @Test
   public void testSimpleExpression_WithHexNumber() {
-    this.lexer = new ExpressionLexer("3+0xAF");
+    this.lexer = new ExpressionLexer(this.instance, "3+0xAF");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(3, token.getValue(null));
@@ -284,7 +292,7 @@
 
   @Test
   public void testSimpleExpression_WithSpace() {
-    this.lexer = new ExpressionLexer(" 1 + 2 ");
+    this.lexer = new ExpressionLexer(this.instance, " 1 + 2 ");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(1, token.getValue(null));
@@ -306,7 +314,7 @@
 
   @Test
   public void testExpression_WithDouble() {
-    this.lexer = new ExpressionLexer("3.0+4-5.9");
+    this.lexer = new ExpressionLexer(this.instance, "3.0+4-5.9");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(3.0, token.getValue(null));
@@ -339,7 +347,7 @@
 
   @Test(expected = CompileExpressionErrorException.class)
   public void testExpression_WithIllegalDouble() {
-    this.lexer = new ExpressionLexer("3.0+4-5.9.2");
+    this.lexer = new ExpressionLexer(this.instance, "3.0+4-5.9.2");
     while (this.lexer.scan() != null) {
       ;
     }
@@ -349,14 +357,14 @@
 
   @Test
   public void testExpression_True_False() {
-    this.lexer = new ExpressionLexer("true");
+    this.lexer = new ExpressionLexer(this.instance, "true");
     Token<?> token = this.lexer.scan();
 
     assertEquals(TokenType.Variable, token.getType());
     assertTrue((Boolean) token.getValue(null));
     assertNull(this.lexer.scan());
 
-    this.lexer = new ExpressionLexer("false");
+    this.lexer = new ExpressionLexer(this.instance, "false");
     token = this.lexer.scan();
 
     assertEquals(TokenType.Variable, token.getType());
@@ -368,7 +376,7 @@
 
   @Test
   public void testQuoteVar() {
-    this.lexer = new ExpressionLexer("#abc");
+    this.lexer = new ExpressionLexer(this.instance, "#abc");
     Token<?> token = this.lexer.scan();
 
     assertEquals(TokenType.Variable, token.getType());
@@ -376,7 +384,7 @@
     assertTrue(((Variable) token).isQuote());
     assertNull(this.lexer.scan());
 
-    this.lexer = new ExpressionLexer("#abc.array[0].d");
+    this.lexer = new ExpressionLexer(this.instance, "#abc.array[0].d");
     token = this.lexer.scan();
 
     assertEquals(TokenType.Variable, token.getType());
@@ -388,7 +396,7 @@
 
   @Test
   public void testExpression_Logic_Join() {
-    this.lexer = new ExpressionLexer("a || c ");
+    this.lexer = new ExpressionLexer(this.instance, "a || c ");
     Token<?> token = this.lexer.scan();
 
     assertEquals(TokenType.Variable, token.getType());
@@ -413,7 +421,7 @@
 
   @Test
   public void testExpression_Eq() {
-    this.lexer = new ExpressionLexer("a ==c ");
+    this.lexer = new ExpressionLexer(this.instance, "a ==c ");
     Token<?> token = this.lexer.scan();
 
     assertEquals(TokenType.Variable, token.getType());
@@ -434,7 +442,7 @@
 
   @Test
   public void testExpression_Not() {
-    this.lexer = new ExpressionLexer("!(3<=1)");
+    this.lexer = new ExpressionLexer(this.instance, "!(3<=1)");
     Token<?> token = this.lexer.scan();
 
     assertEquals(TokenType.Char, token.getType());
@@ -471,23 +479,23 @@
 
   @Test
   public void testBlank_SpaceExpression() {
-    this.lexer = new ExpressionLexer("");
+    this.lexer = new ExpressionLexer(this.instance, "");
     assertNull(this.lexer.scan());
 
-    this.lexer = new ExpressionLexer("   ");
+    this.lexer = new ExpressionLexer(this.instance, "   ");
     assertNull(this.lexer.scan());
 
-    this.lexer = new ExpressionLexer("\t");
+    this.lexer = new ExpressionLexer(this.instance, "\t");
     assertNull(this.lexer.scan());
 
-    this.lexer = new ExpressionLexer("\t \t");
+    this.lexer = new ExpressionLexer(this.instance, "\t \t");
     assertNull(this.lexer.scan());
   }
 
 
   @Test
   public void testExpression_Neg() {
-    this.lexer = new ExpressionLexer("-10.3");
+    this.lexer = new ExpressionLexer(this.instance, "-10.3");
     Token<?> token = this.lexer.scan();
 
     assertEquals(TokenType.Char, token.getType());
@@ -502,7 +510,7 @@
 
   @Test
   public void testExpression_Logic_And() {
-    this.lexer = new ExpressionLexer("a==3 && false");
+    this.lexer = new ExpressionLexer(this.instance, "a==3 && false");
     Token<?> token = this.lexer.scan();
 
     assertEquals(TokenType.Variable, token.getType());
@@ -538,7 +546,7 @@
 
   @Test
   public void testExpression_WithString() {
-    this.lexer = new ExpressionLexer("'hello world'");
+    this.lexer = new ExpressionLexer(this.instance, "'hello world'");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.String, token.getType());
     assertEquals("hello world", token.getValue(null));
@@ -549,7 +557,7 @@
 
   @Test
   public void testExpression_WithNestedString() {
-    this.lexer = new ExpressionLexer("'hello \"good\" world'");
+    this.lexer = new ExpressionLexer(this.instance, "'hello \"good\" world'");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.String, token.getType());
     assertEquals("hello \"good\" world", token.getValue(null));
@@ -560,14 +568,14 @@
 
   @Test(expected = CompileExpressionErrorException.class)
   public void testExpression_WithIllegalString() {
-    this.lexer = new ExpressionLexer("'hello \" world");
+    this.lexer = new ExpressionLexer(this.instance, "'hello \" world");
     this.lexer.scan();
   }
 
 
   @Test
   public void testExpressionHasPattern() {
-    this.lexer = new ExpressionLexer("/a\\.f\\d+/");
+    this.lexer = new ExpressionLexer(this.instance, "/a\\.f\\d+/");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Char, token.getType());
     assertEquals("/", token.getLexeme());
@@ -610,7 +618,7 @@
 
   @Test
   public void testExpressionHasPattern2() {
-    this.lexer = new ExpressionLexer("/\\//");
+    this.lexer = new ExpressionLexer(this.instance, "/\\//");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Char, token.getType());
     assertEquals("/", token.getLexeme());
@@ -630,7 +638,7 @@
 
   @Test
   public void testExpressionWithParen() {
-    this.lexer = new ExpressionLexer("2.0+(2+2)*99");
+    this.lexer = new ExpressionLexer(this.instance, "2.0+(2+2)*99");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Number, token.getType());
     assertEquals(2.0, token.getValue(null));
@@ -682,7 +690,7 @@
 
   @Test
   public void testNotAnsylyse() {
-    this.lexer = new ExpressionLexer("a + b *d+'hello\n'");
+    this.lexer = new ExpressionLexer(this.instance, "a + b *d+'hello\n'");
     Token<?> token = this.lexer.scan();
     assertEquals(TokenType.Variable, token.getType());
     assertEquals("a", token.getValue(null));
@@ -708,7 +716,7 @@
 
   @Test(expected = CompileExpressionErrorException.class)
   public void testScanHasLine() {
-    this.lexer = new ExpressionLexer("4+5>\n5");
+    this.lexer = new ExpressionLexer(this.instance, "4+5>\n5");
 
     while (this.lexer.scan() != null) {
       ;
@@ -719,7 +727,7 @@
 
   @Test
   public void testPushBack() {
-    this.lexer = new ExpressionLexer("13+100");
+    this.lexer = new ExpressionLexer(this.instance, "13+100");
     Token<?> token = this.lexer.scan();
     assertEquals("13", token.getLexeme());
     this.lexer.pushback(token);
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/parser/ExpressionParserUnitTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/parser/ExpressionParserUnitTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/parser/ExpressionParserUnitTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/parser/ExpressionParserUnitTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -15,10 +15,12 @@
  **/
 package com.googlecode.aviator.parser;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 import java.util.regex.Pattern;
 import org.junit.Before;
 import org.junit.Test;
+import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.AviatorEvaluatorInstance;
 import com.googlecode.aviator.exception.ExpressionSyntaxErrorException;
 import com.googlecode.aviator.lexer.ExpressionLexer;
 
@@ -27,59 +29,146 @@
   private ExpressionParser parser;
 
   private FakeCodeGenerator codeGenerator;
+  private AviatorEvaluatorInstance instance;
 
 
   @Before
   public void setUp() {
     this.codeGenerator = new FakeCodeGenerator();
+    this.instance = AviatorEvaluator.newInstance();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testIllegalIdentifier1() {
-    this.parser = new ExpressionParser(new ExpressionLexer("null"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "null"),
+        this.codeGenerator);
+    this.parser.parse();
+  }
+
+  @Test
+  public void testLambda1() {
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "lambda(x,y)-> x+y end"), this.codeGenerator);
+    this.parser.parse();
+    assertEquals("x y + lambda<defined>", this.codeGenerator.getPostFixExpression());
+  }
+
+  @Test
+  public void testLambda2() {
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "lambda(x)-> lambda(y) -> x +y end end"),
+        this.codeGenerator);
+    this.parser.parse();
+    assertEquals("x y + lambda<defined> lambda<defined>",
+        this.codeGenerator.getPostFixExpression());
+  }
+
+  @Test
+  public void testLambda3() {
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance,
+        "lambda(x)-> lambda(y) -> lambda(z) ->  x +y+z  end end end"), this.codeGenerator);
+    this.parser.parse();
+    assertEquals("x y + z + lambda<defined> lambda<defined> lambda<defined>",
+        this.codeGenerator.getPostFixExpression());
+  }
+
+  @Test(expected = ExpressionSyntaxErrorException.class)
+  public void testLambdaMissingEnd() {
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "lambda(x)-> lambda(y) -> x +y end"),
+        this.codeGenerator);
     this.parser.parse();
   }
 
+  @Test(expected = ExpressionSyntaxErrorException.class)
+  public void testLambdaMissingArrow() {
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "lambda(x) x +y end"), this.codeGenerator);
+    this.parser.parse();
+  }
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testIllegalIdentifier2() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a.null"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "a.null"),
+        this.codeGenerator);
+    this.parser.parse();
+  }
+
+  @Test
+  public void testStatement1() {
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "x+y;x-y"),
+        this.codeGenerator);
+    this.parser.parse();
+    assertEquals("x y + ; x y -", this.codeGenerator.getPostFixExpression());
+  }
+
+  @Test
+  public void testStatement2() {
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "println(3+2);4"), this.codeGenerator);
+    this.parser.parse();
+    assertEquals("3 2 + method<invoked> ; 4", this.codeGenerator.getPostFixExpression());
+  }
+
+  @Test(expected = ExpressionSyntaxErrorException.class)
+  public void testIllegalStatement1() {
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "println(3+2;4"), this.codeGenerator);
+    this.parser.parse();
+  }
+
+  @Test(expected = ExpressionSyntaxErrorException.class)
+  public void testIllegalStatement2() {
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "println(3+2);4-"), this.codeGenerator);
+    this.parser.parse();
+  }
+
+  @Test(expected = ExpressionSyntaxErrorException.class)
+  public void testIllegalStatement3() {
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "println(3+2;);4"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testIllegalIdentifier3() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a3.2"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "a3.2"),
+        this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testParseBlankExpression1() {
-    this.parser = new ExpressionParser(new ExpressionLexer(""), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, ""),
+        this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testIllegalExpression1() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a=2"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "a=2"),
+        this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testIllegalExpression2() {
-    this.parser = new ExpressionParser(new ExpressionLexer("!=3"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "!=3"),
+        this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test
   public void testBitOr() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3|4"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "3|4"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("3 4 |", this.codeGenerator.getPostFixExpression());
   }
@@ -87,7 +176,8 @@
 
   @Test
   public void testBitAnd() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3&4"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "3&4"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("3 4 &", this.codeGenerator.getPostFixExpression());
   }
@@ -95,7 +185,8 @@
 
   @Test
   public void testBitAndNot() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3&~1"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "3&~1"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("3 1 ~ &", this.codeGenerator.getPostFixExpression());
   }
@@ -103,105 +194,122 @@
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testIllegalExpression6() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a!b"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "a!b"),
+        this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testParseBlankExpression2() {
-    this.parser = new ExpressionParser(new ExpressionLexer("\t "), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "\t "),
+        this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testParseBlankExpression3() {
-    this.parser = new ExpressionParser(new ExpressionLexer("  "), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "  "),
+        this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test
   public void testSimpleExpression() {
-    this.parser = new ExpressionParser(new ExpressionLexer("1+3"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "1+3"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("1 3 +", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("1+3-2"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "1+3-2"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("1 3 + 2 -", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("1+3-2/5"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "1+3-2/5"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("1 3 + 2 5 / -", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("6==3"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "6==3"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("6 3 ==", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("6>=3 && c==d.a"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "6>=3 && c==d.a"), this.codeGenerator);
     this.parser.parse();
     assertEquals("6 3 >= c d.a == &&", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser =
-        new ExpressionParser(new ExpressionLexer("6>=3 && c==d.a || 0.3<4"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "6>=3 && c==d.a || 0.3<4"), this.codeGenerator);
     this.parser.parse();
     assertEquals("6 3 >= c d.a == && 0.3 4 < ||", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("!true"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "!true"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("true !", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("!a && 3==1"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "!a && 3==1"), this.codeGenerator);
     this.parser.parse();
     assertEquals("a ! 3 1 == &&", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("-a+2010"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "-a+2010"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("a - 2010 +", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("3&2^1|4 == 5"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3&2^1|4 == 5"), this.codeGenerator);
     this.parser.parse();
     assertEquals("3 2 & 1 ^ 4 5 == |", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("3^2&3|4&~1"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3^2&3|4&~1"), this.codeGenerator);
     this.parser.parse();
     assertEquals("3 2 3 & ^ 4 1 ~ & |", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser =
-        new ExpressionParser(new ExpressionLexer("true || 2&1==0 ? 1 :0"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "true || 2&1==0 ? 1 :0"), this.codeGenerator);
     this.parser.parse();
     assertEquals("true 2 1 0 == & || 1 0 ?:", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("3+4>>1"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "3+4>>1"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("3 4 + 1 >>", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("3-4>>1"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "3-4>>1"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("3 4 - 1 >>", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("3-4<<1==0"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3-4<<1==0"), this.codeGenerator);
     this.parser.parse();
     assertEquals("3 4 - 1 << 0 ==", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser = new ExpressionParser(new ExpressionLexer("3-4<<1&3"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3-4<<1&3"), this.codeGenerator);
     this.parser.parse();
     assertEquals("3 4 - 1 << 3 &", this.codeGenerator.getPostFixExpression());
   }
@@ -209,18 +317,20 @@
 
   @Test
   public void testParseExpression_WithOneParen() {
-    this.parser = new ExpressionParser(new ExpressionLexer("(3+1)/5"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "(3+1)/5"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("3 1 + 5 /", this.codeGenerator.getPostFixExpression());
 
     this.codeGenerator.reset();
-    this.parser = new ExpressionParser(new ExpressionLexer("3-(5+2)"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "3-(5+2)"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("3 5 2 + -", this.codeGenerator.getPostFixExpression());
 
     this.resetCodeGenerator();
-    this.parser =
-        new ExpressionParser(new ExpressionLexer("6>=3 && (c==d.a || 0.3<4)"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "6>=3 && (c==d.a || 0.3<4)"), this.codeGenerator);
     this.parser.parse();
     assertEquals("6 3 >= c d.a == 0.3 4 < || &&", this.codeGenerator.getPostFixExpression());
 
@@ -229,8 +339,9 @@
 
   @Test
   public void testParseExpression_WithManyParens1() {
-    this.parser = new ExpressionParser(
-        new ExpressionLexer("6.3-((3+1)/5+3.14)*600%(2+3-(6+(4.3-9)))"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "6.3-((3+1)/5+3.14)*600%(2+3-(6+(4.3-9)))"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("6.3 3 1 + 5 / 3.14 + 600 * 2 3 + 6 4.3 9 - + - % -",
         this.codeGenerator.getPostFixExpression());
@@ -239,50 +350,56 @@
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testParseExpression_WithIllegalParen1() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3+4)"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "3+4)"),
+        this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testParseExpression_WithIllegalParen2() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3+4)"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "3+4)"),
+        this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testParseExpression_IllegalParens3() {
-    this.parser = new ExpressionParser(new ExpressionLexer("(((((3+4)))"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "(((((3+4)))"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testParseExpression_IllegalParens4() {
-    this.parser = new ExpressionParser(new ExpressionLexer("(((((3+4)))+3"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "(((((3+4)))+3"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testParseExpression_IllegalParens2() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3-(5+6/(c+d)"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3-(5+6/(c+d)"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testParseExpression_IllegalParens() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3-(5+6/(c+d)"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3-(5+6/(c+d)"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test
   public void testParsePattern() {
-    this.parser =
-        new ExpressionParser(new ExpressionLexer("'456.5'=~/[\\d\\.]+/"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "'456.5'=~/[\\d\\.]+/"), this.codeGenerator);
     this.parser.parse();
     assertEquals("456.5 [\\d\\.]+ =~", this.codeGenerator.getPostFixExpression());
   }
@@ -290,8 +407,8 @@
 
   @Test
   public void testParseComplexPattern() {
-    this.parser = new ExpressionParser(
-        new ExpressionLexer(
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance,
             "'killme2008@gmail.com'=~/[a-zA-Z0-9_]+[@][a-zA-Z0-9]+([\\.com]|[\\.cn])/"),
         this.codeGenerator);
     this.parser.parse();
@@ -303,8 +420,8 @@
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testIllegalPattern() {
-    this.parser = new ExpressionParser(
-        new ExpressionLexer("/[a-zA-Z0-9_]+[@][a-zA-Z0-9]+([\\.com]|[\\.cn])/cdf/"),
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "/[a-zA-Z0-9_]+[@][a-zA-Z0-9]+([\\.com]|[\\.cn])/cdf/"),
         this.codeGenerator);
     this.parser.parse();
   }
@@ -312,9 +429,8 @@
 
   @Test
   public void testParseMorePattern() {
-    this.parser = new ExpressionParser(
-        new ExpressionLexer("/[a-zA-Z0-9_]+[@][a-zA-Z0-9]+([\\.com]|[\\.cn])/==/hello/"),
-        this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance,
+        "/[a-zA-Z0-9_]+[@][a-zA-Z0-9]+([\\.com]|[\\.cn])/==/hello/"), this.codeGenerator);
     this.parser.parse();
     assertEquals("[a-zA-Z0-9_]+[@][a-zA-Z0-9]+([\\.com]|[\\.cn]) hello ==",
         this.codeGenerator.getPostFixExpression());
@@ -323,8 +439,8 @@
 
   @Test
   public void testParsePatternWithOtherExpression() {
-    this.parser = new ExpressionParser(new ExpressionLexer(" !false || '456.5'=~/[\\d\\.]+/"),
-        this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, " !false || '456.5'=~/[\\d\\.]+/"), this.codeGenerator);
     this.parser.parse();
     assertEquals("false ! 456.5 [\\d\\.]+ =~ ||", this.codeGenerator.getPostFixExpression());
   }
@@ -332,8 +448,9 @@
 
   @Test
   public void testParseExpression_WithManyParens2() {
-    this.parser = new ExpressionParser(
-        new ExpressionLexer("5+(5+(5+a*1.02)*1.02)*1.02-600/(4*b-(c+d))"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "5+(5+(5+a*1.02)*1.02)*1.02-600/(4*b-(c+d))"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("5 5 5 a 1.02 * + 1.02 * + 1.02 * + 600 4 b * c d + - / -",
         this.codeGenerator.getPostFixExpression());
@@ -374,8 +491,8 @@
 
   @Test
   public void testComplexLogicExpression() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a>b && (c<=d || e!=3.14) && !f"),
-        this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "a>b && (c<=d || e!=3.14) && !f"), this.codeGenerator);
     this.parser.parse();
     assertEquals("a b > c d <= e 3.14 != || && f ! &&", this.codeGenerator.getPostFixExpression());
   }
@@ -383,8 +500,8 @@
 
   private void matchPattern(String pattern) {
     this.codeGenerator.reset();
-    this.parser =
-        new ExpressionParser(new ExpressionLexer("/" + pattern + "/"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "/" + pattern + "/"), this.codeGenerator);
     this.parser.parse();
     assertEquals(pattern, this.codeGenerator.getPostFixExpression());
   }
@@ -393,8 +510,8 @@
   @Test
   public void testPattern_Escape() {
     Pattern.compile("http:\\/\\/www\\.google\\.com");
-    this.parser = new ExpressionParser(
-        new ExpressionLexer("'http://google.com'=~/http:\\/\\/www\\.google\\.com/"),
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "'http://google.com'=~/http:\\/\\/www\\.google\\.com/"),
         this.codeGenerator);
     this.parser.parse();
     assertEquals("http://google.com http:\\/\\/www\\.google\\.com =~",
@@ -409,7 +526,8 @@
 
   @Test
   public void testTernary1() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3>1?1:-3"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3>1?1:-3"), this.codeGenerator);
     this.parser.parse();
     assertEquals("3 1 > 1 3 - ?:", this.codeGenerator.getPostFixExpression());
   }
@@ -418,8 +536,8 @@
   @Test
   public void testTernary2() {
     int d = 3 > 1 ? 6 <= 7 ? 0 : 100 : 3 > 2 ? 9 : 0;
-    this.parser =
-        new ExpressionParser(new ExpressionLexer("3>1?6<=7?0:100:3>2?9:0"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3>1?6<=7?0:100:3>2?9:0"), this.codeGenerator);
     this.parser.parse();
     assertEquals("3 1 > 6 7 <= 0 100 ?: 3 2 > 9 0 ?: ?:",
         this.codeGenerator.getPostFixExpression());
@@ -428,8 +546,8 @@
 
   @Test
   public void testTernary3() {
-    this.parser =
-        new ExpressionParser(new ExpressionLexer("3>1?true:false?1:0"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3>1?true:false?1:0"), this.codeGenerator);
     this.parser.parse();
     assertEquals("3 1 > true false 1 0 ?: ?:", this.codeGenerator.getPostFixExpression());
     Object d = 3 > 1 ? true : false ? 1 : 0;
@@ -440,29 +558,32 @@
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testIllegalTernary1() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3>1?true"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3>1?true"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testIllegalTernary2() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3>1?true:"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3>1?true:"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testIllegalTernary3() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3>1?true:false?9"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3>1?true:false?9"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test
   public void testTernaryWithParen1() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3==1?(9.0-3>5?-1:2):(false?9:0)"),
-        this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3==1?(9.0-3>5?-1:2):(false?9:0)"), this.codeGenerator);
     this.parser.parse();
     assertEquals("3 1 == 9.0 3 - 5 > 1 - 2 ?: false 9 0 ?: ?:",
         this.codeGenerator.getPostFixExpression());
@@ -471,8 +592,8 @@
 
   @Test
   public void testTernaryWithParen2() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3==1?(100-(3+1)):(false?9:0)"),
-        this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3==1?(100-(3+1)):(false?9:0)"), this.codeGenerator);
     this.parser.parse();
     assertEquals("3 1 == 100 3 1 + - false 9 0 ?: ?:", this.codeGenerator.getPostFixExpression());
   }
@@ -480,23 +601,24 @@
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testTernaryWithIllegalParen1() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3==1?(100-(3+1):(false?9:0)"),
-        this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3==1?(100-(3+1):(false?9:0)"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testTernaryWithIllegalParen2() {
-    this.parser = new ExpressionParser(new ExpressionLexer("3==1?(100-3+1)):(false?9:0)"),
-        this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "3==1?(100-3+1)):(false?9:0)"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test
   public void testParseGroup() {
-    this.parser = new ExpressionParser(new ExpressionLexer("'3.45'=~/(\\d+)\\.(\\d+)/ ? $2 : $0 "),
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "'3.45'=~/(\\d+)\\.(\\d+)/ ? $2 : $0 "),
         this.codeGenerator);
     this.parser.parse();
     assertEquals("3.45 (\\d+)\\.(\\d+) =~ $2 $0 ?:", this.codeGenerator.getPostFixExpression());
@@ -505,8 +627,9 @@
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testParseIllegalGroup1() {
-    this.parser = new ExpressionParser(
-        new ExpressionLexer("'3.45'=~/(\\d+)\\.(\\d+)/ ? $2.3 : $0 "), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "'3.45'=~/(\\d+)\\.(\\d+)/ ? $2.3 : $0 "),
+        this.codeGenerator);
     this.parser.parse();
 
   }
@@ -514,7 +637,8 @@
 
   @Test
   public void testParseFunction() {
-    this.parser = new ExpressionParser(new ExpressionLexer("string.contains(\"hello\",'fuck')"),
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "string.contains(\"hello\",'fuck')"),
         this.codeGenerator);
     this.parser.parse();
 
@@ -525,8 +649,8 @@
 
   @Test
   public void testParseSeqFunction() {
-    this.parser =
-        new ExpressionParser(new ExpressionLexer("map(list,println)"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "map(list,println)"), this.codeGenerator);
     this.parser.parse();
 
     assertEquals("list println method<invoked>", this.codeGenerator.getPostFixExpression());
@@ -536,7 +660,8 @@
 
   @Test
   public void testParseReduceFunction() {
-    this.parser = new ExpressionParser(new ExpressionLexer("reduce(list,-,0)"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "reduce(list,-,0)"), this.codeGenerator);
     this.parser.parse();
 
     assertEquals("list - 0 method<invoked>", this.codeGenerator.getPostFixExpression());
@@ -546,8 +671,8 @@
 
   @Test
   public void testParseFunctionNested() {
-    this.parser = new ExpressionParser(
-        new ExpressionLexer(
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance,
             "string.contains(string.substring(\"hello\",3,4),string.substring(\"hello\",1)) && 3>2"),
         this.codeGenerator);
     this.parser.parse();
@@ -560,7 +685,8 @@
 
   @Test
   public void testArrayAccess() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a[2]"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "a[2]"),
+        this.codeGenerator);
     this.parser.parse();
 
     assertEquals("a 2 []", this.codeGenerator.getPostFixExpression());
@@ -569,7 +695,8 @@
 
   @Test
   public void testMultiDimensionalArrayAccess1() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a[2][3]"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "a[2][3]"),
+        this.codeGenerator);
     this.parser.parse();
     assertEquals("a 2 [] 3 []", this.codeGenerator.getPostFixExpression());
 
@@ -579,8 +706,8 @@
   @Test
   public void testMultiDimensionalArrayAccess2() {
 
-    this.parser =
-        new ExpressionParser(new ExpressionLexer("a[1][2] [3]   [4]"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "a[1][2] [3]   [4]"), this.codeGenerator);
     this.parser.parse();
     assertEquals("a 1 [] 2 [] 3 [] 4 []", this.codeGenerator.getPostFixExpression());
   }
@@ -588,7 +715,8 @@
 
   @Test
   public void testArrayAccess_IndexIsExp() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a[b+c/2]"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "a[b+c/2]"), this.codeGenerator);
     this.parser.parse();
 
     assertEquals("a b c 2 / + []", this.codeGenerator.getPostFixExpression());
@@ -597,7 +725,8 @@
 
   @Test
   public void testArrayAccessNested1() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a[c[3]]"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "a[c[3]]"),
+        this.codeGenerator);
     this.parser.parse();
 
     assertEquals("a c 3 [] []", this.codeGenerator.getPostFixExpression());
@@ -607,7 +736,8 @@
 
   @Test
   public void testArrayAccessNested2() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a[c[3+c[y*2]]]"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "a[c[3+c[y*2]]]"), this.codeGenerator);
     this.parser.parse();
 
     assertEquals("a c 3 c y 2 * [] + [] []", this.codeGenerator.getPostFixExpression());
@@ -617,56 +747,63 @@
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testArrayAccess_Illegal1() {
-    this.parser = new ExpressionParser(new ExpressionLexer("ab+c/2]"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "ab+c/2]"),
+        this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testArrayAccess_Illegal2() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a[c[3+c[y*2]]"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "a[c[3+c[y*2]]"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   // @Test(expected = ExpressionSyntaxErrorException.class)
   // public void testArrayAccess_Illegal3() {
-  // this.parser = new ExpressionParser(new
+  // this.parser = new ExpressionParser(this.instance,new
   // ExpressionLexer("a[c[3+true[y*2]]]"), this.codeGenerator);
   // this.parser.parse();
   // }
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testArrayAccess_Illegal4() {
-    this.parser = new ExpressionParser(new ExpressionLexer("a[c3+c[y*2]]]"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "a[c3+c[y*2]]]"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testInvalidExpression1() {
-    this.parser = new ExpressionParser(new ExpressionLexer("4(ss*^^%%$$$$"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "4(ss*^^%%$$$$"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testInvalidExpression2() {
-    this.parser = new ExpressionParser(new ExpressionLexer("4(*)**&^^^^^^^^"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "4(*)**&^^^^^^^^"), this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testInvalidExpression3() {
-    this.parser = new ExpressionParser(new ExpressionLexer("4("), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance, "4("),
+        this.codeGenerator);
     this.parser.parse();
   }
 
 
   @Test(expected = ExpressionSyntaxErrorException.class)
   public void testInvalidExpression4() {
-    this.parser = new ExpressionParser(new ExpressionLexer("4(*8^####"), this.codeGenerator);
+    this.parser = new ExpressionParser(this.instance,
+        new ExpressionLexer(this.instance, "4(*8^####"), this.codeGenerator);
     this.parser.parse();
   }
 
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/parser/FakeCodeGenerator.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/parser/FakeCodeGenerator.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/parser/FakeCodeGenerator.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/parser/FakeCodeGenerator.java	2024-09-08 01:36:08.333768107 +1000
@@ -15,6 +15,7 @@
  **/
 package com.googlecode.aviator.parser;
 
+import java.util.Stack;
 import com.googlecode.aviator.Expression;
 import com.googlecode.aviator.code.CodeGenerator;
 import com.googlecode.aviator.lexer.token.Token;
@@ -22,15 +23,24 @@
 
 /**
  * Fake CodeGenerator,transform infix expression to postfix expression
- * 
+ *
  * @author dennis
- * 
+ *
  */
 public class FakeCodeGenerator implements CodeGenerator {
   private StringBuffer sb = new StringBuffer();
 
   private boolean wasFirst = true;
 
+  private Stack<ScopeInfo> scopes = new Stack<ScopeInfo>();
+  private Parser parser;
+
+
+  @Override
+  public void setParser(Parser parser) {
+    this.parser = parser;
+  }
+
 
   public void reset() {
     this.sb = new StringBuffer();
@@ -38,6 +48,7 @@
   }
 
 
+  @Override
   public Expression getResult() {
     return null;
   }
@@ -48,11 +59,18 @@
   }
 
 
+  @Override
   public void onAdd(Token<?> lookhead) {
     this.appendToken("+");
   }
 
 
+  @Override
+  public void onTernaryEnd(Token<?> lookhead) {
+    this.appendToken(";");
+
+  }
+
   private void appendToken(String s) {
     if (this.wasFirst) {
       this.wasFirst = false;
@@ -63,192 +81,248 @@
   }
 
 
+  @Override
   public void onAndLeft(Token<?> lookhead) {
 
   }
 
 
+  @Override
   public void onAndRight(Token<?> lookhead) {
     this.appendToken("&&");
 
   }
 
 
+  @Override
   public void onJoinRight(Token<?> lookhead) {
     this.appendToken("||");
   }
 
 
+  @Override
   public void onTernaryBoolean(Token<?> lookhead) {
 
   }
 
 
+  @Override
   public void onTernaryLeft(Token<?> lookhead) {
 
   }
 
 
+  @Override
   public void onTernaryRight(Token<?> lookhead) {
     this.appendToken("?:");
   }
 
 
+  @Override
   public void onConstant(Token<?> lookhead) {
     this.appendToken(lookhead.getLexeme());
   }
 
 
+  @Override
   public void onDiv(Token<?> lookhead) {
     this.appendToken("/");
 
   }
 
 
+  @Override
   public void onEq(Token<?> lookhead) {
     this.appendToken("==");
 
   }
 
 
+  @Override
   public void onGe(Token<?> lookhead) {
     this.appendToken(">=");
 
   }
 
 
+  @Override
   public void onGt(Token<?> lookhead) {
     this.appendToken(">");
 
   }
 
 
+  @Override
   public void onJoinLeft(Token<?> lookhead) {
 
   }
 
 
+  @Override
   public void onLe(Token<?> lookhead) {
     this.appendToken("<=");
 
   }
 
 
+  @Override
   public void onLt(Token<?> lookhead) {
     this.appendToken("<");
 
   }
 
 
+  @Override
   public void onMatch(Token<?> lookhead) {
     this.appendToken("=~");
 
   }
 
 
+  @Override
   public void onMod(Token<?> lookhead) {
     this.appendToken("%");
 
   }
 
 
+  @Override
   public void onMult(Token<?> lookhead) {
     this.appendToken("*");
 
   }
 
 
+  @Override
   public void onNeg(Token<?> lookhead) {
     this.appendToken("-");
 
   }
 
 
+  @Override
   public void onNeq(Token<?> lookhead) {
     this.appendToken("!=");
 
   }
 
 
+  @Override
   public void onNot(Token<?> lookhead) {
     this.appendToken("!");
 
   }
 
 
+  @Override
   public void onSub(Token<?> lookhead) {
     this.appendToken("-");
   }
 
 
+  @Override
   public void onMethodInvoke(Token<?> lookhead) {
     this.appendToken("method<invoked>");
 
   }
 
 
+  @Override
   public void onMethodName(Token<?> lookhead) {
 
   }
 
 
+  @Override
   public void onMethodParameter(Token<?> lookhead) {
 
   }
 
 
+  @Override
   public void onArray(Token<?> lookhead) {
     this.appendToken(lookhead.getLexeme());
   }
 
 
+  @Override
   public void onArrayIndexStart(Token<?> token) {
 
   }
 
 
+  @Override
   public void onArrayIndexEnd(Token<?> lookhead) {
     this.appendToken("[]");
 
   }
 
 
+  @Override
   public void onBitAnd(Token<?> lookhead) {
     this.appendToken("&");
 
   }
 
 
+  @Override
   public void onBitNot(Token<?> lookhead) {
     this.appendToken("~");
 
   }
 
 
+  @Override
   public void onBitOr(Token<?> lookhead) {
     this.appendToken("|");
 
   }
 
 
+  @Override
   public void onBitXor(Token<?> lookhead) {
     this.appendToken("^");
 
   }
 
 
+  @Override
   public void onShiftLeft(Token<?> lookhead) {
     this.appendToken("<<");
 
   }
 
+  @Override
+  public void onLambdaDefineStart(Token<?> lookhead) {
+    this.scopes.push(this.parser.enterScope());
+  }
+
+
+  @Override
+  public void onLambdaBodyStart(Token<?> lookhead) {
+
+  }
+
+
+  @Override
+  public void onLambdaArgument(Token<?> lookhead) {}
+
+
+  @Override
+  public void onLambdaBodyEnd(Token<?> lookhead) {
+    this.appendToken("lambda<defined>");
+    this.parser.restoreScope(this.scopes.pop());
+  }
+
 
+  @Override
   public void onShiftRight(Token<?> lookhead) {
     this.appendToken(">>");
 
   }
 
 
+  @Override
   public void onUnsignedShiftRight(Token<?> lookhead) {
     this.appendToken(">>>");
 
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/FunctionUtilsUnitTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/FunctionUtilsUnitTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/FunctionUtilsUnitTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/FunctionUtilsUnitTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -3,6 +3,7 @@
 import static org.junit.Assert.*;
 import org.junit.Test;
 import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.AviatorEvaluatorInstance;
 import com.googlecode.aviator.lexer.token.OperatorType;
 import com.googlecode.aviator.runtime.function.seq.SeqMapFunction;
 import com.googlecode.aviator.runtime.function.system.BinaryFunction;
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/math/MathAbsFunctionUnitTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/math/MathAbsFunctionUnitTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/math/MathAbsFunctionUnitTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/math/MathAbsFunctionUnitTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -3,12 +3,12 @@
 import static org.junit.Assert.assertEquals;
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.util.HashMap;
-import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
+import com.googlecode.aviator.TestUtils;
 import com.googlecode.aviator.runtime.type.AviatorJavaType;
 import com.googlecode.aviator.runtime.type.AviatorNumber;
+import com.googlecode.aviator.utils.Env;
 
 
 public class MathAbsFunctionUnitTest extends BaseMathFunctionUnitTestForOneArgument {
@@ -20,22 +20,22 @@
 
   @Test
   public void testCall() {
-    assertEquals(3, this.function.call(null, AviatorNumber.valueOf(-3)).getValue(null));
-    assertEquals(3.9, this.function.call(null, AviatorNumber.valueOf(-3.9)).getValue(null));
-    assertEquals(400, this.function.call(null, AviatorNumber.valueOf(400)).getValue(null));
+    Env env = TestUtils.getTestEnv();
+    assertEquals(3, this.function.call(env, AviatorNumber.valueOf(-3)).getValue(null));
+    assertEquals(3.9, this.function.call(env, AviatorNumber.valueOf(-3.9)).getValue(null));
+    assertEquals(400, this.function.call(env, AviatorNumber.valueOf(400)).getValue(null));
     assertEquals(new BigInteger("300000000000000000000000000000000"),
         this.function
-            .call(null, AviatorNumber.valueOf(new BigInteger("-300000000000000000000000000000000")))
+            .call(env, AviatorNumber.valueOf(new BigInteger("-300000000000000000000000000000000")))
             .getValue(null));
     assertEquals(new BigDecimal("300000000000000000000000000000000.0000002223333"),
         this.function
-            .call(null,
+            .call(env,
                 AviatorNumber
                     .valueOf(new BigDecimal("-300000000000000000000000000000000.0000002223333")))
             .getValue(null));
-    assertEquals(400, this.function.call(null, AviatorNumber.valueOf(400)).getValue(null));
+    assertEquals(400, this.function.call(env, AviatorNumber.valueOf(400)).getValue(null));
 
-    Map<String, Object> env = new HashMap<String, Object>();
     env.put("a", 300);
     env.put("b", -3.14);
     env.put("c", new BigInteger("-300000000000000000000000000000000"));
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/math/MathLogFunctionUnitTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/math/MathLogFunctionUnitTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/math/MathLogFunctionUnitTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/math/MathLogFunctionUnitTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -3,12 +3,12 @@
 import static org.junit.Assert.assertEquals;
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.util.HashMap;
-import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
+import com.googlecode.aviator.TestUtils;
 import com.googlecode.aviator.runtime.type.AviatorJavaType;
 import com.googlecode.aviator.runtime.type.AviatorNumber;
+import com.googlecode.aviator.utils.Env;
 
 
 public class MathLogFunctionUnitTest extends BaseMathFunctionUnitTestForOneArgument {
@@ -20,16 +20,16 @@
 
   @Test
   public void testCall() {
-    assertEquals(2.197, this.function.call(null, AviatorNumber.valueOf(9)).getValue(null));
-    assertEquals(4.394, this.function.call(null, AviatorNumber.valueOf(81)).getValue(null));
-    assertEquals(5.991, this.function.call(null, AviatorNumber.valueOf(400)).getValue(null));
+    Env env = TestUtils.getTestEnv();
+    assertEquals(2.197, this.function.call(env, AviatorNumber.valueOf(9)).getValue(null));
+    assertEquals(4.394, this.function.call(env, AviatorNumber.valueOf(81)).getValue(null));
+    assertEquals(5.991, this.function.call(env, AviatorNumber.valueOf(400)).getValue(null));
 
     assertEquals(new BigDecimal("5.991"),
-        this.function.call(null, AviatorNumber.valueOf(new BigInteger("400"))).getValue(null));
-    assertEquals(new BigDecimal("6.907755268982137"), this.function
-        .call(null, AviatorNumber.valueOf(new BigDecimal("999.99999"))).getValue(null));
+        this.function.call(env, AviatorNumber.valueOf(new BigInteger("400"))).getValue(null));
+    assertEquals(new BigDecimal("6.907755268982137"),
+        this.function.call(env, AviatorNumber.valueOf(new BigDecimal("999.99999"))).getValue(null));
 
-    Map<String, Object> env = new HashMap<String, Object>();
     env.put("a", 400);
     env.put("b", 9.0);
 
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/seq/SeqMapFunctionUnitTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/seq/SeqMapFunctionUnitTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/seq/SeqMapFunctionUnitTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/seq/SeqMapFunctionUnitTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -1,13 +1,15 @@
 package com.googlecode.aviator.runtime.function.seq;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 import java.util.LinkedList;
 import java.util.List;
 import org.junit.Test;
 import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.TestUtils;
 import com.googlecode.aviator.runtime.type.AviatorJavaType;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 import com.googlecode.aviator.runtime.type.AviatorRuntimeJavaType;
+import com.googlecode.aviator.utils.Env;
 
 
 public class SeqMapFunctionUnitTest {
@@ -35,9 +37,10 @@
       strs.add("hello");
     }
     SeqMapFunction fun = new SeqMapFunction();
+    Env env = TestUtils.getTestEnv();
     AviatorObject result =
-        fun.call(null, new AviatorRuntimeJavaType(strs), new AviatorJavaType("string.length"));
-    LinkedList array = (LinkedList) result.getValue(null);
+        fun.call(env, new AviatorRuntimeJavaType(strs), new AviatorJavaType("string.length"));
+    LinkedList array = (LinkedList) result.getValue(env);
     for (Object i : array) {
       assertEquals(5, i);
     }
@@ -46,10 +49,11 @@
 
   @Test(expected = IllegalArgumentException.class)
   public void testMap_String() {
+    Env env = TestUtils.getTestEnv();
     SeqMapFunction fun = new SeqMapFunction();
 
     AviatorObject result =
-        fun.call(null, new AviatorRuntimeJavaType("hello"), new AviatorJavaType("string.length"));
+        fun.call(env, new AviatorRuntimeJavaType("hello"), new AviatorJavaType("string.length"));
   }
 
 }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/seq/SeqReduceFunctionUnitTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/seq/SeqReduceFunctionUnitTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/seq/SeqReduceFunctionUnitTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/seq/SeqReduceFunctionUnitTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -1,17 +1,28 @@
 package com.googlecode.aviator.runtime.function.seq;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import java.util.LinkedHashSet;
+import org.junit.Before;
 import org.junit.Test;
 import com.googlecode.aviator.AviatorEvaluator;
+import com.googlecode.aviator.TestUtils;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
 import com.googlecode.aviator.runtime.type.AviatorJavaType;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 import com.googlecode.aviator.runtime.type.AviatorRuntimeJavaType;
+import com.googlecode.aviator.utils.Env;
 
 
 public class SeqReduceFunctionUnitTest {
 
+  private Env env;
+
+  @Before
+  public void setup() {
+    this.env = TestUtils.getTestEnv();
+  }
+
   @Test
   public void testReduce_Array() {
     Integer[] a = new Integer[10];
@@ -20,7 +31,7 @@
     }
 
     SeqReduceFunction fun = new SeqReduceFunction();
-    AviatorObject result = fun.call(null, new AviatorRuntimeJavaType(a), new AviatorJavaType("+"),
+    AviatorObject result = fun.call(env, new AviatorRuntimeJavaType(a), new AviatorJavaType("+"),
         new AviatorRuntimeJavaType(0));
     assertNotNull(result);
     assertEquals(45, result.getValue(null));
@@ -38,7 +49,7 @@
     }
 
     SeqReduceFunction fun = new SeqReduceFunction();
-    AviatorObject result = fun.call(null, new AviatorRuntimeJavaType(a), new AviatorJavaType("+"),
+    AviatorObject result = fun.call(env, new AviatorRuntimeJavaType(a), new AviatorJavaType("+"),
         new AviatorRuntimeJavaType(0));
 
   }
@@ -52,7 +63,7 @@
     }
 
     SeqReduceFunction fun = new SeqReduceFunction();
-    AviatorObject result = fun.call(null, new AviatorRuntimeJavaType(a), new AviatorJavaType("+"),
+    AviatorObject result = fun.call(env, new AviatorRuntimeJavaType(a), new AviatorJavaType("+"),
         new AviatorRuntimeJavaType(0));
     assertNotNull(result);
     assertEquals(45, result.getValue(null));
@@ -68,7 +79,7 @@
     }
 
     SeqReduceFunction fun = new SeqReduceFunction();
-    AviatorObject result = fun.call(null, new AviatorRuntimeJavaType(a), new AviatorJavaType("+"));
+    AviatorObject result = fun.call(env, new AviatorRuntimeJavaType(a), new AviatorJavaType("+"));
   }
 
 
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/system/BinaryFunctionUnitTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/system/BinaryFunctionUnitTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/function/system/BinaryFunctionUnitTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/function/system/BinaryFunctionUnitTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -2,19 +2,29 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
+import org.junit.Before;
 import org.junit.Test;
+import com.googlecode.aviator.TestUtils;
 import com.googlecode.aviator.lexer.token.OperatorType;
 import com.googlecode.aviator.runtime.type.AviatorBoolean;
 import com.googlecode.aviator.runtime.type.AviatorLong;
 import com.googlecode.aviator.runtime.type.AviatorObject;
+import com.googlecode.aviator.utils.Env;
 
 
 public class BinaryFunctionUnitTest {
 
+  private Env env;
+
+  @Before
+  public void setup() {
+    env = TestUtils.getTestEnv();
+  }
+
   @Test
   public void testAddFunction() {
     BinaryFunction fun = new BinaryFunction(OperatorType.ADD);
-    AviatorObject result = fun.call(null, AviatorLong.valueOf(10L), AviatorLong.valueOf(11L));
+    AviatorObject result = fun.call(env, AviatorLong.valueOf(10L), AviatorLong.valueOf(11L));
     assertEquals(21L, (Long) result.getValue(null), 0L);
 
   }
@@ -23,7 +33,7 @@
   @Test
   public void testSubFunction() {
     BinaryFunction fun = new BinaryFunction(OperatorType.SUB);
-    AviatorObject result = fun.call(null, AviatorLong.valueOf(10L), AviatorLong.valueOf(11L));
+    AviatorObject result = fun.call(env, AviatorLong.valueOf(10L), AviatorLong.valueOf(11L));
     assertEquals(-1L, (Long) result.getValue(null), 0L);
 
   }
@@ -32,7 +42,7 @@
   @Test
   public void testMultFunction() {
     BinaryFunction fun = new BinaryFunction(OperatorType.MULT);
-    AviatorObject result = fun.call(null, AviatorLong.valueOf(10L), AviatorLong.valueOf(11L));
+    AviatorObject result = fun.call(env, AviatorLong.valueOf(10L), AviatorLong.valueOf(11L));
     assertEquals(110L, (Long) result.getValue(null), 0L);
 
   }
@@ -41,7 +51,7 @@
   @Test
   public void testDivFunction() {
     BinaryFunction fun = new BinaryFunction(OperatorType.DIV);
-    AviatorObject result = fun.call(null, AviatorLong.valueOf(10L), AviatorLong.valueOf(11L));
+    AviatorObject result = fun.call(env, AviatorLong.valueOf(10L), AviatorLong.valueOf(11L));
     assertEquals(0, (Long) result.getValue(null), 0.00);
 
   }
@@ -50,7 +60,7 @@
   @Test
   public void testModFunction() {
     BinaryFunction fun = new BinaryFunction(OperatorType.MOD);
-    AviatorObject result = fun.call(null, AviatorLong.valueOf(10L), AviatorLong.valueOf(11L));
+    AviatorObject result = fun.call(env, AviatorLong.valueOf(10L), AviatorLong.valueOf(11L));
     assertEquals(10L, (Long) result.getValue(null), 0L);
 
   }
@@ -59,7 +69,7 @@
   @Test
   public void testNegFunction() {
     BinaryFunction fun = new BinaryFunction(OperatorType.NEG);
-    AviatorObject result = fun.call(null, AviatorLong.valueOf(10L));
+    AviatorObject result = fun.call(env, AviatorLong.valueOf(10L));
     assertEquals(-10L, (Long) result.getValue(null), 0L);
 
   }
@@ -68,7 +78,7 @@
   @Test
   public void testNotFunction() {
     BinaryFunction fun = new BinaryFunction(OperatorType.NOT);
-    AviatorObject result = fun.call(null, AviatorBoolean.FALSE);
+    AviatorObject result = fun.call(env, AviatorBoolean.FALSE);
     assertTrue((Boolean) result.getValue(null));
 
   }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/type/AviatorNumberUnitTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/type/AviatorNumberUnitTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/type/AviatorNumberUnitTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/type/AviatorNumberUnitTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -22,7 +22,9 @@
 import java.util.HashMap;
 import java.util.Map;
 import org.junit.Test;
+import com.googlecode.aviator.TestUtils;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.utils.Env;
 
 
 public class AviatorNumberUnitTest {
@@ -373,158 +375,155 @@
 
 
   public void testArthOperationWithNumber(OperatorType operatorType) {
-
+    Env env = TestUtils.getTestEnv();
     switch (operatorType) {
       case Add:
         this.reset();
-        assertEquals(6.3, this.a.add(this.b, null).getValue(null));
+        assertEquals(6.3, this.a.add(this.b, env).getValue(env));
         this.reset();
-        assertEquals(6.3, this.b.add(this.a, null).getValue(null));
+        assertEquals(6.3, this.b.add(this.a, env).getValue(env));
         this.reset();
-        assertEquals(7.6, this.a.add(this.d, null).getValue(null));
+        assertEquals(7.6, this.a.add(this.d, env).getValue(env));
         this.reset();
-        assertEquals(7.6, this.d.add(this.a, null).getValue(null));
+        assertEquals(7.6, this.d.add(this.a, env).getValue(env));
         this.reset();
-        assertEquals(1003, this.b.add(this.c, null).getValue(null));
+        assertEquals(1003, this.b.add(this.c, env).getValue(env));
         this.reset();
-        assertEquals(1003, this.c.add(this.b, null).getValue(null));
+        assertEquals(1003, this.c.add(this.b, env).getValue(env));
         this.reset();
-        assertEquals(7.3, this.b.add(this.d, null).getValue(null));
+        assertEquals(7.3, this.b.add(this.d, env).getValue(env));
         this.reset();
-        assertEquals(7.3, this.d.add(this.b, null).getValue(null));
+        assertEquals(7.3, this.d.add(this.b, env).getValue(env));
 
-        assertEquals(new BigInteger("92233720368547758074"),
-            this.b.add(this.e, null).getValue(null));
-        assertEquals(new BigInteger("92233720368547759071"),
-            this.c.add(this.e, null).getValue(null));
-        assertEquals(9.223372036854776E18, this.a.add(this.e, null).getValue(null));
+        assertEquals(new BigInteger("92233720368547758074"), this.b.add(this.e, env).getValue(env));
+        assertEquals(new BigInteger("92233720368547759071"), this.c.add(this.e, env).getValue(env));
+        assertEquals(9.223372036854776E18, this.a.add(this.e, env).getValue(env));
 
         assertEquals(new BigDecimal("92233720368547758074.1001"),
-            this.b.add(this.f, null).getValue(null));
+            this.b.add(this.f, env).getValue(env));
         assertEquals(new BigDecimal("92233720368547759071.1001"),
-            this.c.add(this.f, null).getValue(null));
-        assertEquals(9.223372036854776E19, this.a.add(this.f, null).getValue(null));
+            this.c.add(this.f, env).getValue(env));
+        assertEquals(9.223372036854776E19, this.a.add(this.f, env).getValue(env));
         break;
       case Sub:
         this.reset();
-        assertEquals(0.3, this.a.sub(this.b, null).getValue(null));
+        assertEquals(0.3, this.a.sub(this.b, env).getValue(env));
         this.reset();
-        assertEquals(-0.3, this.b.sub(this.a, null).getValue(null));
+        assertEquals(-0.3, this.b.sub(this.a, env).getValue(env));
         this.reset();
-        assertEquals(-1.0, this.a.sub(this.d, null).getValue(null));
+        assertEquals(-1.0, this.a.sub(this.d, env).getValue(env));
         this.reset();
-        assertEquals(1.0, this.d.sub(this.a, null).getValue(null));
+        assertEquals(1.0, this.d.sub(this.a, env).getValue(env));
         this.reset();
-        assertEquals(-997, this.b.sub(this.c, null).getValue(null));
+        assertEquals(-997, this.b.sub(this.c, env).getValue(env));
         this.reset();
-        assertEquals(997, this.c.sub(this.b, null).getValue(null));
+        assertEquals(997, this.c.sub(this.b, env).getValue(env));
         this.reset();
-        assertEquals(-1.3, this.b.sub(this.d, null).getValue(null));
+        assertEquals(-1.3, this.b.sub(this.d, env).getValue(env));
         this.reset();
-        assertEquals(1.3, this.d.sub(this.b, null).getValue(null));
+        assertEquals(1.3, this.d.sub(this.b, env).getValue(env));
 
         assertEquals(new BigInteger("-92233720368547758068"),
-            this.b.sub(this.e, null).getValue(null));
+            this.b.sub(this.e, env).getValue(env));
         assertEquals(new BigInteger("-92233720368547757071"),
-            this.c.sub(this.e, null).getValue(null));
-        assertEquals(-9.223372036854776E19, this.a.sub(this.e, null).getValue(null));
+            this.c.sub(this.e, env).getValue(env));
+        assertEquals(-9.223372036854776E19, this.a.sub(this.e, env).getValue(env));
 
         assertEquals(new BigDecimal("-92233720368547758068.1001"),
-            this.b.sub(this.f, null).getValue(null));
+            this.b.sub(this.f, env).getValue(env));
         assertEquals(new BigDecimal("-92233720368547757071.1001"),
-            this.c.sub(this.f, null).getValue(null));
-        assertEquals(-9.223372036854776E19, this.a.sub(this.f, null).getValue(null));
+            this.c.sub(this.f, env).getValue(env));
+        assertEquals(-9.223372036854776E19, this.a.sub(this.f, env).getValue(env));
         break;
       case Mult:
         this.reset();
-        assertEquals(9.9, this.a.mult(this.b, null).getValue(null));
+        assertEquals(9.9, this.a.mult(this.b, env).getValue(env));
         this.reset();
-        assertEquals(9.9, this.b.mult(this.a, null).getValue(null));
+        assertEquals(9.9, this.b.mult(this.a, env).getValue(env));
         this.reset();
-        assertEquals(14.19, this.a.mult(this.d, null).getValue(null));
+        assertEquals(14.19, this.a.mult(this.d, env).getValue(env));
         this.reset();
-        assertEquals(14.19, this.d.mult(this.a, null).getValue(null));
+        assertEquals(14.19, this.d.mult(this.a, env).getValue(env));
         this.reset();
-        assertEquals(3000, this.b.mult(this.c, null).getValue(null));
+        assertEquals(3000, this.b.mult(this.c, env).getValue(env));
         this.reset();
-        assertEquals(3000, this.c.mult(this.b, null).getValue(null));
+        assertEquals(3000, this.c.mult(this.b, env).getValue(env));
         this.reset();
-        assertEquals(12.9, this.b.mult(this.d, null).getValue(null));
+        assertEquals(12.9, this.b.mult(this.d, env).getValue(env));
         this.reset();
-        assertEquals(12.9, this.d.mult(this.b, null).getValue(null));
+        assertEquals(12.9, this.d.mult(this.b, env).getValue(env));
 
         assertEquals(new BigInteger("276701161105643274213"),
-            this.b.mult(this.e, null).getValue(null));
+            this.b.mult(this.e, env).getValue(env));
         assertEquals(new BigInteger("92233720368547758071000"),
-            this.c.mult(this.e, null).getValue(null));
-        assertEquals(3.043712772162076E20, this.a.mult(this.e, null).getValue(null));
+            this.c.mult(this.e, env).getValue(env));
+        assertEquals(3.043712772162076E20, this.a.mult(this.e, env).getValue(env));
 
         assertEquals(new BigDecimal("276701161105643274213.3003"),
-            this.b.mult(this.f, null).getValue(null));
+            this.b.mult(this.f, env).getValue(env));
         assertEquals(new BigDecimal("92233720368547758071100.1000"),
-            this.c.mult(this.f, null).getValue(null));
-        assertEquals(3.043712772162076E20, this.a.mult(this.f, null).getValue(null));
+            this.c.mult(this.f, env).getValue(env));
+        assertEquals(3.043712772162076E20, this.a.mult(this.f, env).getValue(env));
         break;
 
       case Div:
         this.reset();
         // 3.3 3 1000 4.3
-        assertEquals(1.1, (Double) this.a.div(this.b, null).getValue(null), 0.001);
+        assertEquals(1.1, (Double) this.a.div(this.b, env).getValue(env), 0.001);
         this.reset();
-        assertEquals(0.90909090, (Double) this.b.div(this.a, null).getValue(null), 0.001);
+        assertEquals(0.90909090, (Double) this.b.div(this.a, env).getValue(env), 0.001);
         this.reset();
-        assertEquals(0.76744, (Double) this.a.div(this.d, null).getValue(null), 0.001);
+        assertEquals(0.76744, (Double) this.a.div(this.d, env).getValue(env), 0.001);
         this.reset();
-        assertEquals(1.30303030, (Double) this.d.div(this.a, null).getValue(null), 0.001);
+        assertEquals(1.30303030, (Double) this.d.div(this.a, env).getValue(env), 0.001);
         this.reset();
-        assertEquals(0, this.b.div(this.c, null).getValue(null));
+        assertEquals(0, this.b.div(this.c, env).getValue(env));
         this.reset();
-        assertEquals(333, this.c.div(this.b, null).getValue(null));
+        assertEquals(333, this.c.div(this.b, env).getValue(env));
         this.reset();
-        assertEquals(0.6976744, (Double) this.b.div(this.d, null).getValue(null), 0.001);
+        assertEquals(0.6976744, (Double) this.b.div(this.d, env).getValue(env), 0.001);
         this.reset();
-        assertEquals(1.433333333, (Double) this.d.div(this.b, null).getValue(null), 0.001);
+        assertEquals(1.433333333, (Double) this.d.div(this.b, env).getValue(env), 0.001);
 
-        assertEquals(new BigInteger("30744573456182586023"),
-            this.e.div(this.b, null).getValue(null));
-        assertEquals(new BigInteger("92233720368547758"), this.e.div(this.c, null).getValue(null));
-        assertEquals(2.794961223289326E19, this.e.div(this.a, null).getValue(null));
+        assertEquals(new BigInteger("30744573456182586023"), this.e.div(this.b, env).getValue(env));
+        assertEquals(new BigInteger("92233720368547758"), this.e.div(this.c, env).getValue(env));
+        assertEquals(2.794961223289326E19, this.e.div(this.a, env).getValue(env));
 
         assertEquals(new BigDecimal("3.252606517456513302336211867796323E-20"),
-            this.b.div(this.f, null).getValue(null));
+            this.b.div(this.f, env).getValue(env));
         assertEquals(new BigDecimal("1.084202172485504434112070622598774E-17"),
-            this.c.div(this.f, null).getValue(null));
-        assertEquals(3.577867169202164E-20, this.a.div(this.f, null).getValue(null));
+            this.c.div(this.f, env).getValue(env));
+        assertEquals(3.577867169202164E-20, this.a.div(this.f, env).getValue(env));
         break;
       case Mod:
         this.reset();
-        assertEquals(0.3, (Double) this.a.mod(this.b, null).getValue(null), 0.001);
+        assertEquals(0.3, (Double) this.a.mod(this.b, env).getValue(env), 0.001);
         this.reset();
-        assertEquals(3.0, (Double) this.b.mod(this.a, null).getValue(null), 0.001);
+        assertEquals(3.0, (Double) this.b.mod(this.a, env).getValue(env), 0.001);
         this.reset();
-        assertEquals(3.3, (Double) this.a.mod(this.d, null).getValue(null), 0.001);
+        assertEquals(3.3, (Double) this.a.mod(this.d, env).getValue(env), 0.001);
         this.reset();
-        assertEquals(1.0, (Double) this.d.mod(this.a, null).getValue(null), 0.001);
+        assertEquals(1.0, (Double) this.d.mod(this.a, env).getValue(env), 0.001);
         this.reset();
-        assertEquals(3, this.b.mod(this.c, null).getValue(null));
+        assertEquals(3, this.b.mod(this.c, env).getValue(env));
         this.reset();
-        assertEquals(1, this.c.mod(this.b, null).getValue(null));
+        assertEquals(1, this.c.mod(this.b, env).getValue(env));
         this.reset();
-        assertEquals(3.0, (Double) this.b.mod(this.d, null).getValue(null), 0.001);
+        assertEquals(3.0, (Double) this.b.mod(this.d, env).getValue(env), 0.001);
         this.reset();
-        assertEquals(1.3, (Double) this.d.mod(this.b, null).getValue(null), 0.001);
+        assertEquals(1.3, (Double) this.d.mod(this.b, env).getValue(env), 0.001);
 
-        assertEquals(new BigInteger("2"), this.e.mod(this.b, null).getValue(null));
-        assertEquals(new BigInteger("71"), this.e.mod(this.c, null).getValue(null));
-        assertEquals(0.0, this.e.mod(this.a, null).getValue(null));
+        assertEquals(new BigInteger("2"), this.e.mod(this.b, env).getValue(env));
+        assertEquals(new BigInteger("71"), this.e.mod(this.c, env).getValue(env));
+        assertEquals(0.0, this.e.mod(this.a, env).getValue(env));
 
-        assertEquals(new BigDecimal("3"), this.b.mod(this.f, null).getValue(null));
-        assertEquals(new BigDecimal("1000"), this.c.mod(this.f, null).getValue(null));
-        assertEquals(3.3, this.a.mod(this.f, null).getValue(null));
+        assertEquals(new BigDecimal("3"), this.b.mod(this.f, env).getValue(env));
+        assertEquals(new BigDecimal("1000"), this.c.mod(this.f, env).getValue(env));
+        assertEquals(3.3, this.a.mod(this.f, env).getValue(env));
 
-        assertEquals(new BigDecimal("2.1001"), this.f.mod(this.b, null).getValue(null));
-        assertEquals(new BigDecimal("71.1001"), this.f.mod(this.c, null).getValue(null));
-        assertEquals(0.0, this.f.mod(this.a, null).getValue(null));
+        assertEquals(new BigDecimal("2.1001"), this.f.mod(this.b, env).getValue(env));
+        assertEquals(new BigDecimal("71.1001"), this.f.mod(this.c, env).getValue(env));
+        assertEquals(0.0, this.f.mod(this.a, env).getValue(env));
         break;
     }
   }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/type/AviatorPatternUnitTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/type/AviatorPatternUnitTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/runtime/type/AviatorPatternUnitTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/runtime/type/AviatorPatternUnitTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -24,7 +24,9 @@
 import org.junit.Test;
 import com.googlecode.aviator.AviatorEvaluator;
 import com.googlecode.aviator.Options;
+import com.googlecode.aviator.TestUtils;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.utils.Env;
 import junit.framework.Assert;
 
 
@@ -109,7 +111,7 @@
 
 
   private Map<String, Object> createEnvWith(String name, Object obj) {
-    Map<String, Object> env = new HashMap<String, Object>();
+    Env env = TestUtils.getTestEnv();
     if (name != null) {
       env.put(name, obj);
     }
@@ -128,9 +130,10 @@
 
   @Test
   public void testMatchString() {
+    Env env = TestUtils.getTestEnv();
     AviatorPattern p1 = new AviatorPattern("[a-zA-Z]+");
-    assertTrue((Boolean) p1.match(new AviatorString("hello"), null).getValue(null));
-    assertFalse((Boolean) p1.match(new AviatorString("hello world"), null).getValue(null));
+    assertTrue((Boolean) p1.match(new AviatorString("hello"), env).getValue(env));
+    assertFalse((Boolean) p1.match(new AviatorString("hello world"), env).getValue(env));
   }
 
 
@@ -148,7 +151,7 @@
   public void testPatternGroup() {
     //
     AviatorPattern p1 = new AviatorPattern("-\\d+\\.\\d+");
-    Map<String, Object> env = new HashMap<String, Object>();
+    Env env = TestUtils.getTestEnv();
     p1.match(new AviatorString("-3.4"), env);
     assertEquals(1, env.size());
     assertEquals("-3.4", env.get("$0"));
Only in ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/spring: SpringContextFunctionMissingTest.java
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/spring: SringContextFunctionLoaderTest.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/test/function/FunctionTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/test/function/FunctionTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/googlecode/aviator/test/function/FunctionTest.java	2024-09-08 01:36:08.345768190 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator/test/function/FunctionTest.java	2024-09-08 01:36:08.333768107 +1000
@@ -14,15 +14,28 @@
  **/
 package com.googlecode.aviator.test.function;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import org.junit.Test;
 import com.googlecode.aviator.AviatorEvaluator;
 import com.googlecode.aviator.Expression;
 import com.googlecode.aviator.Options;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
-import org.junit.Test;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.*;
-import static org.junit.Assert.*;
+import com.googlecode.aviator.runtime.RuntimeUtils;
+import com.googlecode.aviator.utils.Env;
 
 
 public class FunctionTest {
@@ -467,9 +480,11 @@
     assertEquals(new BigInteger("199999999999999999999999999999998"),
         AviatorEvaluator.exec("99999999999999999999999999999999+99999999999999999999999999999999"));
 
+    Env env = new Env(null);
+    env.setInstance(AviatorEvaluator.getInstance());
     assertEquals(
         new BigDecimal("99999999999999999999999999999999.99999999",
-            AviatorEvaluator.getMathContext()),
+            RuntimeUtils.getMathContext(env)),
         AviatorEvaluator.exec("99999999999999999999999999999999.99999999M"));
   }
 
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/googlecode/aviator: TestUtils.java
