diff -r -U 3 ./RegMiner4APR-Regression-Bugs/WORKING/CHANGES ./RegMiner4APR-Regression-Bugs/BIC/CHANGES
--- ./RegMiner4APR-Regression-Bugs/WORKING/CHANGES	2026-01-19 21:54:24.686831355 +1100
+++ ./RegMiner4APR-Regression-Bugs/BIC/CHANGES	2026-01-19 21:55:09.274875283 +1100
@@ -8,6 +8,9 @@
   * Improved selector validation for :contains(...) with unbalanced quotes.
     <https://github.com/jhy/jsoup/issues/803>
 
+  * Improved the speed of index based CSS selectors and other methods that use elementSiblingIndex, by a factor of 18x.
+    <https://github.com/jhy/jsoup/pull/862>
+
   * Bugfix: if an attribute name started or ended with a control character, the parse would fail with a validation
     exception.
     <https://github.com/jhy/jsoup/issues/793>
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/helper: ChangeNotifyingArrayList.java
diff -r -U 3 ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Element.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Element.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Element.java	2026-01-19 21:54:24.690831359 +1100
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Element.java	2026-01-19 21:55:09.274875283 +1100
@@ -14,6 +14,7 @@
 import org.jsoup.select.Selector;
 
 import java.io.IOException;
+import java.lang.ref.SoftReference;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -35,6 +36,7 @@
  */
 public class Element extends Node {
     private Tag tag;
+    private SoftReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children
 
     private static final Pattern classSplit = Pattern.compile("\\s+");
 
@@ -207,7 +209,7 @@
      * @see #childNode(int)
      */
     public Element child(int index) {
-        return children().get(index);
+        return childElementsList().get(index);
     }
 
     /**
@@ -215,18 +217,38 @@
      * <p>
      * This is effectively a filter on {@link #childNodes()} to get Element nodes.
      * </p>
-     * @return child elements. If this element has no children, returns an
-     * empty list.
+     * @return child elements. If this element has no children, returns an empty list.
      * @see #childNodes()
      */
     public Elements children() {
-        // create on the fly rather than maintaining two lists. if gets slow, memoize, and mark dirty on change
-        List<Element> elements = new ArrayList<Element>(childNodes.size());
-        for (Node node : childNodes) {
-            if (node instanceof Element)
-                elements.add((Element) node);
+        return new Elements(childElementsList());
+    }
+
+    /**
+     * Maintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.
+     * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.
+     * @return a list of child elements
+     */
+    private List<Element> childElementsList() {
+        List<Element> children;
+        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {
+            children = new ArrayList<Element>(childNodes.size());
+            for (Node node : childNodes) {
+                if (node instanceof Element)
+                    children.add((Element) node);
+            }
+            shadowChildrenRef = new SoftReference<List<Element>>(children);
         }
-        return new Elements(elements);
+        return children;
+    }
+
+    /**
+     * Clears the cached shadow child elements.
+     */
+    @Override
+    void nodelistChanged() {
+        super.nodelistChanged();
+        shadowChildrenRef = null;
     }
 
     /**
@@ -365,6 +387,25 @@
         addChildren(index, nodeArray);
         return this;
     }
+
+    /**
+     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the
+     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.
+     *
+     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the
+     * end
+     * @param children child nodes to insert
+     * @return this element, for chaining.
+     */
+    public Element insertChildren(int index, Node... children) {
+        Validate.notNull(children, "Children collection to be inserted must not be null.");
+        int currentSize = childNodeSize();
+        if (index < 0) index += currentSize +1; // roll around
+        Validate.isTrue(index >= 0 && index <= currentSize, "Insert position out of bounds.");
+
+        addChildren(index, children);
+        return this;
+    }
     
     /**
      * Create a new element by tag name, and add it as the last child.
@@ -553,7 +594,7 @@
         if (parentNode == null)
             return new Elements(0);
 
-        List<Element> elements = parent().children();
+        List<Element> elements = parent().childElementsList();
         Elements siblings = new Elements(elements.size() - 1);
         for (Element el: elements)
             if (el != this)
@@ -572,7 +613,7 @@
      */
     public Element nextElementSibling() {
         if (parentNode == null) return null;
-        List<Element> siblings = parent().children();
+        List<Element> siblings = parent().childElementsList();
         Integer index = indexInList(this, siblings);
         Validate.notNull(index);
         if (siblings.size() > index+1)
@@ -588,7 +629,7 @@
      */
     public Element previousElementSibling() {
         if (parentNode == null) return null;
-        List<Element> siblings = parent().children();
+        List<Element> siblings = parent().childElementsList();
         Integer index = indexInList(this, siblings);
         Validate.notNull(index);
         if (index > 0)
@@ -603,7 +644,7 @@
      */
     public Element firstElementSibling() {
         // todo: should firstSibling() exclude this?
-        List<Element> siblings = parent().children();
+        List<Element> siblings = parent().childElementsList();
         return siblings.size() > 1 ? siblings.get(0) : null;
     }
     
@@ -614,7 +655,7 @@
      */
     public Integer elementSiblingIndex() {
        if (parent() == null) return 0;
-       return indexInList(this, parent().children()); 
+       return indexInList(this, parent().childElementsList());
     }
 
     /**
@@ -622,7 +663,7 @@
      * @return the last sibling that is an element (aka the parent's last element child) 
      */
     public Element lastElementSibling() {
-        List<Element> siblings = parent().children();
+        List<Element> siblings = parent().childElementsList();
         return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;
     }
     
diff -r -U 3 ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Node.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Node.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/org/jsoup/nodes/Node.java	2026-01-19 21:54:24.690831359 +1100
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/org/jsoup/nodes/Node.java	2026-01-19 21:55:09.274875283 +1100
@@ -1,6 +1,7 @@
 package org.jsoup.nodes;
 
 import org.jsoup.SerializationException;
+import org.jsoup.helper.ChangeNotifyingArrayList;
 import org.jsoup.helper.StringUtil;
 import org.jsoup.helper.Validate;
 import org.jsoup.parser.Parser;
@@ -395,6 +396,10 @@
         else
             return el;
     }
+
+    void nodelistChanged() {
+        // Element overrides this to clear its shadow children elements
+    }
     
     /**
      * Replace this node in the DOM with the supplied node.
@@ -407,6 +412,7 @@
     }
 
     protected void setParentNode(Node parentNode) {
+        Validate.notNull(parentNode);
         if (this.parentNode != null)
             this.parentNode.removeChild(this);
         this.parentNode = parentNode;
@@ -456,7 +462,7 @@
 
     protected void ensureChildNodes() {
         if (childNodes == EMPTY_NODES) {
-            childNodes = new ArrayList<Node>(4);
+            childNodes = new NodeList(4);
         }
     }
 
@@ -665,7 +671,7 @@
         clone.siblingIndex = parent == null ? 0 : siblingIndex;
         clone.attributes = attributes != null ? attributes.clone() : null;
         clone.baseUri = baseUri;
-        clone.childNodes = new ArrayList<Node>(childNodes.size());
+        clone.childNodes = new NodeList(childNodes.size());
 
         for (Node child: childNodes)
             clone.childNodes.add(child);
@@ -700,4 +706,14 @@
             }
         }
     }
+
+    private final class NodeList extends ChangeNotifyingArrayList<Node> {
+        NodeList(int initialCapacity) {
+            super(initialCapacity);
+        }
+
+        public void onContentsChanged() {
+            nodelistChanged();
+        }
+    }
 }
diff -r -U 3 ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/org/jsoup/nodes/ElementTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/org/jsoup/nodes/ElementTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/org/jsoup/nodes/ElementTest.java	2026-01-19 21:54:24.694831363 +1100
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/org/jsoup/nodes/ElementTest.java	2026-01-19 21:55:09.282875290 +1100
@@ -750,7 +750,7 @@
         }
 
         try {
-            div2.insertChildren(0, null);
+            div2.insertChildren(0, (Collection<? extends Node>) null);
             fail();
         } catch (IllegalArgumentException e) {
         }
@@ -1002,7 +1002,7 @@
         assertTrue(a.tagName().equals("P"));
     }
 
-    public void testChildrenElements() {
+    @Test public void testChildrenElements() {
         String html = "<div><p><a>One</a></p><p><a>Two</a></p>Three</div><span>Four</span><foo></foo><img>";
         Document doc = Jsoup.parse(html);
         Element div = doc.select("div").first();
@@ -1031,6 +1031,47 @@
         assertEquals(0, img.childNodes().size());
     }
 
+    @Test public void testShadowElementsAreUpdated() {
+        String html = "<div><p><a>One</a></p><p><a>Two</a></p>Three</div><span>Four</span><foo></foo><img>";
+        Document doc = Jsoup.parse(html);
+        Element div = doc.select("div").first();
+        Elements els = div.children();
+        List<Node> nodes = div.childNodes();
+
+        assertEquals(2, els.size()); // the two Ps
+        assertEquals(3, nodes.size()); // the "Three" textnode
+
+        Element p3 = new Element("p").text("P3");
+        Element p4 = new Element("p").text("P4");
+        div.insertChildren(1, p3);
+        div.insertChildren(3, p4);
+        Elements els2 = div.children();
+
+        // first els should not have changed
+        assertEquals(2, els.size());
+        assertEquals(4, els2.size());
+
+        assertEquals("<p><a>One</a></p>\n" +
+            "<p>P3</p>\n" +
+            "<p><a>Two</a></p>\n" +
+            "<p>P4</p>Three", div.html());
+        assertEquals("P3", els2.get(1).text());
+        assertEquals("P4", els2.get(3).text());
+
+        p3.after("<span>Another</span");
+
+        Elements els3 = div.children();
+        assertEquals(5, els3.size());
+        assertEquals("span", els3.get(2).tagName());
+        assertEquals("Another", els3.get(2).text());
+
+        assertEquals("<p><a>One</a></p>\n" +
+            "<p>P3</p>\n" +
+            "<span>Another</span>\n" +
+            "<p><a>Two</a></p>\n" +
+            "<p>P4</p>Three", div.html());
+    }
+
 	@Test
     public void testNextElementSiblingAfterClone() {
         // via https://github.com/jhy/jsoup/issues/951
