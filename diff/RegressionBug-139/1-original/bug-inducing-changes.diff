diff -r -U 3 ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/AbstractWriter.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/AbstractWriter.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/AbstractWriter.java	2025-12-29 16:14:37.586715686 +1100
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/AbstractWriter.java	2025-12-29 16:17:03.018617249 +1100
@@ -167,7 +167,7 @@
 		this.maxColumns = settings.getMaxColumns();
 
 		this.appender = new WriterCharAppender(settings.getMaxCharsPerColumn(), "", settings.getFormat());
-		this.rowAppender = new WriterCharAppender(settings.getMaxCharsPerColumn() * settings.getMaxColumns(), "", settings.getFormat());
+		this.rowAppender = new WriterCharAppender(settings.getMaxCharsPerColumn(), "", settings.getFormat());
 
 		if (writer != null) {
 			if (writer instanceof BufferedWriter) {
diff -r -U 3 ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/input/DefaultCharAppender.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/input/DefaultCharAppender.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/input/DefaultCharAppender.java	2025-12-29 16:14:37.590715683 +1100
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/input/DefaultCharAppender.java	2025-12-29 16:17:03.022617246 +1100
@@ -20,7 +20,7 @@
 public class DefaultCharAppender implements CharAppender {
 
 	final char[] emptyChars; // default value to return when no characters have been accumulated
-	final char[] chars;
+	char[] chars;
 	final char padding;
 	int index = 0;
 	final String emptyValue; // default value to return when no characters have been accumulated
@@ -61,12 +61,12 @@
 	 */
 	@Override
 	public void appendIgnoringWhitespaceAndPadding(char ch) {
+		chars[index++] = ch;
 		if (ch <= ' ' || ch == padding) {
 			whitespaceCount++;
 		} else {
 			whitespaceCount = 0;
 		}
-		chars[index++] = ch;
 	}
 
 	/**
@@ -74,12 +74,12 @@
 	 */
 	@Override
 	public void appendIgnoringPadding(char ch) {
+		chars[index++] = ch;
 		if (ch == padding) {
 			whitespaceCount++;
 		} else {
 			whitespaceCount = 0;
 		}
-		chars[index++] = ch;
 	}
 
 	/**
@@ -87,12 +87,12 @@
 	 */
 	@Override
 	public void appendIgnoringWhitespace(char ch) {
+		chars[index++] = ch;
 		if (ch <= ' ') {
 			whitespaceCount++;
 		} else {
 			whitespaceCount = 0;
 		}
-		chars[index++] = ch;
 	}
 
 	/**
diff -r -U 3 ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/input/WriterCharAppender.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/input/WriterCharAppender.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/univocity/parsers/common/input/WriterCharAppender.java	2025-12-29 16:14:37.590715683 +1100
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/univocity/parsers/common/input/WriterCharAppender.java	2025-12-29 16:17:03.022617246 +1100
@@ -18,6 +18,7 @@
 import com.univocity.parsers.common.*;
 
 import java.io.*;
+import java.util.*;
 
 /**
  * Extension of the {@link DefaultCharAppender} class to include facilities for writing to an output. Used by writers extending  {@link AbstractWriter}.
@@ -25,11 +26,9 @@
  * <p> This class introduces the handling of the normalized newline character defined in {@link Format#getNormalizedNewline()} and converts it to the newline sequence in {@link Format#getLineSeparator()}
  * <p> It also introduces methods to write to an instance of  {@link java.io.Writer} directly to avoid unnecessary String instantiations.
  *
+ * @author uniVocity Software Pty Ltd - <a href="mailto:parsers@univocity.com">parsers@univocity.com</a>
  * @see com.univocity.parsers.common.Format
  * @see com.univocity.parsers.common.AbstractWriter
- *
- * @author uniVocity Software Pty Ltd - <a href="mailto:parsers@univocity.com">parsers@univocity.com</a>
- *
  */
 public class WriterCharAppender extends DefaultCharAppender {
 
@@ -40,16 +39,16 @@
 	/**
 	 * Creates a WriterCharAppender with:
 	 * <ul>
-	 *  <li>a maximum limit of characters to append</li>
-	 *  <li>the default value to return when no characters have been accumulated.</li>
-	 *  <li>the basic {@link Format} specification for handling newlines</li>
+	 * <li>a maximum limit of characters to append</li>
+	 * <li>the default value to return when no characters have been accumulated.</li>
+	 * <li>the basic {@link Format} specification for handling newlines</li>
 	 * </ul>
 	 *
 	 * The padding character is defaulted to a whitespace character ' '.
 	 *
-	 * @param maxLength maximum limit of characters to append
+	 * @param maxLength  maximum limit of characters to append
 	 * @param emptyValue default value to return when no characters have been accumulated
-	 * @param format output format specification used for newline handling
+	 * @param format     output format specification used for newline handling
 	 */
 	public WriterCharAppender(int maxLength, String emptyValue, Format format) {
 		this(maxLength, emptyValue, ' ', format);
@@ -58,17 +57,17 @@
 	/**
 	 * Creates a WriterCharAppender with:
 	 * <ul>
-	 *  <li>a maximum limit of characters to append</li>
-	 *  <li>the default value to return when no characters have been accumulated.</li>
-	 *  <li>the basic {@link Format} specification for handling newlines</li>
+	 * <li>a maximum limit of characters to append</li>
+	 * <li>the default value to return when no characters have been accumulated.</li>
+	 * <li>the basic {@link Format} specification for handling newlines</li>
 	 * </ul>
 	 *
 	 * The padding character is defaulted to a whitespace character ' '.
 	 *
-	 * @param maxLength maximum limit of characters to append
+	 * @param maxLength  maximum limit of characters to append
 	 * @param emptyValue default value to return when no characters have been accumulated
-	 * @param padding the padding character to ignore when calling {@link WriterCharAppender#appendIgnoringWhitespaceAndPadding(char)}.
-	 * @param format the output format specification used for newline handling
+	 * @param padding    the padding character to ignore when calling {@link WriterCharAppender#appendIgnoringWhitespaceAndPadding(char)}.
+	 * @param format     the output format specification used for newline handling
 	 */
 	public WriterCharAppender(int maxLength, String emptyValue, char padding, Format format) {
 		super(maxLength, emptyValue, padding);
@@ -90,13 +89,18 @@
 	 */
 	@Override
 	public void appendIgnoringWhitespace(char ch) {
-		if (ch == newLine) {
-			super.appendIgnoringWhitespace(lineSeparator1);
-			if (lineSeparator2 != '\0') {
-				super.appendIgnoringWhitespace(lineSeparator2);
+		try {
+			if (ch == newLine) {
+				super.appendIgnoringWhitespace(lineSeparator1);
+				if (lineSeparator2 != '\0') {
+					super.appendIgnoringWhitespace(lineSeparator2);
+				}
+			} else {
+				super.appendIgnoringWhitespace(ch);
 			}
-		} else {
-			super.appendIgnoringWhitespace(ch);
+		} catch (ArrayIndexOutOfBoundsException e) {
+			expandAndRetry();
+			appendIgnoringPadding(ch);
 		}
 	}
 
@@ -109,13 +113,18 @@
 	 */
 	@Override
 	public void appendIgnoringPadding(char ch) {
-		if (ch == newLine) {
-			super.appendIgnoringPadding(lineSeparator1);
-			if (lineSeparator2 != '\0') {
-				super.appendIgnoringPadding(lineSeparator2);
+		try {
+			if (ch == newLine) {
+				super.appendIgnoringPadding(lineSeparator1);
+				if (lineSeparator2 != '\0') {
+					super.appendIgnoringPadding(lineSeparator2);
+				}
+			} else {
+				super.appendIgnoringPadding(ch);
 			}
-		} else {
-			super.appendIgnoringPadding(ch);
+		} catch (ArrayIndexOutOfBoundsException e) {
+			expandAndRetry();
+			appendIgnoringPadding(ch);
 		}
 	}
 
@@ -128,13 +137,18 @@
 	 */
 	@Override
 	public void appendIgnoringWhitespaceAndPadding(char ch) {
-		if (ch == newLine) {
-			super.appendIgnoringWhitespaceAndPadding(lineSeparator1);
-			if (lineSeparator2 != '\0') {
-				super.appendIgnoringWhitespaceAndPadding(lineSeparator2);
+		try {
+			if (ch == newLine) {
+				super.appendIgnoringWhitespaceAndPadding(lineSeparator1);
+				if (lineSeparator2 != '\0') {
+					super.appendIgnoringWhitespaceAndPadding(lineSeparator2);
+				}
+			} else {
+				super.appendIgnoringWhitespaceAndPadding(ch);
 			}
-		} else {
-			super.appendIgnoringWhitespaceAndPadding(ch);
+		} catch (ArrayIndexOutOfBoundsException e) {
+			expandAndRetry();
+			appendIgnoringPadding(ch);
 		}
 	}
 
@@ -150,7 +164,7 @@
 		if (ch == newLine) {
 			appendNewLine();
 		} else {
-			super.append(ch);
+			appendAndExpand(ch);
 		}
 	}
 
@@ -158,7 +172,9 @@
 	 * Writes the accumulated value to the {@link java.io.Writer}, discarding any trailing whitespace characters identified when using {@link WriterCharAppender#appendIgnoringWhitespace(char)}, {@link WriterCharAppender#appendIgnoringPadding(char)} or {@link WriterCharAppender#appendIgnoringWhitespaceAndPadding(char)}
 	 * <p> The internal accumulated value is discarded after invoking this method (as in {@link DefaultCharAppender#reset()})
 	 * <p> If the accumulated value is empty (i.e. no characters were appended, or all appended characters where ignored as whitespace or padding), then the written value will be the {@link DefaultCharAppender#emptyValue} attribute defined in the constructor of this class.
+	 *
 	 * @param writer the output writer
+	 *
 	 * @throws IOException if an error occurs while writing to the output.
 	 */
 	public void writeCharsAndReset(Writer writer) throws IOException {
@@ -175,9 +191,53 @@
 	 * Appends the newline character sequence specified in {@link Format#getLineSeparator()}
 	 */
 	public void appendNewLine() {
-		super.append(lineSeparator1);
+		if(index + 2 >= chars.length){
+			expand();
+		}
+		chars[index++] = lineSeparator1;
 		if (lineSeparator2 != '\0') {
-			super.append(lineSeparator2);
+			chars[index++] = lineSeparator2;
+		}
+	}
+
+	@Override
+	public void fill(char ch, int length) {
+		while (index + length > chars.length) {
+			expand(length);
+		}
+		for (int i = 0; i < length; i++) {
+			chars[index++] = ch;
+		}
+	}
+
+	private void appendAndExpand(char ch) {
+		try {
+			chars[index++] = ch;
+		} catch (ArrayIndexOutOfBoundsException e) {
+			expand();
+			chars[index] = ch;
+		}
+	}
+
+	private void expandAndRetry() {
+		expand();
+		index--;
+	}
+
+	private void expand() {
+		chars = Arrays.copyOf(chars, (int) ((double) chars.length * 1.5));
+	}
+
+	private void expand(int additionalLength) {
+		chars = Arrays.copyOf(chars, (int) ((double) (index + additionalLength) * 1.5));
+	}
+
+	public void append(DefaultCharAppender appender) {
+		try {
+			super.append(appender);
+		} catch (ArrayIndexOutOfBoundsException e) {
+			expand(appender.index);
+			super.append(appender);
 		}
 	}
 }
diff -r -U 3 ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/univocity/parsers/csv/CsvWriterTest.java ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/univocity/parsers/csv/CsvWriterTest.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/test/java/com/univocity/parsers/csv/CsvWriterTest.java	2025-12-29 16:14:37.602715675 +1100
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/test/java/com/univocity/parsers/csv/CsvWriterTest.java	2025-12-29 16:17:03.034617238 +1100
@@ -27,10 +27,10 @@
 	@DataProvider
 	public Object[][] lineSeparatorProvider() {
 		return new Object[][]{
-			{false, new char[]{'\n'}},
-			{true, new char[]{'\r', '\n'}},
-			{true, new char[]{'\n'}},
-			{false, new char[]{'\r', '\n'}},
+				{false, new char[]{'\n'}},
+				{true, new char[]{'\r', '\n'}},
+				{true, new char[]{'\n'}},
+				{false, new char[]{'\r', '\n'}},
 		};
 	}
 
@@ -50,21 +50,21 @@
 		CsvWriter writer = new CsvWriter(new OutputStreamWriter(csvResult, "UTF-8"), settings);
 
 		Object[][] expectedResult = new Object[][]{
-			{"1997", "Ford", "E350", "ac, abs, moon", "3000.00"},
-			{"1999", "Chevy", "Venture \"Extended Edition\"", null, "4900.00"},
-			{"1996", "Jeep", "Grand Cherokee", "MUST SELL!\nair, moon roof, loaded", "4799.00"},
-			{"1999", "Chevy", "Venture \"Extended Edition, Very Large\"", null, "5000.00"},
-			{null, null, "Venture \"Extended Edition\"", null, "4900.00"},
-			{null, null, null, null, null},
-			{null, null, null, null, null},
-			{null, null, "5", null, null},
-			{"1997", "Ford", "E350", "ac, abs, moon", "3000.00"},
-			{"1997", "Ford", "E350", " ac, abs, moon ", "3000.00"},
-			{"1997", "Ford", "E350", " ac, abs, moon ", "3000.00"},
-			{"19 97", "Fo rd", "E350", " ac, abs, moon ", "3000.00"},
-			{null, " ", null, "  ", "30 00.00"},
-			{"1997", "Ford", "E350", " \" ac, abs, moon \" ", "3000.00"},
-			{"1997", "Ford", "E350", "\" ac, abs, moon \" ", "3000.00"},
+				{"1997", "Ford", "E350", "ac, abs, moon", "3000.00"},
+				{"1999", "Chevy", "Venture \"Extended Edition\"", null, "4900.00"},
+				{"1996", "Jeep", "Grand Cherokee", "MUST SELL!\nair, moon roof, loaded", "4799.00"},
+				{"1999", "Chevy", "Venture \"Extended Edition, Very Large\"", null, "5000.00"},
+				{null, null, "Venture \"Extended Edition\"", null, "4900.00"},
+				{null, null, null, null, null},
+				{null, null, null, null, null},
+				{null, null, "5", null, null},
+				{"1997", "Ford", "E350", "ac, abs, moon", "3000.00"},
+				{"1997", "Ford", "E350", " ac, abs, moon ", "3000.00"},
+				{"1997", "Ford", "E350", " ac, abs, moon ", "3000.00"},
+				{"19 97", "Fo rd", "E350", " ac, abs, moon ", "3000.00"},
+				{null, " ", null, "  ", "30 00.00"},
+				{"1997", "Ford", "E350", " \" ac, abs, moon \" ", "3000.00"},
+				{"1997", "Ford", "E350", "\" ac, abs, moon \" ", "3000.00"},
 		};
 
 		writer.writeHeaders();
@@ -116,27 +116,27 @@
 		CsvWriter writer = new CsvWriter(new OutputStreamWriter(csvResult, "UTF-8"), settings);
 
 		Object[][] input = new Object[][]{
-			{"E350", "3000.00"},
-			{"Venture \"Extended Edition\"", "4900.00"},
-			{"Grand Cherokee", "4799.00"},
-			{"Venture \"Extended Edition, Very Large\"", "5000.00"},
-			{"Venture \"Extended Edition\"", "4900.00"},
-			{null, null},
-			{"5", null},
-			{"E350", "3000.00"},
+				{"E350", "3000.00"},
+				{"Venture \"Extended Edition\"", "4900.00"},
+				{"Grand Cherokee", "4799.00"},
+				{"Venture \"Extended Edition, Very Large\"", "5000.00"},
+				{"Venture \"Extended Edition\"", "4900.00"},
+				{null, null},
+				{"5", null},
+				{"E350", "3000.00"},
 		};
 		writer.writeHeaders();
 		writer.writeRowsAndClose(input);
 
 		Object[][] expectedResult = new Object[][]{
-			{null, null, "E350", null, "3000.00"},
-			{null, null, "Venture \"Extended Edition\"", null, "4900.00"},
-			{null, null, "Grand Cherokee", null, "4799.00"},
-			{null, null, "Venture \"Extended Edition, Very Large\"", null, "5000.00"},
-			{null, null, "Venture \"Extended Edition\"", null, "4900.00"},
-			{null, null, null, null, null},
-			{null, null, "5", null, null},
-			{null, null, "E350", null, "3000.00"},
+				{null, null, "E350", null, "3000.00"},
+				{null, null, "Venture \"Extended Edition\"", null, "4900.00"},
+				{null, null, "Grand Cherokee", null, "4799.00"},
+				{null, null, "Venture \"Extended Edition, Very Large\"", null, "5000.00"},
+				{null, null, "Venture \"Extended Edition\"", null, "4900.00"},
+				{null, null, null, null, null},
+				{null, null, "5", null, null},
+				{null, null, "E350", null, "3000.00"},
 		};
 
 		String result = csvResult.toString();
@@ -213,10 +213,10 @@
 	@DataProvider
 	public Object[][] escapeHandlingParameterProvider() {
 		return new Object[][]{
-			{false, false, "A|\"", "\",B|||\"\""},    //default: escapes only the quoted value
-			{false, true, "A|||\"", "\",B|||\"\""},    //escape the unquoted value
-			{true, false, "A|\"", "\",B|\"\""},        //assumes input is already escaped and won't change it. Quotes introduced around value with delimiter
-			{true, true, "A|\"", "\",B|\"\""}        //same as above, configured to escape the unquoted value but assumes input is already escaped.
+				{false, false, "A|\"", "\",B|||\"\""},    //default: escapes only the quoted value
+				{false, true, "A|||\"", "\",B|||\"\""},    //escape the unquoted value
+				{true, false, "A|\"", "\",B|\"\""},        //assumes input is already escaped and won't change it. Quotes introduced around value with delimiter
+				{true, true, "A|\"", "\",B|\"\""}        //same as above, configured to escape the unquoted value but assumes input is already escaped.
 		};
 	}
 
@@ -281,10 +281,10 @@
 	@DataProvider
 	public Object[][] blanksProvider() {
 		return new Object[][]{
-			{false, "--", "--,--,//,\"\"\"\"\"\",--"},
-			{true, "--", "\"//\",\"//\",\"//\",\"\"\"\"\"\",\"--\""},
-			{false, null, ",,//,\"\"\"\"\"\","},
-			{true, null, "\"//\",\"//\",\"//\",\"\"\"\"\"\",\"\""},
+				{false, "--", "--,--,//,\"\"\"\"\"\",--"},
+				{true, "--", "\"//\",\"//\",\"//\",\"\"\"\"\"\",\"--\""},
+				{false, null, ",,//,\"\"\"\"\"\","},
+				{true, null, "\"//\",\"//\",\"//\",\"\"\"\"\"\",\"\""},
 		};
 	}
 
@@ -319,4 +319,28 @@
 		assertEquals(row[3], "\"\"");
 		assertEquals(row[4], nullValue);
 	}
+
+	@Test
+	public void testWriteWithArrayExpansion() {
+		StringBuilder longText = new StringBuilder(1000000);
+		for (int i = 0; i < 1000000; i++) {
+			longText.append(i % 10);
+		}
+
+		CsvWriterSettings s = new CsvWriterSettings();
+		s.setMaxCharsPerColumn(2);
+		CsvWriter w = new CsvWriter(s);
+
+		w.writeValue(longText);
+		String value = w.writeValuesToString().trim();
+		assertEquals(value.length(), longText.length());
+		assertEquals(value, longText.toString());
+
+		w.writeValue(longText);
+		w.writeValue(longText);
+		value = w.writeValuesToString().trim();
+		assertEquals(value.length(), longText.length() * 2 + 1);
+		assertEquals(value, longText.toString() + "," + longText.toString());
+	}
+
 }
