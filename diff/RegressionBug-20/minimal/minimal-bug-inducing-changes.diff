diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/BackendConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/BackendConnection.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/BackendConnection.java	2024-09-08 01:36:10.393782533 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/BackendConnection.java	2024-09-08 01:36:10.321782029 +1000
@@ -49,7 +49,7 @@
     void execute(RouteResultsetNode node, ServerConnection source,
                  boolean autocommit);
 
-    boolean syncAndExcute();
+    boolean syncAndExecute();
 
     void rollback();
 
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java	2024-09-08 01:36:10.393782533 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/FetchStoreNodeOfChildTableHandler.java	2024-09-08 01:36:10.325782057 +1000
@@ -29,7 +29,7 @@
 
 /**
  * company where id=(select company_id from customer where id=3); the one which
- * return data (id) is the datanode to store child table's records
+ * return data (id) is the data node to store child table's records
  *
  * @author wuzhih, huqing.yan
  */
@@ -73,7 +73,7 @@
             PhysicalDBNode mysqlDN = conf.getDataNodes().get(dn);
             try {
                 if (LOGGER.isDebugEnabled()) {
-                    LOGGER.debug("execute in datanode " + dn);
+                    LOGGER.debug("execute in data_node " + dn);
                 }
                 RouteResultsetNode node = new RouteResultsetNode(dn, ServerParse.SELECT, sql);
                 node.setRunOnSlave(false); // get child node from master
@@ -161,7 +161,7 @@
         if (LOGGER.isDebugEnabled()) {
             LOGGER.debug("okResponse " + conn);
         }
-        boolean executeResponse = conn.syncAndExcute();
+        boolean executeResponse = conn.syncAndExecute();
         if (executeResponse) {
             finished.incrementAndGet();
             if (canReleaseConn()) {
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java	2024-09-08 01:36:10.393782533 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/LockTablesHandler.java	2024-09-08 01:36:10.325782057 +1000
@@ -73,7 +73,7 @@
 
     @Override
     public void okResponse(byte[] data, BackendConnection conn) {
-        boolean executeResponse = conn.syncAndExcute();
+        boolean executeResponse = conn.syncAndExecute();
         if (executeResponse) {
             if (clearIfSessionClosed(session)) {
                 return;
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java	2024-09-08 01:36:10.393782533 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeDdlHandler.java	2024-09-08 01:36:10.325782057 +1000
@@ -56,7 +56,7 @@
         }
 
         if (LOGGER.isDebugEnabled()) {
-            LOGGER.debug("execute mutinode query " + rrs.getStatement());
+            LOGGER.debug("execute multiNode query " + rrs.getStatement());
         }
 
         this.rrs = RouteResultCopy.rrCopy(rrs, ServerParse.SELECT, STMT);
@@ -138,7 +138,7 @@
                 errConnection = new ArrayList<>();
             }
             errConnection.add(conn);
-            if (!conn.syncAndExcute()) {
+            if (!conn.syncAndExecute()) {
                 return;
             }
             if (--nodeCount <= 0) {
@@ -167,7 +167,7 @@
                 errConnection = new ArrayList<>();
             }
             errConnection.add(conn);
-            if (!conn.syncAndExcute()) {
+            if (!conn.syncAndExecute()) {
                 return;
             }
             if (--nodeCount <= 0) {
@@ -196,7 +196,7 @@
         try {
             if (!isFail())
                 setFail(err.toString());
-            if (!conn.syncAndExcute()) {
+            if (!conn.syncAndExecute()) {
                 return;
             }
             if (--nodeCount > 0)
@@ -210,7 +210,7 @@
     /* arriving here is impossible */
     @Override
     public void okResponse(byte[] data, BackendConnection conn) {
-        if (!conn.syncAndExcute()) {
+        if (!conn.syncAndExecute()) {
             LOGGER.debug("MultiNodeDdlHandler should not arrive here(okResponse) !");
         }
     }
@@ -218,10 +218,10 @@
     @Override
     public void rowEofResponse(final byte[] eof, boolean isLeft, BackendConnection conn) {
         if (LOGGER.isDebugEnabled()) {
-            LOGGER.debug("on row end reseponse " + conn);
+            LOGGER.debug("on row end response " + conn);
         }
 
-        if (errorRepsponsed.get()) {
+        if (errorResponsed.get()) {
             return;
         }
 
@@ -262,14 +262,14 @@
     }
 
     @Override
-    public void fieldEofResponse(byte[] header, List<byte[]> fields, List<FieldPacket> fieldPacketsnull, byte[] eof,
+    public void fieldEofResponse(byte[] header, List<byte[]> fields, List<FieldPacket> fieldPacketsNull, byte[] eof,
                                  boolean isLeft, BackendConnection conn) {
     }
 
     @Override
-    public boolean rowResponse(final byte[] row, RowDataPacket rowPacketnull, boolean isLeft, BackendConnection conn) {
+    public boolean rowResponse(final byte[] row, RowDataPacket rowPacketNull, boolean isLeft, BackendConnection conn) {
         /* It is impossible arriving here, because we set limit to 0 */
-        return errorRepsponsed.get();
+        return errorResponsed.get();
     }
 
     @Override
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java	2024-09-08 01:36:10.393782533 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeHandler.java	2024-09-08 01:36:10.325782057 +1000
@@ -26,7 +26,7 @@
     private AtomicBoolean isFailed = new AtomicBoolean(false);
     protected volatile String error;
     protected byte packetId;
-    protected final AtomicBoolean errorRepsponsed = new AtomicBoolean(false);
+    protected final AtomicBoolean errorResponsed = new AtomicBoolean(false);
 
     public MultiNodeHandler(NonBlockingSession session) {
         if (session == null) {
@@ -48,7 +48,7 @@
 
 
     protected boolean canClose(BackendConnection conn, boolean tryErrorFinish) {
-        // realse this connection if safe
+        // release this connection if safe
         session.releaseConnectionIfSafe(conn, false);
         boolean allFinished = false;
         if (tryErrorFinish) {
@@ -69,9 +69,9 @@
         session.releaseConnectionIfSafe(conn, false);
         ErrorPacket err = new ErrorPacket();
         err.read(data);
-        String errmsg = new String(err.getMessage());
-        this.setFail(errmsg);
-        LOGGER.warn("error response from " + conn + " err " + errmsg + " code:" + err.getErrno());
+        String errMsg = new String(err.getMessage());
+        this.setFail(errMsg);
+        LOGGER.warn("error response from " + conn + " err " + errMsg + " code:" + err.getErrno());
         this.tryErrorFinished(this.decrementCountBy(1));
     }
 
@@ -109,7 +109,7 @@
         packetId = 0;
     }
 
-    protected ErrorPacket createErrPkg(String errmgs) {
+    protected ErrorPacket createErrPkg(String errMsg) {
         ErrorPacket err = new ErrorPacket();
         lock.lock();
         try {
@@ -118,13 +118,13 @@
             lock.unlock();
         }
         err.setErrno(ErrorCode.ER_UNKNOWN_ERROR);
-        err.setMessage(StringUtil.encode(errmgs, session.getSource().getCharset().getResults()));
+        err.setMessage(StringUtil.encode(errMsg, session.getSource().getCharset().getResults()));
         return err;
     }
 
     protected void tryErrorFinished(boolean allEnd) {
         if (allEnd && !session.closed()) {
-            if (errorRepsponsed.compareAndSet(false, true)) {
+            if (errorResponsed.compareAndSet(false, true)) {
                 createErrPkg(this.error).write(session.getSource());
             }
             // clear session resources,release all
@@ -135,7 +135,7 @@
                 session.closeAndClearResources(error);
             } else {
                 session.getSource().setTxInterrupt(this.error);
-                // clear resouces
+                // clear resources
                 clearResources();
             }
         }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java	2024-09-08 01:36:10.393782533 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/MultiNodeQueryHandler.java	2024-09-08 01:36:10.325782057 +1000
@@ -263,7 +263,7 @@
     @Override
     public void okResponse(byte[] data, BackendConnection conn) {
         this.netOutBytes += data.length;
-        boolean executeResponse = conn.syncAndExcute();
+        boolean executeResponse = conn.syncAndExecute();
         if (LOGGER.isDebugEnabled()) {
             LOGGER.debug("received ok response ,executeResponse:" + executeResponse + " from " + conn);
         }
@@ -321,7 +321,7 @@
 
         this.netOutBytes += eof.length;
 
-        if (errorRepsponsed.get()) {
+        if (errorResponsed.get()) {
             return;
         }
 
@@ -645,7 +645,7 @@
     }
 
     public void handleDataProcessException(Exception e) {
-        if (!errorRepsponsed.get()) {
+        if (!errorResponsed.get()) {
             this.error = e.toString();
             LOGGER.warn("caught exception ", e);
             setFail(e.toString());
@@ -656,7 +656,7 @@
     @Override
     public boolean rowResponse(final byte[] row, RowDataPacket rowPacketnull, boolean isLeft, BackendConnection conn) {
 
-        if (errorRepsponsed.get()) {
+        if (errorResponsed.get()) {
             // the connection has been closed or set to "txInterrupt" properly
             //in tryErrorFinished() method! If we close it here, it can
             // lead to tx error such as blocking rollback tx for ever.
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java	2024-09-08 01:36:10.393782533 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/query/impl/BaseSelectHandler.java	2024-09-08 01:36:10.325782057 +1000
@@ -81,7 +81,7 @@
 
     @Override
     public void okResponse(byte[] ok, BackendConnection conn) {
-        conn.syncAndExcute();
+        conn.syncAndExecute();
     }
 
     @Override
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler: ResetConnHandler.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java	2024-09-08 01:36:10.393782533 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/SingleNodeHandler.java	2024-09-08 01:36:10.325782057 +1000
@@ -176,7 +176,7 @@
         //
         this.netOutBytes += data.length;
 
-        boolean executeResponse = conn.syncAndExcute();
+        boolean executeResponse = conn.syncAndExecute();
         if (executeResponse) {
             session.handleSpecial(rrs, session.getSource().getSchema(), true);
             ServerConnection source = session.getSource();
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java	2024-09-08 01:36:10.393782533 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/handler/UnLockTablesHandler.java	2024-09-08 01:36:10.325782057 +1000
@@ -84,7 +84,7 @@
 
     @Override
     public void okResponse(byte[] data, BackendConnection conn) {
-        boolean executeResponse = conn.syncAndExcute();
+        boolean executeResponse = conn.syncAndExecute();
         if (executeResponse) {
             boolean isEndPack = decrementCountBy(1);
             session.releaseConnection(conn);
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java	2024-09-08 01:36:10.393782533 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/backend/mysql/nio/MySQLConnection.java	2024-09-08 01:36:10.325782057 +1000
@@ -15,10 +15,12 @@
 import com.actiontech.dble.net.BackendAIOConnection;
 import com.actiontech.dble.net.mysql.*;
 import com.actiontech.dble.route.RouteResultsetNode;
+import com.actiontech.dble.route.parser.util.Pair;
 import com.actiontech.dble.server.NonBlockingSession;
 import com.actiontech.dble.server.ServerConnection;
 import com.actiontech.dble.server.SystemVariables;
 import com.actiontech.dble.server.parser.ServerParse;
+import com.actiontech.dble.util.StringUtil;
 import com.actiontech.dble.util.TimeUtil;
 import com.actiontech.dble.util.exception.UnknownTxIsolationException;
 import org.slf4j.Logger;
@@ -27,6 +29,7 @@
 import java.io.UnsupportedEncodingException;
 import java.nio.channels.NetworkChannel;
 import java.security.NoSuchAlgorithmException;
+import java.util.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -44,7 +47,7 @@
     private volatile boolean isDDL = false;
     private volatile boolean isRunning;
     private volatile StatusSync statusSync;
-    private volatile boolean metaDataSyned = true;
+    private volatile boolean metaDataSynced = true;
     private volatile TxState xaStatus = TxState.TX_INITIALIZE_STATE;
     private volatile int txIsolation;
     private volatile boolean autocommit;
@@ -137,8 +140,18 @@
         *  it need to sync the status firstly for new idle connection*/
         this.txIsolation = -1;
         this.complexQuery = false;
+        this.usrVariables = new LinkedHashMap<>();
+        this.sysVariables = new LinkedHashMap<>();
     }
 
+    public void resetContextStatus() {
+        this.txIsolation = -1;
+        this.autocommit = true;
+        //TODO:CHECK
+        this.setCharacterSet(SystemVariables.getDefaultValue("character_set_server"));
+        this.usrVariables.clear();
+        this.sysVariables.clear();
+    }
     public void setRunning(boolean running) {
         isRunning = running;
     }
@@ -211,7 +224,7 @@
         this.threadId = threadId;
     }
 
-    public void setAuthenticated(boolean authenticated) {
+    void setAuthenticated(boolean authenticated) {
         isAuthenticated = authenticated;
     }
 
@@ -219,7 +232,7 @@
         return password;
     }
 
-    public void authenticate() {
+    void authenticate() {
         AuthPacket packet = new AuthPacket();
         packet.setPacketId(1);
         packet.setClientFlags(clientFlags);
@@ -254,7 +267,7 @@
         return isClosed() || isQuit.get();
     }
 
-    protected void sendQueryCmd(String query, CharsetNames clientCharset) {
+    public void sendQueryCmd(String query, CharsetNames clientCharset) {
         CommandPacket packet = new CommandPacket();
         packet.setPacketId(0);
         packet.setCommand(MySQLPacket.COM_QUERY);
@@ -316,7 +329,7 @@
         if (!sc.isAutocommit() && !sc.isTxstart() && modifiedSQLExecuted) {
             sc.setTxstart(true);
         }
-        synAndDoExecute(xaTxId, rrn, sc.getCharset(), sc.getTxIsolation(), isAutoCommit);
+        synAndDoExecute(xaTxId, rrn, sc.getCharset(), sc.getTxIsolation(), isAutoCommit, sc.getUsrVariables(), sc.getSysVariables());
     }
 
     public String getConnXID(NonBlockingSession session) {
@@ -329,23 +342,26 @@
     }
 
     private void synAndDoExecute(String xaTxID, RouteResultsetNode rrn,
-                                 CharsetNames clientCharset, int clientTxIsoLation,
-                                 boolean expectAutocommit) {
+                                 CharsetNames clientCharset, int clientTxIsolation,
+                                 boolean expectAutocommit, Map<String, String> usrVariables, Map<String, String> sysVariables) {
         String xaCmd = null;
-        boolean conAutoComit = this.autocommit;
+        boolean conAutoCommit = this.autocommit;
         String conSchema = this.schema;
         int xaSyn = 0;
         if (!expectAutocommit && xaTxID != null && xaStatus == TxState.TX_INITIALIZE_STATE) {
-            // clientTxIsoLation = Isolations.SERIALIZABLE;
+            // clientTxIsolation = Isolation.SERIALIZABLE;TODO:NEEDED?
             xaCmd = "XA START " + xaTxID + ';';
             this.xaStatus = TxState.TX_STARTED_STATE;
             xaSyn = 1;
         }
+        Set<String> toResetSys = new HashSet();
+        String setSql = getSetSQL(usrVariables, sysVariables, toResetSys);
+        int setSqlFlag = setSql == null ? 0 : 1;
         int schemaSyn = conSchema.equals(oldSchema) ? 0 : 1;
         int charsetSyn = (charsetName.equals(clientCharset)) ? 0 : 1;
-        int txIsoLationSyn = (txIsolation == clientTxIsoLation) ? 0 : 1;
-        int autoCommitSyn = (conAutoComit == expectAutocommit) ? 0 : 1;
-        int synCount = schemaSyn + charsetSyn + txIsoLationSyn + autoCommitSyn + xaSyn;
+        int txIsolationSyn = (txIsolation == clientTxIsolation) ? 0 : 1;
+        int autoCommitSyn = (conAutoCommit == expectAutocommit) ? 0 : 1;
+        int synCount = schemaSyn + charsetSyn + txIsolationSyn + autoCommitSyn + xaSyn + setSqlFlag;
         if (synCount == 0) {
             // not need syn connection
             sendQueryCmd(rrn.getStatement(), clientCharset);
@@ -355,18 +371,19 @@
         StringBuilder sb = new StringBuilder();
         if (schemaSyn == 1) {
             schemaCmd = getChangeSchemaCommand(conSchema);
-            // getChangeSchemaCommand(sb, conSchema);
         }
-
         if (charsetSyn == 1) {
             getCharsetCommand(sb, clientCharset);
         }
-        if (txIsoLationSyn == 1) {
-            getTxIsolationCommand(sb, clientTxIsoLation);
+        if (txIsolationSyn == 1) {
+            getTxIsolationCommand(sb, clientTxIsolation);
         }
         if (autoCommitSyn == 1) {
             getAutocommitCommand(sb, expectAutocommit);
         }
+        if (setSqlFlag == 1) {
+            sb.append(setSql);
+        }
         if (xaCmd != null) {
             sb.append(xaCmd);
         }
@@ -375,22 +392,73 @@
                     " commands " + sb.toString() + "schema change:" +
                     (schemaCmd != null) + " con:" + this);
         }
-        metaDataSyned = false;
+        metaDataSynced = false;
         statusSync = new StatusSync(conSchema,
-                clientCharset, clientTxIsoLation, expectAutocommit,
-                synCount);
+                clientCharset, clientTxIsolation, expectAutocommit,
+                synCount, usrVariables, sysVariables, toResetSys);
         // syn schema
         if (schemaCmd != null) {
             schemaCmd.write(this);
         }
         // and our query sql to multi command at last
-        sb.append(rrn.getStatement() + ";");
+        sb.append(rrn.getStatement()).append(";");
         // syn and execute others
         this.sendQueryCmd(sb.toString(), clientCharset);
         // waiting syn result...
 
     }
 
+    private String getSetSQL(Map<String, String> usrVars, Map<String, String> sysVars, Set<String> toResetSys) {
+        //new final var
+        List<Pair<String, String>> setVars = new ArrayList<>();
+        Map<String, String> tmpSysVars = new HashMap<>();
+        //tmp add all backend sysVariables
+        tmpSysVars.putAll(sysVariables);
+        //for all front end sysVariables
+        for (Map.Entry<String, String> entry : sysVars.entrySet()) {
+            if (!tmpSysVars.containsKey(entry.getKey())) {
+                setVars.add(new Pair<>(entry.getKey(), entry.getValue()));
+            } else {
+                String value = tmpSysVars.remove(entry.getKey());
+                //if backend is not equal frontend, need to reset
+                if (!StringUtil.equalsIgnoreCase(entry.getValue(), value)) {
+                    setVars.add(new Pair<>(entry.getKey(), entry.getValue()));
+                }
+            }
+        }
+        //tmp now = backend -(backend &&frontend)
+        for (Map.Entry<String, String> entry : tmpSysVars.entrySet()) {
+            String value = SystemVariables.getDefaultValue(entry.getKey());
+            setVars.add(new Pair<>(entry.getKey(), value));
+            toResetSys.add(entry.getKey());
+        }
+
+        for (Map.Entry<String, String> entry : usrVars.entrySet()) {
+            if (!usrVariables.containsKey(entry.getKey())) {
+                setVars.add(new Pair<>(entry.getKey(), entry.getValue()));
+            } else {
+                if (!StringUtil.equalsIgnoreCase(entry.getValue(), usrVariables.get(entry.getKey()))) {
+                    setVars.add(new Pair<>(entry.getKey(), entry.getValue()));
+                }
+            }
+        }
+
+        if (setVars.size() == 0)
+            return null;
+        StringBuilder sb = new StringBuilder("set ");
+        int cnt = 0;
+        for (Pair<String, String> var : setVars) {
+            if (cnt > 0) {
+                sb.append(",");
+            }
+            sb.append(var.getKey());
+            sb.append("=");
+            sb.append(var.getValue());
+            cnt++;
+        }
+        sb.append(";");
+        return sb.toString();
+    }
     private static CommandPacket getChangeSchemaCommand(String schema) {
         CommandPacket cmd = new CommandPacket();
         cmd.setPacketId(0);
@@ -402,14 +470,11 @@
     /**
      * by wuzh ,execute a query and ignore transaction settings for performance
      *
-     * @param query
-     * @throws UnsupportedEncodingException
      */
-    public void query(String query) throws UnsupportedEncodingException {
+    public void query(String query) {
         RouteResultsetNode rrn = new RouteResultsetNode("default",
                 ServerParse.SELECT, query);
-
-        synAndDoExecute(null, rrn, this.charsetName, this.txIsolation, true);
+        synAndDoExecute(null, rrn, this.charsetName, this.txIsolation, true, this.getUsrVariables(), this.getSysVariables());
 
     }
 
@@ -432,7 +497,7 @@
     }
 
 
-    public boolean isComplexQuery() {
+    boolean isComplexQuery() {
         return complexQuery;
     }
 
@@ -472,18 +537,23 @@
     }
 
     public void release() {
-        if (!metaDataSyned) { // indicate connection not normalfinished
+        if (!metaDataSynced) { // indicate connection not normal finished
             // ,and
             // we can't know it's syn status ,so
             // close
             // it
             LOGGER.warn("can't sure connection syn result,so close it " + this);
             this.respHandler = null;
-            this.close("syn status unkown ");
+            this.close("syn status unknown ");
+            return;
+        }
+        if (this.usrVariables.size() > 0) {
+            this.respHandler = null;
+            this.close("close for clear usrVariables");
             return;
         }
         complexQuery = false;
-        metaDataSyned = true;
+        metaDataSynced = true;
         attachment = null;
         statusSync = null;
         modifiedSQLExecuted = false;
@@ -541,12 +611,53 @@
 
     @Override
     public String toString() {
-        return "MySQLConnection [id=" + id + ", lastTime=" + lastTime + ", user=" + user + ", schema=" + schema +
-                ", old shema=" + oldSchema + ", borrowed=" + borrowed + ", fromSlaveDB=" + fromSlaveDB + ", threadId=" +
-                threadId + "," + charsetName.toString() + ", txIsolation=" + txIsolation + ", autocommit=" + autocommit +
-                ", attachment=" + attachment + ", respHandler=" + respHandler + ", host=" + host + ", port=" + port +
-                ", statusSync=" + statusSync + ", writeQueue=" + this.getWriteQueue().size() +
-                ", modifiedSQLExecuted=" + modifiedSQLExecuted + "]";
+        StringBuilder result = new StringBuilder();
+        result.append("MySQLConnection [id=");
+        result.append(id);
+        result.append(", lastTime=");
+        result.append(lastTime);
+        result.append(", user=");
+        result.append(user);
+        result.append(", schema=");
+        result.append(schema);
+        result.append(", old schema=");
+        result.append(oldSchema);
+        result.append(", borrowed=");
+        result.append(borrowed);
+        result.append(", fromSlaveDB=");
+        result.append(fromSlaveDB);
+        result.append(", threadId=");
+        result.append(threadId);
+        result.append(",");
+        result.append(charsetName.toString());
+        result.append(", txIsolation=");
+        result.append(txIsolation);
+        result.append(", autocommit=");
+        result.append(autocommit);
+        result.append(", attachment=");
+        result.append(attachment);
+        result.append(", respHandler=");
+        result.append(respHandler);
+        result.append(", host=");
+        result.append(host);
+        result.append(", port=");
+        result.append(port);
+        result.append(", statusSync=");
+        result.append(statusSync);
+        result.append(", writeQueue=");
+        result.append(this.getWriteQueue().size());
+        result.append(", modifiedSQLExecuted=");
+        result.append(modifiedSQLExecuted);
+        if (sysVariables.size() > 0) {
+            result.append(", ");
+            result.append(getStringOfSysVariables());
+        }
+        if (usrVariables.size() > 0) {
+            result.append(", ");
+            result.append(getStringOfUsrVariables());
+        }
+        result.append("]");
+        return result.toString();
     }
 
     public String compactInfo() {
@@ -572,7 +683,7 @@
      * @return if synchronization finished and execute-sql has already been sent
      * before
      */
-    public boolean syncAndExcute() {
+    public boolean syncAndExecute() {
         StatusSync sync = this.statusSync;
         if (sync == null) {
             return true;
@@ -592,23 +703,30 @@
         private final Integer txtIsolation;
         private final Boolean autocommit;
         private final AtomicInteger synCmdCount;
+        private final Map<String, String> usrVariables = new LinkedHashMap<>();
+        private final Map<String, String> sysVariables = new LinkedHashMap<>();
 
         StatusSync(String schema,
                    CharsetNames clientCharset, Integer txtIsolation, Boolean autocommit,
-                   int synCount) {
+                   int synCount, Map<String, String> usrVariables, Map<String, String> sysVariables, Set<String> toResetSys) {
             super();
             this.schema = schema;
             this.clientCharset = clientCharset;
             this.txtIsolation = txtIsolation;
             this.autocommit = autocommit;
             this.synCmdCount = new AtomicInteger(synCount);
+            this.usrVariables.putAll(usrVariables);
+            this.sysVariables.putAll(sysVariables);
+            for (String sysVariable : toResetSys) {
+                this.sysVariables.remove(sysVariable);
+            }
         }
 
-        public boolean synAndExecuted(MySQLConnection conn) {
+        boolean synAndExecuted(MySQLConnection conn) {
             int remains = synCmdCount.decrementAndGet();
             if (remains == 0) { // syn command finished
                 this.updateConnectionInfo(conn);
-                conn.metaDataSyned = true;
+                conn.metaDataSynced = true;
                 return false;
             } else if (remains < 0) {
                 return true;
@@ -630,7 +748,8 @@
             if (autocommit != null) {
                 conn.autocommit = autocommit;
             }
+            conn.sysVariables = sysVariables;
+            conn.usrVariables = usrVariables;
         }
-
     }
 }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/config/Versions.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/config/Versions.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/config/Versions.java	2024-09-08 01:36:10.397782561 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/config/Versions.java	2024-09-08 01:36:10.329782085 +1000
@@ -12,7 +12,7 @@
 
     public static final byte PROTOCOL_VERSION = 10;
 
-    private static byte[] serverVersion = "5.6.29-dble-2.17.08.0-20240827175049".getBytes();
+    private static byte[] serverVersion = "5.6.29-dble-2.17.08.0-20240827175206".getBytes();
     public static final byte[] VERSION_COMMENT = "dble Server (ActionTech)".getBytes();
     public static final String ANNOTATION_NAME = "dble:";
     public static final String ROOT_PREFIX = "dble";
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java	2024-09-08 01:36:10.401782589 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowBackend.java	2024-09-08 01:36:10.333782113 +1000
@@ -32,7 +32,7 @@
     private ShowBackend() {
     }
 
-    private static final int FIELD_COUNT = 18;
+    private static final int FIELD_COUNT = 20;
     private static final ResultSetHeaderPacket HEADER = PacketUtil.getHeader(FIELD_COUNT);
     private static final FieldPacket[] FIELDS = new FieldPacket[FIELD_COUNT];
     private static final EOFPacket EOF = new EOFPacket();
@@ -41,8 +41,7 @@
         int i = 0;
         byte packetId = 0;
         HEADER.setPacketId(++packetId);
-        FIELDS[i] = PacketUtil.getField("processor",
-                Fields.FIELD_TYPE_VAR_STRING);
+        FIELDS[i] = PacketUtil.getField("processor", Fields.FIELD_TYPE_VAR_STRING);
         FIELDS[i++].setPacketId(++packetId);
         FIELDS[i] = PacketUtil.getField("ID", Fields.FIELD_TYPE_LONG);
         FIELDS[i++].setPacketId(++packetId);
@@ -76,10 +75,15 @@
         FIELDS[i++].setPacketId(++packetId);
         FIELDS[i] = PacketUtil.getField("CHARACTER_SET_RESULTS", Fields.FIELD_TYPE_VAR_STRING);
         FIELDS[i++].setPacketId(++packetId);
-        FIELDS[i] = PacketUtil.getField("TXLEVEL", Fields.FIELD_TYPE_VAR_STRING);
+        FIELDS[i] = PacketUtil.getField("TX_ISOLATION_LEVEL", Fields.FIELD_TYPE_VAR_STRING);
         FIELDS[i++].setPacketId(++packetId);
         FIELDS[i] = PacketUtil.getField("AUTOCOMMIT", Fields.FIELD_TYPE_VAR_STRING);
+        FIELDS[i++].setPacketId(++packetId);
+        FIELDS[i] = PacketUtil.getField("SYS_VARIABLES", Fields.FIELD_TYPE_VAR_STRING);
+        FIELDS[i++].setPacketId(++packetId);
+        FIELDS[i] = PacketUtil.getField("USER_VARIABLES", Fields.FIELD_TYPE_VAR_STRING);
         FIELDS[i].setPacketId(++packetId);
+
         EOF.setPacketId(++packetId);
     }
 
@@ -132,6 +136,8 @@
         row.add(conn.getCharset().getResults().getBytes());
         row.add((conn.getTxIsolation() + "").getBytes());
         row.add((conn.isAutocommit() + "").getBytes());
+        row.add(StringUtil.encode(conn.getStringOfSysVariables(), charset));
+        row.add(StringUtil.encode(conn.getStringOfUsrVariables(), charset));
         return row;
     }
 }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java	2024-09-08 01:36:10.401782589 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowConnection.java	2024-09-08 01:36:10.333782113 +1000
@@ -33,7 +33,7 @@
     private ShowConnection() {
     }
 
-    private static final int FIELD_COUNT = 17;
+    private static final int FIELD_COUNT = 19;
     private static final ResultSetHeaderPacket HEADER = PacketUtil.getHeader(FIELD_COUNT);
     private static final FieldPacket[] FIELDS = new FieldPacket[FIELD_COUNT];
     private static final EOFPacket EOF = new EOFPacket();
@@ -80,8 +80,7 @@
         FIELDS[i] = PacketUtil.getField("NET_OUT", Fields.FIELD_TYPE_LONGLONG);
         FIELDS[i++].setPacketId(++packetId);
 
-        FIELDS[i] = PacketUtil.getField("ALIVE_TIME(S)",
-                Fields.FIELD_TYPE_LONGLONG);
+        FIELDS[i] = PacketUtil.getField("ALIVE_TIME(S)", Fields.FIELD_TYPE_LONGLONG);
         FIELDS[i++].setPacketId(++packetId);
 
         FIELDS[i] = PacketUtil.getField("RECV_BUFFER", Fields.FIELD_TYPE_LONG);
@@ -90,11 +89,16 @@
         FIELDS[i] = PacketUtil.getField("SEND_QUEUE", Fields.FIELD_TYPE_LONG);
         FIELDS[i++].setPacketId(++packetId);
 
-        FIELDS[i] = PacketUtil.getField("TXLEVEL", Fields.FIELD_TYPE_VAR_STRING);
+        FIELDS[i] = PacketUtil.getField("TX_ISOLATION_LEVEL", Fields.FIELD_TYPE_VAR_STRING);
         FIELDS[i++].setPacketId(++packetId);
 
-        FIELDS[i] = PacketUtil.getField("AUTOCOMMIT",
-                Fields.FIELD_TYPE_VAR_STRING);
+        FIELDS[i] = PacketUtil.getField("AUTOCOMMIT", Fields.FIELD_TYPE_VAR_STRING);
+        FIELDS[i++].setPacketId(++packetId);
+
+        FIELDS[i] = PacketUtil.getField("SYS_VARIABLES", Fields.FIELD_TYPE_VAR_STRING);
+        FIELDS[i++].setPacketId(++packetId);
+
+        FIELDS[i] = PacketUtil.getField("USER_VARIABLES", Fields.FIELD_TYPE_VAR_STRING);
         FIELDS[i].setPacketId(++packetId);
 
         EOF.setPacketId(++packetId);
@@ -156,15 +160,16 @@
         row.add(IntegerUtil.toBytes(c.getWriteQueue().size()));
 
         String txLevel = "";
-        String txAutommit = "";
+        String autocommit = "";
         if (c instanceof ServerConnection) {
-            ServerConnection mysqlC = (ServerConnection) c;
-            txLevel = mysqlC.getTxIsolation() + "";
-            txAutommit = mysqlC.isAutocommit() + "";
+            ServerConnection serverConn = (ServerConnection) c;
+            txLevel = serverConn.getTxIsolation() + "";
+            autocommit = serverConn.isAutocommit() + "";
         }
         row.add(txLevel.getBytes());
-        row.add(txAutommit.getBytes());
-
+        row.add(autocommit.getBytes());
+        row.add(StringUtil.encode(c.getStringOfSysVariables(), charset));
+        row.add(StringUtil.encode(c.getStringOfUsrVariables(), charset));
         return row;
     }
 
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java	2024-09-08 01:36:10.401782589 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/manager/response/ShowDirectMemory.java	2024-09-08 01:36:10.333782113 +1000
@@ -18,7 +18,6 @@
 import com.actiontech.dble.net.mysql.RowDataPacket;
 import com.actiontech.dble.util.StringUtil;
 
-import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.util.Map;
 import java.util.concurrent.ConcurrentMap;
@@ -176,8 +175,6 @@
         }
         // write eof
         buffer = TOTAL_EOF.write(buffer, c, true);
-        // write rows
-        byte packetId = TOTAL_EOF.getPacketId();
 
         int useOffHeapForMerge = DbleServer.getInstance().getConfig().
                 getSystem().getUseOffHeapForMerge();
@@ -250,7 +247,8 @@
         }
 
         row.add(StringUtil.encode(resevedForOs > 0 ? JavaUtils.bytesToString2(resevedForOs) : "0", c.getCharset().getResults()));
-
+        // write rows
+        byte packetId = TOTAL_EOF.getPacketId();
         row.setPacketId(++packetId);
         buffer = row.write(buffer, c, true);
 
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/AbstractConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/AbstractConnection.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/AbstractConnection.java	2024-09-08 01:36:10.405782618 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/AbstractConnection.java	2024-09-08 01:36:10.333782113 +1000
@@ -5,7 +5,6 @@
 */
 package com.actiontech.dble.net;
 
-import com.actiontech.dble.backend.mysql.CharsetUtil;
 import com.actiontech.dble.net.mysql.CharsetNames;
 import com.actiontech.dble.net.mysql.MySQLPacket;
 import com.actiontech.dble.server.SystemVariables;
@@ -20,6 +19,7 @@
 import java.nio.channels.AsynchronousChannel;
 import java.nio.channels.NetworkChannel;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -58,6 +58,8 @@
     protected volatile boolean isSupportCompress = false;
     protected final ConcurrentLinkedQueue<byte[]> decompressUnfinishedDataQueue = new ConcurrentLinkedQueue<>();
     protected final ConcurrentLinkedQueue<byte[]> compressUnfinishedDataQueue = new ConcurrentLinkedQueue<>();
+    protected volatile Map<String, String> usrVariables;
+    protected volatile Map<String, String> sysVariables;
 
     private long idleTimeout;
 
@@ -83,31 +85,16 @@
         this.isClosed = new AtomicBoolean(false);
         this.socketWR = null;
     }
-    public boolean setCollationConnection(String collation) {
-        int ci = CharsetUtil.getCollationIndex(collation);
-        if (ci <= 0) {
-            return false;
-        }
+    public void setCollationConnection(String collation) {
         charsetName.setCollation(collation);
-        return true;
     }
 
-    public boolean setCharacterConnection(String charset) {
-        String collationName = CharsetUtil.getDefaultCollation(charset);
-        if (collationName == null) {
-            return false;
-        }
+    public void setCharacterConnection(String collationName) {
         charsetName.setCollation(collationName);
-        return true;
     }
 
-    public boolean setCharacterResults(String name) {
-        int ci = CharsetUtil.getCharsetDefaultIndex(name);
-        if (ci <= 0 && !name.equals("null")) {
-            return false;
-        }
+    public void setCharacterResults(String name) {
         charsetName.setResults(name);
-        return true;
     }
 
 
@@ -115,36 +102,17 @@
         this.charsetName = charsetName.clone();
     }
 
-    public boolean setCharacterClient(String name) {
-        int ci = CharsetUtil.getCharsetDefaultIndex(name);
-        if (ci <= 0) {
-            return false;
-        }
+    public void setCharacterClient(String name) {
         charsetName.setClient(name);
-        return true;
     }
 
-    public boolean setCharacterSet(String name) {
-        int ci = CharsetUtil.getCharsetDefaultIndex(name);
-        if (ci <= 0) {
-            return false;
-        }
+    public void setCharacterSet(String name) {
         charsetName.setClient(name);
         charsetName.setResults(name);
         charsetName.setCollation(SystemVariables.getDefaultValue("collation_database"));
-        return true;
     }
 
     public boolean setNames(String name, String collationName) {
-        int ci = CharsetUtil.getCharsetDefaultIndex(name);
-        if (ci <= 0) {
-            return false;
-        }
-        if (collationName == null) {
-            collationName = CharsetUtil.getDefaultCollation(name);
-        } else if (CharsetUtil.getCollationIndex(collationName) <= 0) {
-            return false;
-        }
         charsetName.setNames(name, collationName);
         return true;
     }
@@ -198,6 +166,14 @@
         return TimeUtil.currentTimeMillis() > Math.max(lastWriteTime, lastReadTime) + idleTimeout;
     }
 
+    public Map<String, String> getUsrVariables() {
+        return usrVariables;
+    }
+
+    public Map<String, String> getSysVariables() {
+        return sysVariables;
+    }
+
     public NetworkChannel getChannel() {
         return channel;
     }
@@ -583,6 +559,39 @@
         }
     }
 
+    public String getStringOfSysVariables() {
+        StringBuilder sbSysVariables = new StringBuilder();
+        int cnt = 0;
+        if (sysVariables != null) {
+            for (Map.Entry sysVariable : sysVariables.entrySet()) {
+                if (cnt > 0) {
+                    sbSysVariables.append(",");
+                }
+                sbSysVariables.append(sysVariable.getKey());
+                sbSysVariables.append("=");
+                sbSysVariables.append(sysVariable.getValue());
+                cnt++;
+            }
+        }
+        return sbSysVariables.toString();
+    }
+
+    public String getStringOfUsrVariables() {
+        StringBuilder sbUsrVariables = new StringBuilder();
+        int cnt = 0;
+        if (usrVariables != null) {
+            for (Map.Entry usrVariable : usrVariables.entrySet()) {
+                if (cnt > 0) {
+                    sbUsrVariables.append(",");
+                }
+                sbUsrVariables.append(usrVariable.getKey());
+                sbUsrVariables.append("=");
+                sbUsrVariables.append(usrVariable.getValue());
+                cnt++;
+            }
+        }
+        return sbUsrVariables.toString();
+    }
     public void onConnectfinish() {
         LOGGER.debug("The backend conntinon has finished connecting");
     }
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java	2024-09-08 01:36:10.405782618 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/mysql/OkPacket.java	2024-09-08 01:36:10.337782141 +1000
@@ -32,8 +32,7 @@
  */
 public class OkPacket extends MySQLPacket {
     public static final byte FIELD_COUNT = 0x00;
-    public static final byte[] OK = new byte[]{7, 0, 0, 1, 0, 0, 0, 2, 0, 0,
-            0};
+    public static final byte[] OK = new byte[]{7, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0};
 
     private byte fieldCount = FIELD_COUNT;
     private long affectedRows;
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/net/mysql: ResetConnectionPacket.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java	2024-09-08 01:36:10.413782673 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/route/sequence/handler/FetchMySQLSequnceHandler.java	2024-09-08 01:36:10.345782197 +1000
@@ -82,7 +82,7 @@
 
     @Override
     public void okResponse(byte[] ok, BackendConnection conn) {
-        boolean executeResponse = conn.syncAndExcute();
+        boolean executeResponse = conn.syncAndExecute();
         if (executeResponse) {
             ((SequenceVal) conn.getAttachment()).dbfinished = true;
             conn.release();
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/handler: SetCallBack.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/handler/SetHandler.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/handler/SetHandler.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/handler/SetHandler.java	2024-09-08 01:36:10.413782673 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/handler/SetHandler.java	2024-09-08 01:36:10.345782197 +1000
@@ -11,15 +11,27 @@
 import com.actiontech.dble.config.Isolations;
 import com.actiontech.dble.log.transaction.TxnLogHelper;
 import com.actiontech.dble.net.mysql.OkPacket;
+import com.actiontech.dble.route.parser.util.Pair;
 import com.actiontech.dble.route.parser.util.ParseUtil;
 import com.actiontech.dble.server.ServerConnection;
-import com.actiontech.dble.server.parser.ServerParseSet;
-import com.actiontech.dble.util.SetIgnoreUtil;
+import com.actiontech.dble.server.SystemVariables;
+import com.actiontech.dble.sqlengine.OneRawSQLQueryResultHandler;
+import com.actiontech.dble.sqlengine.SetTestJob;
 import com.actiontech.dble.util.StringUtil;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import static com.actiontech.dble.server.parser.ServerParseSet.*;
+import com.alibaba.druid.sql.ast.SQLExpr;
+import com.alibaba.druid.sql.ast.SQLStatement;
+import com.alibaba.druid.sql.ast.expr.*;
+import com.alibaba.druid.sql.ast.statement.SQLAssignItem;
+import com.alibaba.druid.sql.ast.statement.SQLSetStatement;
+import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetCharSetStatement;
+import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetNamesStatement;
+import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetTransactionStatement;
+import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
+import com.alibaba.druid.sql.parser.SQLStatementParser;
+
+import java.sql.SQLSyntaxErrorException;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
  * SetHandler
@@ -31,259 +43,712 @@
     private SetHandler() {
     }
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(SetHandler.class);
-
     private static final byte[] AC_OFF = new byte[]{7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0};
 
+    public enum KeyType {
+        SYNTAX_ERROR,
+        XA,
+        AUTOCOMMIT,
+        NAMES,
+        CHARSET,
+        CHARACTER_SET_CLIENT,
+        CHARACTER_SET_CONNECTION,
+        CHARACTER_SET_RESULTS,
+        COLLATION_CONNECTION,
+        SYSTEM_VARIABLES,
+        USER_VARIABLES,
+        TX_READ_ONLY,
+        TX_ISOLATION
+    }
+
     public static void handle(String stmt, ServerConnection c, int offset) {
         if (!ParseUtil.isSpace(stmt.charAt(offset))) {
             c.writeErrMessage(ErrorCode.ERR_WRONG_USED, stmt + " is not supported");
         }
-        int rs = ServerParseSet.parse(stmt, offset);
-        switch (rs & 0xff) {
-            case MULTI_SET:
-                //set split with ','
-                if (!parserMultiSet(stmt.substring(offset), c)) {
-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
-                }
-                break;
-            case AUTOCOMMIT_ON:
-                if (c.isAutocommit()) {
-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+        try {
+            String smt = convertCharsetKeyWord(stmt);
+            List<Pair<KeyType, Pair<String, String>>> contextTask = new ArrayList<>();
+            if (handleSetStatement(smt, c, contextTask) && contextTask.size() > 0) {
+                setStmtCallback(stmt, c, contextTask);
+            }
+        } catch (SQLSyntaxErrorException e) {
+            c.writeErrMessage(ErrorCode.ER_PARSE_ERROR, e.toString());
+        }
+    }
+
+    private static SQLStatement parseSQL(String stmt) throws SQLSyntaxErrorException {
+        SQLStatementParser parser = new MySqlStatementParser(stmt);
+        try {
+            return parser.parseStatement();
+        } catch (Exception t) {
+            if (t.getMessage() != null) {
+                throw new SQLSyntaxErrorException(t.getMessage());
+            } else {
+                throw new SQLSyntaxErrorException(t);
+            }
+        }
+    }
+    private static boolean handleSetStatement(String stmt, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) throws SQLSyntaxErrorException {
+        SQLStatement statement = parseSQL(stmt);
+        if (statement instanceof SQLSetStatement) {
+            List<SQLAssignItem> assignItems = ((SQLSetStatement) statement).getItems();
+            if (assignItems.size() == 1 && contextTask.size() == 0) {
+                return handleSingleVariable(stmt, assignItems.get(0), c, contextTask);
+            } else {
+                return handleSetMultiStatement(assignItems, c, contextTask);
+            }
+        } else if (statement instanceof MySqlSetNamesStatement) {
+            MySqlSetNamesStatement setNamesStatement = (MySqlSetNamesStatement) statement;
+            if (contextTask.size() > 0 || stmt.contains(",")) {
+                if (handleSetNamesInMultiStmt(c, setNamesStatement.getCharSet(), setNamesStatement.getCollate(), contextTask)) {
+                    int index = stmt.indexOf(",");
+                    String newStmt = "set " + stmt.substring(index + 1);
+                    return handleSetStatement(newStmt, c, contextTask);
                 } else {
-                    c.commit("commit[because of " + stmt + "]");
-                    c.setAutocommit(true);
+                    return false;
                 }
-                break;
-            case AUTOCOMMIT_OFF: {
-                if (c.isAutocommit()) {
-                    c.setAutocommit(false);
-                    TxnLogHelper.putTxnLog(c, stmt);
-                }
-                c.write(c.writeToBuffer(AC_OFF, c.allocate()));
-                break;
+            } else {
+                return handleSingleSetNames(stmt, c, setNamesStatement);
             }
-            case XA_FLAG_ON: {
-                if (c.isTxstart() && c.getSession2().getSessionXaID() == null) {
-                    c.writeErrMessage(ErrorCode.ERR_WRONG_USED, "set xa cmd on can't used before ending a transaction");
-                    return;
+        } else if (statement instanceof MySqlSetCharSetStatement) {
+            MySqlSetCharSetStatement setCharSetStatement = (MySqlSetCharSetStatement) statement;
+            if (contextTask.size() > 0 || stmt.contains(",")) {
+                if (handleCharsetInMultiStmt(c, setCharSetStatement.getCharSet(), contextTask)) {
+                    int index = stmt.indexOf(",");
+                    String newStmt = "set " + stmt.substring(index + 1);
+                    return handleSetStatement(newStmt, c, contextTask);
+                } else {
+                    return false;
                 }
-                c.getSession2().setXaTxEnabled(true);
-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
-                break;
+            } else {
+                return handleSingleSetCharset(stmt, c, setCharSetStatement);
             }
-            case XA_FLAG_OFF: {
-                if (c.isTxstart() && c.getSession2().getSessionXaID() != null) {
-                    c.writeErrMessage(ErrorCode.ERR_WRONG_USED, "set xa cmd off can't used before ending a transaction");
-                    return;
-                }
-                c.getSession2().setXaTxEnabled(false);
-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
-                return;
+        } else if (statement instanceof MySqlSetTransactionStatement) {
+            return handleTransaction(c, (MySqlSetTransactionStatement) statement);
+        } else {
+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, stmt + " is not recognized and ignored");
+            return false;
+        }
+    }
+
+    private static boolean handleSetNamesInMultiStmt(ServerConnection c, String charset, String collate, List<Pair<KeyType, Pair<String, String>>> contextTask) {
+        String[] charsetInfo = checkSetNames(charset, collate);
+        if (charsetInfo != null) {
+            contextTask.add(new Pair<>(KeyType.NAMES, new Pair<>(charsetInfo[0], charsetInfo[1])));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set  '" + charset + " or collate '" + collate + "'");
+            return false;
+        }
+    }
+
+    private static boolean handleSingleSetNames(String stmt, ServerConnection c, MySqlSetNamesStatement statement) {
+        String[] charsetInfo = checkSetNames(statement.getCharSet(), statement.getCollate());
+        if (charsetInfo != null) {
+            c.setNames(charsetInfo[0], charsetInfo[1]);
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set in statement '" + stmt + "");
+            return false;
+        }
+    }
+
+    private static boolean handleSingleSetCharset(String stmt, ServerConnection c, MySqlSetCharSetStatement statement) {
+        String charset = getCharset(statement.getCharSet());
+        if (charset != null) {
+            c.setCharacterSet(charset);
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set in statement '" + stmt + "");
+            return false;
+        }
+    }
+
+    private static boolean handleSetMultiStatement(List<SQLAssignItem> assignItems, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {
+        for (SQLAssignItem assignItem : assignItems) {
+            if (!handleVariableInMultiStmt(assignItem, c, contextTask)) {
+                return false;
             }
-            case TX_READ_UNCOMMITTED: {
-                c.setTxIsolation(Isolations.READ_UNCOMMITTED);
-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+        }
+        return true;
+    }
+
+    //execute multiStmt and callback to reset conn
+    private static void setStmtCallback(String multiStmt, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {
+        c.setContextTask(contextTask);
+        OneRawSQLQueryResultHandler resultHandler = new OneRawSQLQueryResultHandler(new String[0], new SetCallBack(c));
+        SetTestJob sqlJob = new SetTestJob(multiStmt, resultHandler, c);
+        sqlJob.run();
+    }
+
+    private static boolean handleVariableInMultiStmt(SQLAssignItem assignItem, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {
+        String key = handleSetKey(assignItem, c);
+        if (key == null) {
+            return false;
+        }
+        SQLExpr valueExpr = assignItem.getValue();
+        if (!checkValue(valueExpr)) {
+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "setting target is not supported for '" + assignItem.getValue() + "'");
+            return false;
+        }
+        KeyType keyType = parseKeyType(key, true, KeyType.SYSTEM_VARIABLES);
+        switch (keyType) {
+            case XA:
+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, "set xa cmd can't used in multi-set statement");
+                return false;
+            case AUTOCOMMIT:
+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, "set autocommit cmd can't used in multi-set statement");
+                return false;
+            case NAMES: {
+                String charset = parseStringValue(valueExpr);
+                //TODO:druid lost collation info
+                if (!handleSetNamesInMultiStmt(c, charset, null, contextTask)) return false;
                 break;
             }
-            case TX_READ_COMMITTED: {
-                c.setTxIsolation(Isolations.READ_COMMITTED);
-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            case CHARSET: {
+                String charset = parseStringValue(valueExpr);
+                if (!handleCharsetInMultiStmt(c, charset, contextTask)) return false;
                 break;
             }
-            case TX_REPEATED_READ: {
-                c.setTxIsolation(Isolations.REPEATED_READ);
-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            case CHARACTER_SET_CLIENT:
+                if (!handleCharsetClientInMultiStmt(c, contextTask, valueExpr)) return false;
                 break;
-            }
-            case TX_SERIALIZABLE: {
-                c.setTxIsolation(Isolations.SERIALIZABLE);
-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            case CHARACTER_SET_CONNECTION:
+                if (!handleCharsetConnInMultiStmt(c, contextTask, valueExpr)) return false;
                 break;
-            }
-            case TX_READ_WRITE:
-                c.setSessionReadOnly(false);
-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            case CHARACTER_SET_RESULTS:
+                if (!handleCharsetResultsInMultiStmt(c, contextTask, valueExpr)) return false;
+                break;
+            case COLLATION_CONNECTION:
+                if (!handleCollationConnInMultiStmt(c, contextTask, valueExpr)) return false;
                 break;
             case TX_READ_ONLY:
-                c.setSessionReadOnly(true);
-                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+                if (!handleReadOnlyInMultiStmt(c, contextTask, valueExpr)) return false;
                 break;
-            case NAMES: {
-                String names = stmt.substring(rs >>> 8).trim();
-                if (handleSetNames(names, c)) {
-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
-                } else {
-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set" + names + "");
-                }
+            case TX_ISOLATION:
+                if (!handleTxIsolationInMultiStmt(c, contextTask, valueExpr)) return false;
                 break;
-            }
-            case CHARACTER_SET_CLIENT:
-                String charsetClient = stmt.substring(rs >>> 8).trim().toLowerCase();
-                if (charsetClient.equals("null")) {
-                    c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, "Variable 'character_set_client' can't be set to the value of 'NULL'");
-                }
-                if (handleCharSetClient(charsetClient, c)) {
-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
-                } else {
-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set " + charsetClient + "");
+            case SYSTEM_VARIABLES:
+                if (SystemVariables.getDefaultValue(key) == null) {
+                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "system variable " + key + " is not supported");
                 }
+                contextTask.add(new Pair<>(KeyType.SYSTEM_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));
                 break;
-            case CHARACTER_SET_CONNECTION:
-                String charsetConnection = stmt.substring(rs >>> 8).trim().toLowerCase();
-                if (charsetConnection.equals("null")) {
-                    c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, "Variable 'character_set_connection' can't be set to the value of 'NULL'");
-                }
-                if (handleCharSetConnection(charsetConnection, c)) {
-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
-                } else {
-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set " + charsetConnection + "");
-                }
+            case USER_VARIABLES:
+                contextTask.add(new Pair<>(KeyType.USER_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));
                 break;
+            default:
+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, key + " is not supported");
+                return false;
+        }
+        return true;
+    }
+
+    private static boolean handleCharsetInMultiStmt(ServerConnection c, String charset, List<Pair<KeyType, Pair<String, String>>> contextTask) {
+        String charsetInfo = getCharset(charset);
+        if (charsetInfo != null) {
+            contextTask.add(new Pair<>(KeyType.CHARSET, new Pair<String, String>(charsetInfo, null)));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set '" + charset + "'");
+            return false;
+        }
+    }
+
+    private static boolean handleTxIsolationInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {
+        String value = parseStringValue(valueExpr);
+        Integer txIsolation = getIsolationLevel(value);
+        if (txIsolation == null) {
+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "Variable 'tx_isolation' can't be set to the value of '" + value + "'");
+            return false;
+        }
+        contextTask.add(new Pair<>(KeyType.TX_ISOLATION, new Pair<String, String>(String.valueOf(txIsolation), null)));
+        return true;
+    }
+
+    private static boolean handleReadOnlyInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {
+        Boolean switchStatus = isSwitchOn(valueExpr);
+        if (switchStatus == null) {
+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, "Incorrect argument type to variable 'tx_read_only|transaction_read_only'");
+            return false;
+        } else if (switchStatus) {
+            contextTask.add(new Pair<>(KeyType.TX_READ_ONLY, new Pair<String, String>("true", null)));
+        } else {
+            contextTask.add(new Pair<>(KeyType.TX_READ_ONLY, new Pair<String, String>("false", null)));
+        }
+        return true;
+    }
+
+    private static boolean handleCollationConnInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {
+        String collation = parseStringValue(valueExpr);
+        if (checkCollation(collation)) {
+            contextTask.add(new Pair<>(KeyType.COLLATION_CONNECTION, new Pair<String, String>(collation, null)));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_COLLATION, "Unknown collation '" + collation + "'");
+            return false;
+        }
+    }
+
+    private static boolean handleCharsetResultsInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {
+        String charsetResult = parseStringValue(valueExpr);
+        if (charsetResult.equals("null") || checkCharset(charsetResult)) {
+            contextTask.add(new Pair<>(KeyType.CHARACTER_SET_RESULTS, new Pair<String, String>(charsetResult, null)));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set '" + charsetResult + "'");
+            return false;
+        }
+    }
+
+    private static boolean handleCharsetConnInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {
+        String charsetConnection = parseStringValue(valueExpr);
+        if (charsetConnection.equals("null")) {
+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, "Variable 'character_set_connection' can't be set to the value of 'NULL'");
+            return false;
+        }
+        String collationName = CharsetUtil.getDefaultCollation(charsetConnection);
+        if (collationName != null) {
+            contextTask.add(new Pair<>(KeyType.CHARACTER_SET_CONNECTION, new Pair<String, String>(collationName, null)));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set '" + charsetConnection + "'");
+            return false;
+        }
+    }
+
+    private static boolean handleCharsetClientInMultiStmt(ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask, SQLExpr valueExpr) {
+        String charsetClient = parseStringValue(valueExpr);
+        if (charsetClient.equals("null")) {
+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, "Variable 'character_set_client' can't be set to the value of 'NULL'");
+            return false;
+        }
+        if (checkCharset(charsetClient)) {
+            contextTask.add(new Pair<>(KeyType.CHARACTER_SET_CLIENT, new Pair<String, String>(charsetClient, null)));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set '" + charsetClient + "'");
+            return false;
+        }
+    }
+
+    private static boolean handleSingleVariable(String stmt, SQLAssignItem assignItem, ServerConnection c, List<Pair<KeyType, Pair<String, String>>> contextTask) {
+        String key = handleSetKey(assignItem, c);
+        if (key == null) return false;
+        SQLExpr valueExpr = assignItem.getValue();
+        if (!checkValue(valueExpr)) {
+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "setting target is not supported for '" + assignItem.getValue() + "'");
+            return false;
+        }
+        KeyType keyType = parseKeyType(key, true, KeyType.SYSTEM_VARIABLES);
+        switch (keyType) {
+            case XA:
+                return handleSingleXA(c, valueExpr);
+            case AUTOCOMMIT:
+                return handleSingleAutocommit(stmt, c, valueExpr);
+            case CHARACTER_SET_CLIENT:
+                return handleSingleCharsetClient(c, valueExpr);
+            case CHARACTER_SET_CONNECTION:
+                return handleSingleCharsetConnection(c, valueExpr);
             case CHARACTER_SET_RESULTS:
-                String charsetResult = stmt.substring(rs >>> 8).trim();
-                if (handleCharSetResults(charsetResult, c)) {
-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
-                } else {
-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set " + charsetResult + "");
-                }
-                break;
-            case CHARACTER_SET_NAME: {
-                String charset = stmt.substring(rs >>> 8).trim();
-                if (handleCharSetName(charset, c)) {
-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
-                } else {
-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set " + charset + "");
+                return handleSingleCharsetResults(c, valueExpr);
+            case COLLATION_CONNECTION:
+                return handleCollationConnection(c, valueExpr);
+            case TX_READ_ONLY:
+                return handleTxReadOnly(c, valueExpr);
+            case TX_ISOLATION:
+                return handleTxIsolation(c, valueExpr);
+            case SYSTEM_VARIABLES:
+                if (SystemVariables.getDefaultValue(key) == null) {
+                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "system variable " + key + " is not supported");
+                    return false;
                 }
-                break;
+                contextTask.add(new Pair<>(KeyType.SYSTEM_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));
+                return true;
+            case USER_VARIABLES:
+                contextTask.add(new Pair<>(KeyType.USER_VARIABLES, new Pair<>(key, parseVariablesValue(valueExpr))));
+                return true;
+            default:
+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, stmt + " is not supported");
+                return false;
+        }
+    }
+
+    private static boolean handleTxReadOnly(ServerConnection c, SQLExpr valueExpr) {
+        Boolean switchStatus = isSwitchOn(valueExpr);
+        if (switchStatus == null) {
+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, "Incorrect argument type to variable 'tx_read_only|transaction_read_only'");
+            return false;
+        } else if (switchStatus) {
+            c.setSessionReadOnly(true);
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+        } else {
+            c.setSessionReadOnly(false);
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+        }
+        return true;
+    }
+
+    private static boolean handleTxIsolation(ServerConnection c, SQLExpr valueExpr) {
+        String value = parseStringValue(valueExpr);
+        Integer txIsolation = getIsolationLevel(value);
+        if (txIsolation == null) {
+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "Variable 'tx_isolation' can't be set to the value of '" + value + "'");
+            return false;
+        }
+        c.setTxIsolation(txIsolation);
+        c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+        return true;
+    }
+
+    private static Integer getIsolationLevel(String value) {
+        switch (value) {
+            case "read-uncommitted":
+                return Isolations.READ_UNCOMMITTED;
+            case "read-committed":
+                return Isolations.READ_COMMITTED;
+            case "repeatable-read":
+                return Isolations.REPEATED_READ;
+            case "serializable":
+                return Isolations.SERIALIZABLE;
+            default:
+                return null;
+        }
+    }
+
+    private static boolean handleCollationConnection(ServerConnection c, SQLExpr valueExpr) {
+        String collation = parseStringValue(valueExpr);
+        if (checkCollation(collation)) {
+            c.setCollationConnection(collation);
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_COLLATION, "Unknown collation '" + collation + "'");
+            return false;
+        }
+    }
+
+    private static boolean handleSingleCharsetResults(ServerConnection c, SQLExpr valueExpr) {
+        String charsetResult = parseStringValue(valueExpr);
+        if (charsetResult.equals("null") || checkCharset(charsetResult)) {
+            c.setCharacterResults(charsetResult);
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set '" + charsetResult + "'");
+            return false;
+        }
+    }
+
+    private static boolean handleSingleCharsetConnection(ServerConnection c, SQLExpr valueExpr) {
+        String charsetConnection = parseStringValue(valueExpr);
+        if (charsetConnection.equals("null")) {
+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, "Variable 'character_set_connection' can't be set to the value of 'NULL'");
+            return false;
+        }
+        String collationName = CharsetUtil.getDefaultCollation(charsetConnection);
+        if (collationName != null) {
+            c.setCharacterConnection(collationName);
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set '" + charsetConnection + "'");
+            return false;
+        }
+    }
+
+    private static boolean handleSingleCharsetClient(ServerConnection c, SQLExpr valueExpr) {
+        String charsetClient = parseStringValue(valueExpr);
+        if (charsetClient.equals("null")) {
+            c.writeErrMessage(ErrorCode.ER_WRONG_VALUE_FOR_VAR, "Variable 'character_set_client' can't be set to the value of 'NULL'");
+            return false;
+        }
+        if (checkCharset(charsetClient)) {
+            c.setCharacterClient(charsetClient);
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            return true;
+        } else {
+            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set '" + charsetClient + "'");
+            return false;
+        }
+    }
+
+    private static boolean handleSingleAutocommit(String stmt, ServerConnection c, SQLExpr valueExpr) {
+        Boolean switchStatus = isSwitchOn(valueExpr);
+        if (switchStatus == null) {
+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, "Incorrect argument type to variable 'AUTOCOMMIT'");
+            return false;
+        } else if (switchStatus) {
+            if (c.isAutocommit()) {
+                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            } else {
+                c.commit("commit[because of " + stmt + "]");
+                c.setAutocommit(true);
+            }
+        } else {
+            if (c.isAutocommit()) {
+                c.setAutocommit(false);
+                TxnLogHelper.putTxnLog(c, stmt);
             }
-            case COLLATION_CONNECTION: {
-                String collation = stmt.substring(rs >>> 8).trim();
-                if (handleCollationConn(collation, c)) {
-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
-                } else {
-                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_COLLATION, "Unknown collation " + collation + "");
-                }
-                break;
+            c.write(c.writeToBuffer(AC_OFF, c.allocate()));
+        }
+        return true;
+    }
+
+    private static boolean handleSingleXA(ServerConnection c, SQLExpr valueExpr) {
+        Boolean switchStatus = isSwitchOn(valueExpr);
+        if (switchStatus == null) {
+            c.writeErrMessage(ErrorCode.ER_WRONG_TYPE_FOR_VAR, "Incorrect argument type to variable 'XA'");
+            return false;
+        } else if (switchStatus) {
+            if (c.isTxstart() && c.getSession2().getSessionXaID() == null) {
+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, "set xa cmd on can't used before ending a transaction");
+                return false;
+            }
+            c.getSession2().setXaTxEnabled(true);
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            return true;
+        } else {
+            if (c.isTxstart() && c.getSession2().getSessionXaID() != null) {
+                c.writeErrMessage(ErrorCode.ERR_WRONG_USED, "set xa cmd off can't used before ending a transaction");
+                return false;
+            }
+            c.getSession2().setXaTxEnabled(false);
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            return true;
+        }
+    }
+
+    // druid not support 'set charset' ,change to 'set character set'
+    private static String convertCharsetKeyWord(String stmt) {
+        StringBuilder result = new StringBuilder();
+        String toCheck = stmt.toLowerCase();
+        int index = toCheck.indexOf("charset");
+        int tailStart = 0;
+        while (index > 0) {
+            char before = toCheck.charAt(index - 1);
+            char after = toCheck.charAt(index + 7);
+            if ((ParseUtil.isSpace(before) || ',' == before) && ParseUtil.isSpace(after)) {
+                result.append(stmt.substring(tailStart, index));
+                result.append("character set");
+            }
+            tailStart = index + 7;
+            index = toCheck.indexOf("charset", tailStart);
+        }
+        if (result.length() > 0) {
+            result.append(stmt.substring(tailStart));
+            return result.toString();
+        }
+        return stmt;
+    }
+
+    private static String handleSetKey(SQLAssignItem assignItem, ServerConnection c) {
+        if (assignItem.getTarget() instanceof SQLPropertyExpr) {
+            SQLPropertyExpr target = (SQLPropertyExpr) assignItem.getTarget();
+            if (!(target.getOwner() instanceof SQLVariantRefExpr)) {
+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "setting target is not supported for '" + target + "'");
+                return null;
             }
-            case GLOBAL:
+            SQLVariantRefExpr owner = (SQLVariantRefExpr) target.getOwner();
+            if (owner.isGlobal()) {
                 c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "setting GLOBAL value is not supported");
-                break;
+                return null;
+            }
+            return target.getName();
+        } else if (assignItem.getTarget() instanceof SQLVariantRefExpr) {
+            SQLVariantRefExpr target = (SQLVariantRefExpr) assignItem.getTarget();
+            if (target.isGlobal()) {
+                c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "setting GLOBAL value is not supported");
+                return null;
+            }
+            return target.getName();
+        } else if (assignItem.getTarget() instanceof SQLIdentifierExpr) {
+            SQLIdentifierExpr target = (SQLIdentifierExpr) assignItem.getTarget();
+            return target.getLowerName();
+        } else {
+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "setting target is not supported for '" + assignItem.getTarget() + "'");
+            return null;
+        }
+    }
+
+    private static boolean checkValue(SQLExpr valueExpr) {
+        return (valueExpr instanceof SQLCharExpr) || (valueExpr instanceof SQLIdentifierExpr) ||
+                (valueExpr instanceof SQLIntegerExpr);
+    }
+
+    private static KeyType parseKeyType(String key, boolean origin, KeyType defaultVariables) {
+        switch (key.toLowerCase()) {
+            case "xa":
+                return KeyType.XA;
+            case "autocommit":
+                return KeyType.AUTOCOMMIT;
+            case "collation_connection":
+                return KeyType.COLLATION_CONNECTION;
+            case "character_set_client":
+                return KeyType.CHARACTER_SET_CLIENT;
+            case "character_set_results":
+                return KeyType.CHARACTER_SET_RESULTS;
+            case "character_set_connection":
+                return KeyType.CHARACTER_SET_CONNECTION;
+            case "transaction_isolation":
+            case "tx_isolation":
+                return KeyType.TX_ISOLATION;
+            case "transaction_read_only":
+            case "tx_read_only":
+                return KeyType.TX_READ_ONLY;
+            case "names":
+                return KeyType.NAMES;
+            case "character set":
+                return KeyType.CHARSET;
             default:
-                boolean ignore = SetIgnoreUtil.isIgnoreStmt(stmt);
-                if (!ignore) {
-                    StringBuilder s = new StringBuilder();
-                    String warn = stmt + " is not recognized and ignored";
-                    LOGGER.warn(s.append(c).append(warn).toString());
-                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, warn);
+                if (!origin && key.startsWith("@")) {
+                    return KeyType.SYNTAX_ERROR;
+                } else if (key.startsWith("@@")) {
+                    return parseKeyType(key.substring(2), false, KeyType.SYSTEM_VARIABLES);
+                } else if (key.startsWith("@")) {
+                    return parseKeyType(key.substring(1), false, KeyType.USER_VARIABLES);
                 } else {
-                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+                    return defaultVariables;
                 }
         }
     }
 
-    //TODO:
-    private static boolean parserMultiSet(String setSQL, ServerConnection c) {
-        String[] setStatements = setSQL.split(",");
-        for (String statement : setStatements) {
-            boolean setError = false;
-            int rs = ServerParseSet.parse(statement, 0);
-            switch (rs & 0xff) {
-                case AUTOCOMMIT_ON:
+    private static Boolean isSwitchOn(SQLExpr valueExpr) {
+        if (valueExpr instanceof SQLIntegerExpr) {
+            SQLIntegerExpr value = (SQLIntegerExpr) valueExpr;
+            int iValue = value.getNumber().intValue();
+            if (iValue < 0 || iValue > 1) {
+                return null;
+            }
+            return (iValue == 1);
+        }
+        String strValue = parseStringValue(valueExpr);
+        switch (strValue) {
+            case "on":
+                return true;
+            case "off":
+                return false;
+            default:
+                return null;
+        }
+    }
 
-                    break;
-                case AUTOCOMMIT_OFF: {
-                    break;
-                }
-                case XA_FLAG_ON: {
+    private static String parseVariablesValue(SQLExpr valueExpr) {
+        String strValue = "";
+        if (valueExpr instanceof SQLIdentifierExpr) {
+            SQLIdentifierExpr value = (SQLIdentifierExpr) valueExpr;
+            strValue = "'" + StringUtil.removeBackQuote(value.getSimpleName().toLowerCase()) + "'";
+        } else if (valueExpr instanceof SQLCharExpr) {
+            SQLCharExpr value = (SQLCharExpr) valueExpr;
+            strValue = "'" + value.getText().toLowerCase() + "'";
+        } else if (valueExpr instanceof SQLIntegerExpr) {
+            SQLIntegerExpr value = (SQLIntegerExpr) valueExpr;
+            strValue = value.getNumber().toString();
+        }
+        return strValue;
+    }
 
-                    break;
-                }
-                case XA_FLAG_OFF: {
+    private static String parseStringValue(SQLExpr valueExpr) {
+        String strValue = "";
+        if (valueExpr instanceof SQLIdentifierExpr) {
+            SQLIdentifierExpr value = (SQLIdentifierExpr) valueExpr;
+            strValue = StringUtil.removeBackQuote(value.getSimpleName().toLowerCase());
+        } else if (valueExpr instanceof SQLCharExpr) {
+            SQLCharExpr value = (SQLCharExpr) valueExpr;
+            strValue = value.getText().toLowerCase();
+        } else if (valueExpr instanceof SQLIntegerExpr) {
+            SQLIntegerExpr value = (SQLIntegerExpr) valueExpr;
+            strValue = value.getNumber().toString();
+        }
+        return strValue;
+    }
 
+
+    private static boolean handleTransaction(ServerConnection c, MySqlSetTransactionStatement setStatement) {
+        //always single
+        if (setStatement.getGlobal() == null) {
+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "setting transaction without any SESSION or GLOBAL keyword is not supported now");
+            return false;
+        } else if (setStatement.getGlobal()) {
+            c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "setting GLOBAL value is not supported");
+            return false;
+        } else if (setStatement.getAccessModel() != null) {
+            if (setStatement.getAccessModel().equals("ONLY")) {
+                c.setSessionReadOnly(true);
+            } else {
+                c.setSessionReadOnly(false);
+            }
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            return true;
+        } else {
+            int txIsolation = Isolations.REPEATED_READ;
+            switch (setStatement.getIsolationLevel()) {
+                case "READ UNCOMMITTED":
+                    txIsolation = Isolations.READ_UNCOMMITTED;
                     break;
-                }
-                case NAMES: {
-                    String names = statement.substring(rs >>> 8).trim();
-                    if (!handleSetNames(names, c)) {
-                        setError = true;
-                        c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set " + names + "");
-                    }
-                    break;
-                }
-                case CHARACTER_SET_CLIENT:
-                case CHARACTER_SET_CONNECTION:
-                case CHARACTER_SET_RESULTS:
-                    //TODO:
-                    break;
-                case CHARACTER_SET_NAME: {
-                    String charset = statement.substring(rs >>> 8).trim();
-                    if (!handleCharSetName(charset, c)) {
-                        setError = true;
-                        c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown character set " + charset + "");
-                    }
+                case "READ COMMITTED":
+                    txIsolation = Isolations.READ_COMMITTED;
                     break;
-                }
-                case GLOBAL:
-                    c.writeErrMessage(ErrorCode.ERR_NOT_SUPPORTED, "setting GLOBAL value is not supported");
+                case "REPEATABLE READ":
+                    txIsolation = Isolations.REPEATED_READ;
                     break;
-                case TX_READ_UNCOMMITTED:
-                case TX_READ_COMMITTED:
-                case TX_REPEATED_READ:
-                case TX_SERIALIZABLE: {
+                case "SERIALIZABLE":
+                    txIsolation = Isolations.SERIALIZABLE;
                     break;
-                }
                 default:
-                    //TODO
-            }
-            if (setError) {
-                return true;
+                    // can't be happened
+                    break;
             }
+            c.setTxIsolation(txIsolation);
+            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
+            return true;
         }
-        return false;
-    }
-    private static boolean handleCollationConn(String collation, ServerConnection c) {
-        collation = StringUtil.removeApostropheOrBackQuote(collation);
-        return c.setCollationConnection(collation);
-    }
-    private static boolean handleCharSetConnection(String charset, ServerConnection c) {
-        charset = StringUtil.removeApostropheOrBackQuote(charset);
-        return c.setCharacterConnection(charset);
     }
-    private static boolean handleCharSetResults(String charset, ServerConnection c) {
-        charset = StringUtil.removeApostropheOrBackQuote(charset);
-        return c.setCharacterResults(charset);
+
+    private static boolean checkCollation(String collation) {
+        int ci = CharsetUtil.getCollationIndex(collation);
+        return ci > 0;
     }
-    private static boolean handleCharSetClient(String charset, ServerConnection c) {
-        charset = StringUtil.removeApostropheOrBackQuote(charset);
-        return c.setCharacterClient(charset);
+
+    private static boolean checkCharset(String name) {
+        int ci = CharsetUtil.getCharsetDefaultIndex(name);
+        return ci > 0;
     }
-    private static boolean handleCharSetName(String charset, ServerConnection c) {
+
+    private static String getCharset(String charset) {
         charset = charset.toLowerCase();
         if (charset.equals("default")) {
             charset = DbleServer.getInstance().getConfig().getSystem().getCharset();
         }
         charset = StringUtil.removeApostropheOrBackQuote(charset);
-        return c.setCharacterSet(charset);
+        if (checkCharset(charset)) {
+            return charset;
+        }
+        return null;
     }
 
-    private static boolean handleSetNames(String names, ServerConnection c) {
-        String charset = names.toLowerCase();
-        int collateIndex = charset.indexOf("collate");
-        String collate = null;
-        if (collateIndex > 0) {
-            charset = names.substring(0, collateIndex).trim();
-            collate = names.substring(collateIndex + 7).trim();
-            if (collate.toLowerCase().equals("default")) {
-                String defaultCharset = DbleServer.getInstance().getConfig().getSystem().getCharset();
-                collate = CharsetUtil.getDefaultCollation(defaultCharset);
-            }
-        }
+    private static String[] checkSetNames(String charset, String collate) {
+        charset = charset.toLowerCase();
         if (charset.equals("default")) {
             charset = DbleServer.getInstance().getConfig().getSystem().getCharset();
+        } else {
+            charset = StringUtil.removeApostropheOrBackQuote(charset);
+            if (!checkCharset(charset)) {
+                return null;
+            }
         }
-        charset = StringUtil.removeApostropheOrBackQuote(charset);
-        return c.setNames(charset, collate);
-
+        if (collate == null) {
+            collate = CharsetUtil.getDefaultCollation(charset);
+        } else {
+            collate = collate.toLowerCase();
+            if (collate.equals("default")) {
+                collate = CharsetUtil.getDefaultCollation(charset);
+            } else if (CharsetUtil.getCollationIndex(collate) <= 0) {
+                return null;
+            }
+        }
+        return new String[]{charset, collate};
     }
 }
Only in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/parser: ServerParseSet.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/ServerConnection.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/ServerConnection.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/server/ServerConnection.java	2024-09-08 01:36:10.413782673 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/server/ServerConnection.java	2024-09-08 01:36:10.345782197 +1000
@@ -16,7 +16,9 @@
 import com.actiontech.dble.log.transaction.TxnLogHelper;
 import com.actiontech.dble.net.FrontendConnection;
 import com.actiontech.dble.route.RouteResultset;
+import com.actiontech.dble.route.parser.util.Pair;
 import com.actiontech.dble.route.util.RouterUtil;
+import com.actiontech.dble.server.handler.SetHandler;
 import com.actiontech.dble.server.parser.ServerParse;
 import com.actiontech.dble.server.response.Heartbeat;
 import com.actiontech.dble.server.response.Ping;
@@ -31,6 +33,9 @@
 import java.nio.channels.NetworkChannel;
 import java.sql.SQLException;
 import java.sql.SQLNonTransientException;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.LockSupport;
@@ -53,11 +58,12 @@
     private NonBlockingSession session;
     private volatile boolean isLocked = false;
     private AtomicLong txID;
-
+    private List<Pair<SetHandler.KeyType, Pair<String, String>>> contextTask = new ArrayList<>();
     public long getAndIncrementXid() {
         return txID.getAndIncrement();
     }
 
+
     public long getXid() {
         return txID.get();
     }
@@ -68,6 +74,8 @@
         this.txInterrupted = false;
         this.autocommit = true;
         this.txID = new AtomicLong(1);
+        this.usrVariables = new LinkedHashMap<>();
+        this.sysVariables = new LinkedHashMap<>();
     }
 
     public ServerConnection() {
@@ -131,7 +139,7 @@
         return session;
     }
 
-    public void setSession2(NonBlockingSession session2) {
+    void setSession2(NonBlockingSession session2) {
         this.session = session2;
     }
 
@@ -139,10 +147,64 @@
         return isLocked;
     }
 
-    public void setLocked(boolean locked) {
+    void setLocked(boolean locked) {
         this.isLocked = locked;
     }
 
+
+    public List<Pair<SetHandler.KeyType, Pair<String, String>>> getContextTask() {
+        return contextTask;
+    }
+
+    public void setContextTask(List<Pair<SetHandler.KeyType, Pair<String, String>>> contextTask) {
+        this.contextTask = contextTask;
+    }
+
+    public void executeTask() {
+        for (Pair<SetHandler.KeyType, Pair<String, String>> task : contextTask) {
+            switch (task.getKey()) {
+                case CHARACTER_SET_CLIENT:
+                    String charsetClient = task.getValue().getKey();
+                    this.setCharacterClient(charsetClient);
+                    break;
+                case CHARACTER_SET_CONNECTION:
+                    String collationName = task.getValue().getKey();
+                    this.setCharacterConnection(collationName);
+                    break;
+                case CHARACTER_SET_RESULTS:
+                    String charsetResult = task.getValue().getKey();
+                    this.setCharacterResults(charsetResult);
+                    break;
+                case COLLATION_CONNECTION:
+                    String collation = task.getValue().getKey();
+                    this.setCollationConnection(collation);
+                    break;
+                case TX_ISOLATION:
+                    String isolationLevel = task.getValue().getKey();
+                    this.setTxIsolation(Integer.parseInt(isolationLevel));
+                    break;
+                case TX_READ_ONLY:
+                    String enable = task.getValue().getKey();
+                    this.setSessionReadOnly(Boolean.parseBoolean(enable));
+                    break;
+                case SYSTEM_VARIABLES:
+                    this.sysVariables.put(task.getValue().getKey(), task.getValue().getValue());
+                    break;
+                case USER_VARIABLES:
+                    this.usrVariables.put(task.getValue().getKey(), task.getValue().getValue());
+                    break;
+                case CHARSET:
+                    this.setCharacterSet(task.getValue().getKey());
+                    break;
+                case NAMES:
+                    this.setNames(task.getValue().getKey(), task.getValue().getValue());
+                    break;
+                default:
+                    //can't happen
+                    break;
+            }
+        }
+    }
     @Override
     public void ping() {
         Ping.response(this);
@@ -319,10 +381,7 @@
         session.rollback();
     }
 
-    /**
-     * @param sql
-     */
-    public void lockTable(String sql) {
+    void lockTable(String sql) {
         // lock table is disable in transaction
         if (!autocommit) {
             writeErrMessage(ErrorCode.ER_YES, "can't lock table in transaction!");
@@ -339,10 +398,7 @@
         }
     }
 
-    /**
-     * @param sql
-     */
-    public void unLockTable(String sql) {
+    void unLockTable(String sql) {
         sql = sql.replaceAll("\n", " ").replaceAll("\t", " ");
         String[] words = SplitUtil.split(sql, ' ', true);
         if (words.length == 2 && ("table".equalsIgnoreCase(words[1]) || "tables".equalsIgnoreCase(words[1]))) {
@@ -395,9 +451,31 @@
 
     @Override
     public String toString() {
-        return "ServerConnection [id=" + id + ", schema=" + schema + ", host=" + host +
-                ", user=" + user + ",txIsolation=" + txIsolation + ", autocommit=" + autocommit +
-                ", schema=" + schema + "]";
+        StringBuilder result = new StringBuilder();
+        result.append("ServerConnection [id=");
+        result.append(id);
+        result.append(", schema=");
+        result.append(schema);
+        result.append(", host=");
+        result.append(host);
+        result.append(", user=");
+        result.append(user);
+        result.append(",txIsolation=");
+        result.append(txIsolation);
+        result.append(", autocommit=");
+        result.append(autocommit);
+        result.append(", schema=");
+        result.append(schema);
+        if (sysVariables.size() > 0) {
+            result.append(", ");
+            result.append(getStringOfSysVariables());
+        }
+        if (usrVariables.size() > 0) {
+            result.append(", ");
+            result.append(getStringOfUsrVariables());
+        }
+        result.append("]");
+        return result.toString();
     }
 
 }
Only in ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/sqlengine: SetTestJob.java
diff -r -u ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java
--- ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java	2024-09-08 01:36:10.417782701 +1000
+++ ./RegMiner4APR-Regression-Bugs/BIC/src/main/java/com/actiontech/dble/sqlengine/SQLJob.java	2024-09-08 01:36:10.349782225 +1000
@@ -36,14 +36,12 @@
     private BackendConnection connection;
     private final SQLJobHandler jobHandler;
     private final PhysicalDatasource ds;
-    private final int id;
     private volatile boolean finished;
 
 
     public SQLJob(String sql, String databaseName, SQLJobHandler jobHandler,
                   PhysicalDatasource ds) {
         super();
-        this.id = 0;
         this.sql = sql;
         this.dataNodeOrDatabase = databaseName;
         this.jobHandler = jobHandler;
@@ -132,7 +130,7 @@
 
     @Override
     public void okResponse(byte[] ok, BackendConnection conn) {
-        if (conn.syncAndExcute()) {
+        if (conn.syncAndExecute()) {
             conn.release();
             doFinished(false);
         }
@@ -170,14 +168,9 @@
     public void connectionClose(BackendConnection conn, String reason) {
         doFinished(true);
     }
-
-    public int getId() {
-        return id;
-    }
-
     @Override
     public String toString() {
-        return "SQLJob [ id=" + id + ",dataNodeOrDatabase=" +
+        return "SQLJob [dataNodeOrDatabase=" +
                 dataNodeOrDatabase + ",sql=" + sql + ",  jobHandler=" +
                 jobHandler + "]";
     }
Only in ./RegMiner4APR-Regression-Bugs/WORKING/src/main/java/com/actiontech/dble/util: SetIgnoreUtil.java