{
    "1": {
        "buggy_function": "  void CheckFontSize(CssGrammar.CssConstruct construct, CssGrammar.CssDeclaration declaration)\n  {\n    MessageId id = hasIndividualFixedFormatDocuments ? MessageId.ACC_016 : MessageId.ACC_014;\n    switch (construct.getType())\n    {\n      case KEYWORD:\n      {\n        if (!isGlobalFixedFormat || hasIndividualFixedFormatDocuments)\n        {\n          // report non-relative font-size keyword as ACC USAGE message\n          String value = construct.toCssString().toLowerCase(Locale.ROOT);\n\n          // report not allowed font-size keyword as ERROR message\n          if (!isFontSize(construct))\n          {\n            getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n          }\n          else if ((\"smaller\".compareTo(value) != 0) && (\"larger\".compareTo(value) != 0) && (\"inherit\".compareTo(value) != 0))\n          {\n            getReport().message(id, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n          }\n          \n        }\n        break;\n      }\n      case QUANTITY:\n        if (!isGlobalFixedFormat || hasIndividualFixedFormatDocuments)\n        {\n          CssGrammar.CssQuantity quantity = (CssGrammar.CssQuantity) construct;\n          switch (quantity.getUnit())\n          {\n            case EMS:\n            case EXS:\n            case REMS:\n            case PERCENTAGE:\n              break;\n            case LENGTH:\n              // report absolute font-size as ACC USAGE message\n              getReport().message(id, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n              break;\n            default:\n              // report unsupported font-size as ERROR message\n              getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n              break;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }\n",
        "patched_function": "  void CheckFontSize(CssGrammar.CssConstruct construct, CssGrammar.CssDeclaration declaration)\n  {\n    MessageId id = hasIndividualFixedFormatDocuments ? MessageId.ACC_016 : MessageId.ACC_014;\n    switch (construct.getType())\n    {\n      case KEYWORD:\n      {\n        if (!isGlobalFixedFormat || hasIndividualFixedFormatDocuments)\n        {\n          // report non-relative font-size keyword as ACC USAGE message\n          String value = construct.toCssString().toLowerCase(Locale.ROOT);\n\n          // report not allowed font-size keyword as ERROR message\n          if (!isFontSize(construct))\n          {\n            getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n          }\n          else if ((\"smaller\".compareTo(value) != 0) && (\"larger\".compareTo(value) != 0) && (\"inherit\".compareTo(value) != 0))\n          {\n            getReport().message(id, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n          }\n          \n        }\n        break;\n      }\n      case QUANTITY:\n        if (!isGlobalFixedFormat || hasIndividualFixedFormatDocuments)\n        {\n          CssGrammar.CssQuantity quantity = (CssGrammar.CssQuantity) construct;\n          switch (quantity.getUnit())\n          {\n            case EMS:\n            case EXS:\n            case REMS:\n            case PERCENTAGE:\n              break;\n            case LENGTH:\n              // report absolute font-size as ACC USAGE message\n              getReport().message(id, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n              break;\n            case INTEGER:\n              // issue #922: \"0\" should be allowed as font-size\n              if (!quantity.toCssString().equals(\"0\"))\n              {\n                // report unsupported font-size as ERROR message\n                getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n              }\n              break;\n            default:\n              // report unsupported font-size as ERROR message\n              getReport().message(MessageId.CSS_020, getCorrectedEPUBLocation(path, declaration.getLocation().getLine(), declaration.getLocation().getColumn(), declaration.toCssString()), construct.toCssString());\n              break;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }"
    },
    "2": {
        "buggy_function": "  private void readUntilEndOfEntry() throws IOException {\n    if (localFileHeader.isDirectory() || localFileHeader.getCompressedSize() == 0) {\n      return;\n    }\n\n    if (endOfEntryBuffer == null) {\n      endOfEntryBuffer = new byte[512];\n    }\n\n    while (read(endOfEntryBuffer) != -1);\n  }\n",
        "patched_function": "  private void readUntilEndOfEntry() throws IOException {\n    // If data descriptor exists, proceed to reading the entry, or else skip if the entry is directory\n    // or compressed size is 0\n    if (!localFileHeader.isDataDescriptorExists()\n        && (localFileHeader.isDirectory() || localFileHeader.getCompressedSize() == 0)) {\n      return;\n    }\n\n    if (endOfEntryBuffer == null) {\n      endOfEntryBuffer = new byte[512];\n    }\n\n    while (read(endOfEntryBuffer) != -1);\n  }"
    },
    "3": {
        "buggy_function": "  public Formula implication(final Formula left, final Formula right) {\n    if (left.type() == FALSE || right.type() == TRUE)\n      return this.verum();\n    if (left.type() == TRUE)\n      return right;\n    if (right.type() == FALSE)\n      return this.not(left);\n    if (left.equals(right))\n      return this.verum();\n    if (left.negate().equals(right))\n      return left.negate();\n    final Pair<Formula, Formula> key = new Pair<>(left, right);\n    Implication implication = this.implications.get(key);\n    if (implication == null) {\n      implication = new Implication(left, right, this);\n      this.implications.put(key, implication);\n    }\n    return implication;\n  }\n",
        "patched_function": "  public Formula implication(final Formula left, final Formula right) {\n    if (left.type() == FALSE || right.type() == TRUE)\n      return this.verum();\n    if (left.type() == TRUE)\n      return right;\n    if (right.type() == FALSE)\n      return this.not(left);\n    if (left.equals(right))\n      return this.verum();\n    final Pair<Formula, Formula> key = new Pair<>(left, right);\n    Implication implication = this.implications.get(key);\n    if (implication == null) {\n      implication = new Implication(left, right, this);\n      this.implications.put(key, implication);\n    }\n    return implication;\n  }"
    },
    "5": {
        "buggy_function": "    @Exported(visibility=999)\n    public @Override String getName() {\n    \tif (testName.isEmpty()) {\n    \t\treturn \"(?)\";\n    \t}\n        return testName;\n    }\n",
        "patched_function": "    @Exported(visibility=999)\n    public @Override String getName() {\n        if (StringUtils.isEmpty(testName)) {\n            return \"(?)\";\n        }\n        return testName;\n    }"
    },
    "10": {
        "buggy_function": "\tprivate static boolean isAssignableFrom(Class<?> target, KType source) {\n\n\t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n\n\t\treturn ResolvableType.forClass(target).isAssignableFrom(ResolvableType.forType(parameterType));\n\t}\n",
        "patched_function": "\tprivate static boolean isAssignableFrom(Class<?> target, KType source) {\n\n\t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n\n\t\tClass<?> rawClass = ResolvableType.forType(parameterType).getRawClass();\n\t\treturn rawClass == null || target.isAssignableFrom(rawClass);\n\t}"
    },
    "12": {
        "buggy_function": "    private YamlNode valueOfStringKey(final String key) {\n        YamlNode value = null;\n        final String[] keys = new String[] {\n            key,\n            \"\\\"\" + key + \"\\\"\",\n            \"'\" + key + \"'\",\n        };\n        for(final String tryKey : keys) {\n            for (final YamlLine line : this.significant) {\n                final String trimmed = line.trimmed();\n                if(trimmed.endsWith(tryKey + \":\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\>$\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\|$\")\n                ) {\n                    value = this.significant.toYamlNode(\n                        line, this.guessIndentation\n                    );\n                } else if((trimmed.startsWith(tryKey + \":\")\n                    || trimmed.startsWith(\"- \" + tryKey + \":\"))\n                    && trimmed.length() > 1\n                ) {\n                    value = new ReadPlainScalar(this.all, line);\n                }\n                if(value != null) {\n                    return value;\n                }\n            }\n        }\n        return null;\n    }\n",
        "patched_function": "    private YamlNode valueOfStringKey(final String key) {\n        YamlNode value = null;\n        final String[] keys = new String[] {\n            key,\n            \"\\\"\" + key + \"\\\"\",\n            \"'\" + key + \"'\",\n        };\n        for(final String tryKey : keys) {\n            for (final YamlLine line : this.significant) {\n                final String trimmed = line.trimmed();\n                if(trimmed.equals(tryKey + \":\") || trimmed.equals(\"- \"+ tryKey + \":\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\>$\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\|$\")\n                ) {\n                    value = this.significant.toYamlNode(\n                        line, this.guessIndentation\n                    );\n                } else if((trimmed.startsWith(tryKey + \":\")\n                    || trimmed.startsWith(\"- \" + tryKey + \":\"))\n                    && trimmed.length() > 1\n                ) {\n                    value = new ReadPlainScalar(this.all, line);\n                }\n                if(value != null) {\n                    return value;\n                }\n            }\n        }\n        return null;\n    }"
    },
    "13": {
        "buggy_function": "    private YamlNode valueOfStringKey(final String key) {\n        YamlNode value = null;\n        final String[] keys = new String[] {\n            key,\n            \"\\\"\" + key + \"\\\"\",\n            \"'\" + key + \"'\",\n        };\n        for(final String tryKey : keys) {\n            for (final YamlLine line : this.significant) {\n                final String trimmed = line.trimmed();\n                if(trimmed.endsWith(tryKey + \":\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\>$\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\|$\")\n                ) {\n                    value = this.significant.toYamlNode(\n                        line, this.guessIndentation\n                    );\n                } else if((trimmed.startsWith(tryKey + \":\")\n                    || trimmed.startsWith(\"- \" + tryKey + \":\"))\n                    && trimmed.length() > 1\n                ) {\n                    value = new ReadPlainScalar(this.all, line);\n                }\n                if(value != null) {\n                    return value;\n                }\n            }\n        }\n        return null;\n    }\n",
        "patched_function": "    private YamlNode valueOfStringKey(final String key) {\n        YamlNode value = null;\n        final String[] keys = new String[] {\n            key,\n            \"\\\"\" + key + \"\\\"\",\n            \"'\" + key + \"'\",\n        };\n        for(final String tryKey : keys) {\n            for (final YamlLine line : this.significant) {\n                final String trimmed = line.trimmed();\n                if(trimmed.matches(\"^-?[ ]*\" + Pattern.quote(tryKey) + \":\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\>$\")\n                    || trimmed.matches(\"^\" + Pattern.quote(tryKey) + \"\\\\:[ ]*\\\\|$\")\n                ) {\n                    value = this.significant.toYamlNode(\n                        line, this.guessIndentation\n                    );\n                } else if((trimmed.startsWith(tryKey + \":\")\n                    || trimmed.startsWith(\"- \" + tryKey + \":\"))\n                    && trimmed.length() > 1\n                ) {\n                    value = new ReadPlainScalar(this.all, line);\n                }\n                if(value != null) {\n                    return value;\n                }\n            }\n        }\n        return null;\n    }"
    },
    "17": {
        "buggy_function": "    @SuppressWarnings(\"rawtypes\")\n    protected Object getArrayItem(final Object currentObject, int index) {\n        if (currentObject == null) {\n            return null;\n        }\n\n        if (currentObject instanceof List) {\n            List list = (List) currentObject;\n\n            if (index >= 0) {\n                if (index < list.size()) {\n                    return list.get(index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= list.size()) {\n                    return list.get(list.size() + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject.getClass().isArray()) {\n            int arrayLenth = Array.getLength(currentObject);\n\n            if (index >= 0) {\n                if (index < arrayLenth) {\n                    return Array.get(currentObject, index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= arrayLenth) {\n                    return Array.get(currentObject, arrayLenth + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject instanceof Map) {\n            Map map = (Map) currentObject;\n            Object value = map.get(index);\n            if (value == null) {\n                value = map.get(Integer.toString(index));\n            }\n            return value;\n        }\n\n        if (currentObject instanceof Collection) {\n            Collection collection = (Collection) currentObject;\n            int i = 0;\n            for (Object item : collection) {\n                if (i == index) {\n                    return item;\n                }\n                i++;\n            }\n            return null;\n        }\n\n        throw new UnsupportedOperationException();\n    }\n",
        "patched_function": "    @SuppressWarnings(\"rawtypes\")\n    protected Object getArrayItem(final Object currentObject, int index) {\n        if (currentObject == null) {\n            return null;\n        }\n\n        if (currentObject instanceof List) {\n            List list = (List) currentObject;\n\n            if (index >= 0) {\n                if (index < list.size()) {\n                    return list.get(index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= list.size()) {\n                    return list.get(list.size() + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject.getClass().isArray()) {\n            int arrayLenth = Array.getLength(currentObject);\n\n            if (index >= 0) {\n                if (index < arrayLenth) {\n                    return Array.get(currentObject, index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= arrayLenth) {\n                    return Array.get(currentObject, arrayLenth + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject instanceof Map) {\n            Map map = (Map) currentObject;\n            Object value = map.get(index);\n            if (value == null) {\n                value = map.get(Integer.toString(index));\n            }\n            return value;\n        }\n\n        if (currentObject instanceof Collection) {\n            Collection collection = (Collection) currentObject;\n            int i = 0;\n            for (Object item : collection) {\n                if (i == index) {\n                    return item;\n                }\n                i++;\n            }\n            return null;\n        }\n\n        if (index == 0) {\n            return currentObject;\n        }\n\n        throw new UnsupportedOperationException();\n    }"
    },
    "21": {
        "buggy_function": "    public SQLExpr orRest(SQLExpr expr) {\n        for (;;) {\n            if (lexer.token == Token.OR) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                if (lexer.token == Token.OR\n                        && lexer.isEnabled(SQLParserFeature.EnableSQLBinaryOpExprGroup)) {\n\n                    SQLBinaryOpExprGroup group = new SQLBinaryOpExprGroup(SQLBinaryOperator.BooleanOr, dbType);\n                    group.add(expr);\n                    group.add(rightExp);\n\n                    if (lexer.isKeepComments() && lexer.hasComment()) {\n                        rightExp.addAfterComment(lexer.readAndResetComments());\n                    }\n\n                    for (;;) {\n                        lexer.nextToken();\n                        SQLExpr more = relational();\n                        group.add(more);\n                        if (lexer.token == Token.OR) {\n                            if (lexer.isKeepComments() && lexer.hasComment()) {\n                                more.addAfterComment(lexer.readAndResetComments());\n                            }\n\n                            continue;\n                        }\n                        break;\n                    }\n\n                    expr = group;\n                } else {\n                    expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, dbType);\n                }\n            } else  if (lexer.token == Token.BARBAR && JdbcConstants.MYSQL.equals(dbType)) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, dbType);\n            } else if (lexer.token == Token.XOR) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanXor, rightExp, dbType);\n            } else {\n                break;\n            }\n        }\n\n        return expr;\n    }\n",
        "patched_function": "    public SQLExpr orRest(SQLExpr expr) {\n        for (;;) {\n            if (lexer.token == Token.OR) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                if (lexer.token == Token.OR\n                        && lexer.isEnabled(SQLParserFeature.EnableSQLBinaryOpExprGroup)) {\n\n                    SQLBinaryOpExprGroup group = new SQLBinaryOpExprGroup(SQLBinaryOperator.BooleanOr, dbType);\n                    group.add(expr);\n                    group.add(rightExp);\n\n                    if (lexer.isKeepComments() && lexer.hasComment()) {\n                        rightExp.addAfterComment(lexer.readAndResetComments());\n                    }\n\n                    for (;;) {\n                        lexer.nextToken();\n                        SQLExpr more = and();\n                        group.add(more);\n                        if (lexer.token == Token.OR) {\n                            if (lexer.isKeepComments() && lexer.hasComment()) {\n                                more.addAfterComment(lexer.readAndResetComments());\n                            }\n\n                            continue;\n                        }\n                        break;\n                    }\n\n                    expr = group;\n                } else {\n                    expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, dbType);\n                }\n            } else  if (lexer.token == Token.BARBAR && JdbcConstants.MYSQL.equals(dbType)) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, dbType);\n            } else if (lexer.token == Token.XOR) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanXor, rightExp, dbType);\n            } else {\n                break;\n            }\n        }\n\n        return expr;\n    }"
    },
    "22": {
        "buggy_function": "    protected void printInteger(SQLIntegerExpr x, boolean parameterized) {\n        long val = x.getNumber().longValue();\n\n        if (val == 1) {\n            if (JdbcConstants.ORACLE.equals(dbType)) {\n                SQLObject parent = x.getParent();\n                if (parent instanceof SQLBinaryOpExpr) {\n                    SQLBinaryOpExpr binaryOpExpr = (SQLBinaryOpExpr) parent;\n                    SQLExpr left = binaryOpExpr.getLeft();\n                    SQLBinaryOperator op = binaryOpExpr.getOperator();\n                    if (left instanceof SQLIdentifierExpr\n                            && op == SQLBinaryOperator.Equality) {\n                        String name = ((SQLIdentifierExpr) left).getName();\n                        if (\"rownum\".equals(name)) {\n                            print(1);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        if (parameterized) {\n            print('?');\n            incrementReplaceCunt();\n\n            if(this.parameters != null){\n                ExportParameterVisitorUtils.exportParameter(this.parameters, x);\n            }\n            return;\n        }\n\n        print(val);\n    }\n",
        "patched_function": "    protected void printInteger(SQLIntegerExpr x, boolean parameterized) {\n        String val = x.getNumber().toString();\n\n        if (\"1\".equals(val)) {\n            if (JdbcConstants.ORACLE.equals(dbType)) {\n                SQLObject parent = x.getParent();\n                if (parent instanceof SQLBinaryOpExpr) {\n                    SQLBinaryOpExpr binaryOpExpr = (SQLBinaryOpExpr) parent;\n                    SQLExpr left = binaryOpExpr.getLeft();\n                    SQLBinaryOperator op = binaryOpExpr.getOperator();\n                    if (left instanceof SQLIdentifierExpr\n                            && op == SQLBinaryOperator.Equality) {\n                        String name = ((SQLIdentifierExpr) left).getName();\n                        if (\"rownum\".equals(name)) {\n                            print(1);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        if (parameterized) {\n            print('?');\n            incrementReplaceCunt();\n\n            if(this.parameters != null){\n                ExportParameterVisitorUtils.exportParameter(this.parameters, x);\n            }\n            return;\n        }\n\n        print(val);\n    }"
    },
    "24": {
        "buggy_function": "    @Override\n    public void close() throws IOException {\n        this.input.close();\n        this.output.close();\n    }\n",
        "patched_function": "    @Override\n    public void close() throws IOException {\n        this.input.close();\n        this.output.flush();\n    }"
    },
    "25": {
        "buggy_function": "    @Override\n    public final boolean equals(final Object other) {\n        return new UncheckedScalar<>(\n            new And(\n                new Or(\n                    () -> new InheritanceLevel(\n                        other.getClass(), Collection.class\n                    ).value() > -1,\n                    () -> new InheritanceLevel(\n                        other.getClass(), CollectionEnvelope.class\n                    ).value() > -1\n                ),\n                () -> {\n                    final Collection<?> compared = (Collection<?>) other;\n                    return this.size() == compared.size();\n                },\n                () -> {\n                    final Iterable<?> compared = (Iterable<?>) other;\n                    final Iterator<?> iterator = compared.iterator();\n                    return new UncheckedScalar<>(\n                        new And(\n                            (X input) -> input.equals(iterator.next()),\n                            this\n                        )\n                    ).value();\n                }\n            )\n        ).value();\n    }\n",
        "patched_function": "    @Override\n    public final boolean equals(final Object other) {\n        return new UncheckedScalar<>(\n            new And(\n                () -> other != null,\n                () -> new InheritanceLevel(\n                    other.getClass(), CollectionEnvelope.class\n                ).value() > -1,\n                () -> {\n                    final Collection<?> compared = (Collection<?>) other;\n                    return this.size() == compared.size();\n                },\n                () -> {\n                    final Iterable<?> compared = (Iterable<?>) other;\n                    final Iterator<?> iterator = compared.iterator();\n                    return new UncheckedScalar<>(\n                        new And(\n                            (X input) -> input.equals(iterator.next()),\n                            this\n                        )\n                    ).value();\n                }\n            )\n        ).value();\n    }"
    },
    "28": {
        "buggy_function": "\tfinal void reset() {\n\t\tthis.columnsToExtractInitialized = false;\n\t\tthis.currentRecord = 0;\n\t\tthis.column = 0;\n\t\tthis.headers = null;\n\t}\n",
        "patched_function": "\tfinal void reset() {\n\t\tthis.columnsToExtractInitialized = false;\n\t\tthis.currentRecord = 0;\n\t\tthis.column = 0;\n\t\tthis.headers = null;\n\t\tthis.headerStrings = null;\n\t}"
    },
    "30": {
        "buggy_function": "\tpublic String[] rowParsed() {\n\t\t// some values were parsed. Let's return them\n\t\tif (column > 0) {\n\t\t\t// identifies selected columns and headers (in the first non-empty row)\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t\t//skips the header row. We want to use the headers defined in the settings.\n\t\t\t\tif (settings.isHeaderExtractionEnabled()) {\n\t\t\t\t\tArrays.fill(parsedValues, null);\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tthis.appender = appenders[0];\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (!columnsReordered && selectedIndexes != null) {\n\t\t\t\t\tString[] out = new String[column];\n\t\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\t\tif (index < column) {\n\t\t\t\t\t\t\tout[index] = parsedValues[index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\treturn out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] reorderedValues = new String[selectedIndexes.length];\n\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\tif (index >= column || index == -1) {\n\t\t\t\t\t\treorderedValues[i] = nullValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treorderedValues[i] = parsedValues[index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn reorderedValues;\n\t\t\t} else {\n\t\t\t\tint last = columnReorderingEnabledSetting ? column : column < headers.length ? headers.length : column;\n\n\t\t\t\tString[] out = new String[last];\n\t\t\t\tSystem.arraycopy(parsedValues, 0, out, 0, column);\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn out;\n\t\t\t}\n\t\t} else if (!skipEmptyLines) { //no values were parsed, but we are not skipping empty lines\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] out = new String[selectedIndexes.length];\n\t\t\t\tArrays.fill(out, nullValue);\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t}\n\t\t// no values were parsed and we do not care about empty lines.\n\t\treturn null;\n\t}\n",
        "patched_function": "\tpublic String[] rowParsed() {\n\t\t// some values were parsed. Let's return them\n\t\tif (column > 0) {\n\t\t\t// identifies selected columns and headers (in the first non-empty row)\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t\t//skips the header row. We want to use the headers defined in the settings.\n\t\t\t\tif (settings.isHeaderExtractionEnabled()) {\n\t\t\t\t\tArrays.fill(parsedValues, null);\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tthis.appender = appenders[0];\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (!columnsReordered && selectedIndexes != null) {\n\t\t\t\t\tString[] out = new String[column];\n\t\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\t\tif (index < column) {\n\t\t\t\t\t\t\tout[index] = parsedValues[index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\treturn out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] reorderedValues = new String[selectedIndexes.length];\n\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\tif (index >= column || index == -1) {\n\t\t\t\t\t\treorderedValues[i] = nullValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treorderedValues[i] = parsedValues[index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn reorderedValues;\n\t\t\t} else {\n\t\t\t\tint last = columnReorderingEnabledSetting ? column : column < headers.length ? headers.length : column;\n\n\t\t\t\tString[] out = new String[last];\n\t\t\t\tSystem.arraycopy(parsedValues, 0, out, 0, column);\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn out;\n\t\t\t}\n\t\t} else if (!skipEmptyLines) { //no values were parsed, but we are not skipping empty lines\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] out = new String[selectedIndexes.length];\n\t\t\t\tArrays.fill(out, nullValue);\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t}\n\t\t// no values were parsed and we do not care about empty lines.\n\t\treturn null;\n\t}"
    },
    "31": {
        "buggy_function": "\tprivate char pickDelimiter(Map<Character, Integer> sums, Map<Character, Integer> totals) {\n\t\tchar delimiterMax = max(sums, totals, suggestedDelimiter);\n\t\tchar delimiterMin = min(sums, totals, suggestedDelimiter);\n\n\t\tchar delimiter;\n\t\tout:\n\t\tif (delimiterMax != delimiterMin) {\n\t\t\tif (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\n\t\t\tfor (char c : delimiterPreference) {\n\t\t\t\tif (c == delimiterMin) {\n\t\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\t\tbreak out;\n\t\t\t\t} else if (c == delimiterMax) {\n\t\t\t\t\tdelimiter = delimiterMax;\n\t\t\t\t\tbreak out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (totals.get(delimiterMin) > totals.get(delimiterMax)) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\t\t\tdelimiter = delimiterMax;\n\t\t} else {\n\t\t\tdelimiter = delimiterMax;\n\t\t}\n\t\treturn delimiter;\n\t}\n",
        "patched_function": "\tprotected char pickDelimiter(Map<Character, Integer> sums, Map<Character, Integer> totals) {\n\t\tchar delimiterMax = max(sums, totals, suggestedDelimiter);\n\t\tchar delimiterMin = min(sums, totals, suggestedDelimiter);\n\n\t\tif (delimiterMin == ' ' || delimiterMax == ' ') {\n\t\t\tboolean hasOtherDelimiters = false;\n\t\t\tfor (Map.Entry<Character, Integer> e : sums.entrySet()) {\n\t\t\t\tif (e.getValue() == 0 && e.getKey() != ' ') {\n\t\t\t\t\thasOtherDelimiters = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasOtherDelimiters) {\n\t\t\t\ttotals.remove(' ');\n\t\t\t\tdelimiterMax = max(sums, totals, suggestedDelimiter);\n\t\t\t\tdelimiterMin = min(sums, totals, suggestedDelimiter);\n\t\t\t}\n\t\t}\n\n\t\tchar delimiter;\n\t\tout:\n\t\tif (delimiterMax != delimiterMin) {\n\t\t\tif (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\n\t\t\tfor (char c : delimiterPreference) {\n\t\t\t\tif (c == delimiterMin) {\n\t\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\t\tbreak out;\n\t\t\t\t} else if (c == delimiterMax) {\n\t\t\t\t\tdelimiter = delimiterMax;\n\t\t\t\t\tbreak out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (totals.get(delimiterMin) > totals.get(delimiterMax)) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\t\t\tdelimiter = delimiterMax;\n\t\t} else {\n\t\t\tdelimiter = delimiterMax;\n\t\t}\n\t\treturn delimiter;\n\t}"
    },
    "33": {
        "buggy_function": "\tprivate final void parseSingleDelimiterRecord() {\n\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t}\n\n\t\twhile (ch != newLine) {\n\t\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t\t}\n\n\t\t\tif (ch == delimiter || ch == newLine) {\n\t\t\t\toutput.emptyParsed();\n\t\t\t} else {\n\t\t\t\tunescaped = false;\n\t\t\t\tprev = '\\0';\n\t\t\t\tif (ch == quote) {\n\t\t\t\t\tinput.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);\n\t\t\t\t\tint len = output.appender.length();\n\t\t\t\t\tif (len == 0) {\n\t\t\t\t\t\tString value = input.getQuotedString(quote, quoteEscape, escapeEscape, maxColumnLength, delimiter, newLine, keepQuotes, keepEscape, trimQuotedLeading, trimQuotedTrailing);\n\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\toutput.valueParsed(value == \"\" ? emptyValue : value);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (len == -1 && input.skipQuotedString(quote, quoteEscape, delimiter, newLine)) {\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\toutput.trim = trimQuotedTrailing;\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n\t\t\t\t\tif (!(unescaped && quoteHandling == BACK_TO_DELIMITER && output.appender.length() == 0)) {\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else if (doNotEscapeUnquotedValues) {\n\t\t\t\t\tString value = null;\n\t\t\t\t\tint len = output.appender.length();\n\t\t\t\t\tif (len == 0) {\n\t\t\t\t\t\tvalue = input.getString(ch, delimiter, ignoreTrailingWhitespace, nullValue, maxColumnLength);\n\t\t\t\t\t}\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\toutput.valueParsed(value);\n\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (len != -1) {\n\t\t\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (input.skipString(ch, delimiter)) {\n\t\t\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\tparseValueProcessingEscape();\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch != newLine) {\n\t\t\t\tch = input.nextChar();\n\t\t\t\tif (ch == newLine) {\n\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
        "patched_function": "\tprivate final void parseSingleDelimiterRecord() {\n\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t}\n\n\t\twhile (ch != newLine) {\n\t\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t\t}\n\n\t\t\tif (ch == delimiter || ch == newLine) {\n\t\t\t\toutput.emptyParsed();\n\t\t\t} else {\n\t\t\t\tunescaped = false;\n\t\t\t\tprev = '\\0';\n\t\t\t\tif (ch == quote) {\n\t\t\t\t\tinput.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);\n\t\t\t\t\tint len = output.appender.length();\n\t\t\t\t\tif (len == 0) {\n\t\t\t\t\t\tString value = input.getQuotedString(quote, quoteEscape, escapeEscape, maxColumnLength, delimiter, newLine, keepQuotes, keepEscape, trimQuotedLeading, trimQuotedTrailing);\n\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\toutput.valueParsed(value == \"\" ? emptyValue : value);\n\t\t\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (len == -1 && input.skipQuotedString(quote, quoteEscape, delimiter, newLine)) {\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\toutput.trim = trimQuotedTrailing;\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n\t\t\t\t\tif (!(unescaped && quoteHandling == BACK_TO_DELIMITER && output.appender.length() == 0)) {\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else if (doNotEscapeUnquotedValues) {\n\t\t\t\t\tString value = null;\n\t\t\t\t\tint len = output.appender.length();\n\t\t\t\t\tif (len == 0) {\n\t\t\t\t\t\tvalue = input.getString(ch, delimiter, ignoreTrailingWhitespace, nullValue, maxColumnLength);\n\t\t\t\t\t}\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\toutput.valueParsed(value);\n\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (len != -1) {\n\t\t\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (input.skipString(ch, delimiter)) {\n\t\t\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\tparseValueProcessingEscape();\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch != newLine) {\n\t\t\t\tch = input.nextChar();\n\t\t\t\tif (ch == newLine) {\n\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
    },
    "34": {
        "buggy_function": "\tprivate <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n\t\ttry {\n\t\t\tIterator[] iterators = new Iterator[rowData.size()];\n\t\t\tObject[] keys = new Object[rowData.size()];\n\t\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<Object, Object>(rowData.size());\n\n\t\t\tif(headers == null){\n\t\t\t\tif(headerMapping != null){\n\t\t\t\t\tsetHeadersFromMap(headerMapping, true);\n\t\t\t\t} else {\n\t\t\t\t\tsetHeadersFromMap(rowData, true);\n\t\t\t\t}\n\t\t\t\tif(isHeaderWritingEnabled && recordCount == 0){\n\t\t\t\t\toutputList.add(writeHeadersToString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint length = 0;\n\t\t\tfor (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n\t\t\t\titerators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n\t\t\t\tkeys[length] = rowEntry.getKey();\n\t\t\t\trowValues.put(rowEntry.getKey(), null);\n\t\t\t\tlength++;\n\t\t\t}\n\t\t\tboolean nullsOnly;\n\n\t\t\tdo {\n\t\t\t\tnullsOnly = true;\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tIterator<?> iterator = iterators[i];\n\t\t\t\t\tboolean isNull = iterator == null || !iterator.hasNext();\n\t\t\t\t\tnullsOnly &= isNull;\n\t\t\t\t\tif (isNull) {\n\t\t\t\t\t\trowValues.put(keys[i], null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trowValues.put(keys[i], iterator.next());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!nullsOnly) {\n\t\t\t\t\tif (outputList == null) {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\tprocessRecord((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteRow((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\toutputList.add(processRecordToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toutputList.add(writeRowToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!nullsOnly);\n\t\t} catch (Throwable t) {\n\t\t\tthrow throwExceptionAndClose(\"Error processing input rows from map\", t);\n\t\t}\n\t}\n",
        "patched_function": "\tprivate <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n\t\ttry {\n\t\t\tIterator[] iterators = new Iterator[rowData.size()];\n\t\t\tObject[] keys = new Object[rowData.size()];\n\t\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<Object, Object>(rowData.size());\n\n\t\t\tif(outputList != null && headers == null){\n\t\t\t\tif(headerMapping != null){\n\t\t\t\t\tsetHeadersFromMap(headerMapping, true);\n\t\t\t\t} else {\n\t\t\t\t\tsetHeadersFromMap(rowData, true);\n\t\t\t\t}\n\t\t\t\tif(isHeaderWritingEnabled && recordCount == 0){\n\t\t\t\t\toutputList.add(writeHeadersToString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint length = 0;\n\t\t\tfor (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n\t\t\t\titerators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n\t\t\t\tkeys[length] = rowEntry.getKey();\n\t\t\t\trowValues.put(rowEntry.getKey(), null);\n\t\t\t\tlength++;\n\t\t\t}\n\t\t\tboolean nullsOnly;\n\n\t\t\tdo {\n\t\t\t\tnullsOnly = true;\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tIterator<?> iterator = iterators[i];\n\t\t\t\t\tboolean isNull = iterator == null || !iterator.hasNext();\n\t\t\t\t\tnullsOnly &= isNull;\n\t\t\t\t\tif (isNull) {\n\t\t\t\t\t\trowValues.put(keys[i], null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trowValues.put(keys[i], iterator.next());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!nullsOnly) {\n\t\t\t\t\tif (outputList == null) {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\tprocessRecord((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteRow((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\toutputList.add(processRecordToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toutputList.add(writeRowToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!nullsOnly);\n\t\t} catch (Throwable t) {\n\t\t\tthrow throwExceptionAndClose(\"Error processing input rows from map\", t);\n\t\t}\n\t}"
    },
    "35": {
        "buggy_function": "\t@Override\n\tprotected final void parseRecord() {\n\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t}\n\n\t\twhile (ch != newLine) {\n\t\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t\t}\n\n\t\t\tif (ch == delimiter || ch == newLine) {\n\t\t\t\toutput.emptyParsed();\n\t\t\t} else {\n\t\t\t\tunescaped = false;\n\t\t\t\tprev = '\\0';\n\t\t\t\tif (ch == quote) {\n\t\t\t\t\toutput.trim = false;\n\t\t\t\t\tinput.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);\n\t\t\t\t\tif (output.appender.length() == 0) {\n\t\t\t\t\t\tString value = input.getQuotedString(quote, quoteEscape, escapeEscape, maxColumnLength, delimiter, newLine, keepQuotes, keepEscape);\n\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\toutput.valueParsed(value == \"\" ? emptyValue : value);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t} else if (doNotEscapeUnquotedValues) {\n\t\t\t\t\tString value = null;\n\t\t\t\t\tif (output.appender.length() == 0) {\n\t\t\t\t\t\tvalue = input.getString(ch, delimiter, ignoreTrailingWhitespace, nullValue, maxColumnLength);\n\t\t\t\t\t}\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\toutput.valueParsed(value);\n\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\tparseValueProcessingEscape();\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch != newLine) {\n\t\t\t\tch = input.nextChar();\n\t\t\t\tif (ch == newLine) {\n\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n",
        "patched_function": "\t@Override\n\tprotected final void parseRecord() {\n\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t}\n\n\t\twhile (ch != newLine) {\n\t\t\tif (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {\n\t\t\t\tch = input.skipWhitespace(ch, delimiter, quote);\n\t\t\t}\n\n\t\t\tif (ch == delimiter || ch == newLine) {\n\t\t\t\toutput.emptyParsed();\n\t\t\t} else {\n\t\t\t\tunescaped = false;\n\t\t\t\tprev = '\\0';\n\t\t\t\tif (ch == quote) {\n\t\t\t\t\toutput.trim = false;\n\t\t\t\t\tinput.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);\n\t\t\t\t\tif (output.appender.length() == 0) {\n\t\t\t\t\t\tString value = input.getQuotedString(quote, quoteEscape, escapeEscape, maxColumnLength, delimiter, newLine, keepQuotes, keepEscape);\n\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\toutput.valueParsed(value == \"\" ? emptyValue : value);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\tif (ch == delimiter) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t\t\t\t\t\tif(ch == newLine){\n\t\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t\tinput.enableNormalizeLineEndings(true);\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t} else if (doNotEscapeUnquotedValues) {\n\t\t\t\t\tString value = null;\n\t\t\t\t\tif (output.appender.length() == 0) {\n\t\t\t\t\t\tvalue = input.getString(ch, delimiter, ignoreTrailingWhitespace, nullValue, maxColumnLength);\n\t\t\t\t\t}\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\toutput.valueParsed(value);\n\t\t\t\t\t\tch = input.getChar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t\t\t\t\toutput.valueParsed();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\t\t\tparseValueProcessingEscape();\n\t\t\t\t\toutput.valueParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch != newLine) {\n\t\t\t\tch = input.nextChar();\n\t\t\t\tif (ch == newLine) {\n\t\t\t\t\toutput.emptyParsed();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}"
    },
    "36": {
        "buggy_function": "\t@Override\n\tpublic void execute(char[] characters, int length) {\n\n\t\tSet<Character> allSymbols = new HashSet<Character>();\n\t\tMap<Character, Integer> symbols = new HashMap<Character, Integer>();\n\t\tMap<Character, Integer> escape = new HashMap<Character, Integer>();\n\t\tList<Map<Character, Integer>> symbolsPerRow = new ArrayList<Map<Character, Integer>>();\n\n\t\tint doubleQuoteCount = 0;\n\t\tint singleQuoteCount = 0;\n\n\t\tint i;\n\t\tchar inQuote = '\\0';\n\t\tboolean afterNewLine = true;\n\t\tfor (i = 0; i < length; i++) {\n\n\t\t\tchar ch = characters[i];\n\n\t\t\tif (afterNewLine && ch == comment) {\n\t\t\t\twhile (++i < length) {\n\t\t\t\t\tch = characters[i];\n\t\t\t\t\tif (ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ch == '\"' || ch == '\\'') {\n\t\t\t\tif (inQuote == ch) { //closing quotes (potentially)\n\t\t\t\t\tif (ch == '\"') {\n\t\t\t\t\t\tdoubleQuoteCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsingleQuoteCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\t\tchar next = characters[i + 1];\n\t\t\t\t\t\tif (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\\n' && next != '\\r')) { //no special characters after quote, might be escaping\n\t\t\t\t\t\t\t//special character before (potentially) closing quote, might be an escape\n\t\t\t\t\t\t\tchar prev = characters[i - 1];\n\t\t\t\t\t\t\tif (!Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\t\t\tincrement(escape, prev);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tinQuote = '\\0';\n\t\t\t\t} else if (inQuote == '\\0') {\n\t\t\t\t\tchar prev = '\\0';\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (prev <= ' ' && --j >= 0) {\n\t\t\t\t\t\tprev = characters[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j < 0 || !Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\tinQuote = ch;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inQuote != '\\0') { //keep looping until the quote is closed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tafterNewLine = false;\n\n\t\t\tif (isSymbol(ch)) { //counts all symbols. Skips letters, digits and white spaces (except the tab character)\n\t\t\t\tallSymbols.add(ch);\n\t\t\t\tincrement(symbols, ch);\n\t\t\t} else if ((ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) && symbols.size() > 0) { //got a newline and collected some symbols? Good!\n\t\t\t\tafterNewLine = true;\n\t\t\t\tsymbolsPerRow.add(symbols);\n\t\t\t\tif (symbolsPerRow.size() == MAX_ROW_SAMPLES) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsymbols = new HashMap<Character, Integer>();\n\t\t\t}\n\t\t}\n\n\t\tif (i >= length && symbolsPerRow.size() > 1) { // if got to the end of the buffer, discard last row. It's probably incomplete anyway.\n\t\t\tsymbolsPerRow.remove(symbolsPerRow.size() - 1);\n\t\t}\n\n\t\tMap<Character, Integer> totals = calculateTotals(symbolsPerRow);\n\n\t\tMap<Character, Integer> sums = new HashMap<Character, Integer>();\n\t\tSet<Character> toRemove = new HashSet<Character>();\n\n\t\t//combines the number of symbols found in each row and sums the difference.\n\t\tfor (Map<Character, Integer> previous : symbolsPerRow) {\n\t\t\tfor (Map<Character, Integer> current : symbolsPerRow) {\n\t\t\t\tfor (Character symbol : allSymbols) {\n\t\t\t\t\tInteger previousCount = previous.get(symbol);\n\t\t\t\t\tInteger currentCount = current.get(symbol);\n\n\t\t\t\t\tif (previousCount == null && currentCount == null) { // got a symbol that does not appear in all rows? Discard it.\n\t\t\t\t\t\ttoRemove.add(symbol);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (previousCount == null || currentCount == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tincrement(sums, symbol, Math.abs(previousCount - currentCount)); // we expect to always get 0 or close to 0 here, so the symbol occurs in all rows\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsums.keySet().removeAll(toRemove);\n\n\t\tchar delimiter = max(sums, totals, suggestedDelimiter);\n\t\tchar quote = doubleQuoteCount >= singleQuoteCount ? '\"' : '\\'';\n\n\t\tescape.remove(delimiter);\n\t\tchar quoteEscape = max(escape, totals, quote);\n\t\tapply(delimiter, quote, quoteEscape);\n\t}\n",
        "patched_function": "\t@Override\n\tpublic void execute(char[] characters, int length) {\n\n\t\tSet<Character> allSymbols = new HashSet<Character>();\n\t\tMap<Character, Integer> symbols = new HashMap<Character, Integer>();\n\t\tMap<Character, Integer> escape = new HashMap<Character, Integer>();\n\t\tList<Map<Character, Integer>> symbolsPerRow = new ArrayList<Map<Character, Integer>>();\n\n\t\tint doubleQuoteCount = 0;\n\t\tint singleQuoteCount = 0;\n\n\t\tint i;\n\t\tchar inQuote = '\\0';\n\t\tboolean afterNewLine = true;\n\t\tfor (i = 0; i < length; i++) {\n\n\t\t\tchar ch = characters[i];\n\n\t\t\tif (afterNewLine && ch == comment) {\n\t\t\t\twhile (++i < length) {\n\t\t\t\t\tch = characters[i];\n\t\t\t\t\tif (ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ch == '\"' || ch == '\\'') {\n\t\t\t\tif (inQuote == ch) { //closing quotes (potentially)\n\t\t\t\t\tif (ch == '\"') {\n\t\t\t\t\t\tdoubleQuoteCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsingleQuoteCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\t\tchar next = characters[i + 1];\n\t\t\t\t\t\tif (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\\n' && next != '\\r')) { //no special characters after quote, might be escaping\n\t\t\t\t\t\t\t//special character before (potentially) closing quote, might be an escape\n\t\t\t\t\t\t\tchar prev = characters[i - 1];\n\t\t\t\t\t\t\tif (!Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\t\t\tincrement(escape, prev);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tinQuote = '\\0';\n\t\t\t\t} else if (inQuote == '\\0') {\n\t\t\t\t\tchar prev = '\\0';\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (prev <= ' ' && --j >= 0) {\n\t\t\t\t\t\tprev = characters[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j < 0 || !Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\tinQuote = ch;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inQuote != '\\0') { //keep looping until the quote is closed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tafterNewLine = false;\n\n\t\t\tif (isSymbol(ch)) { //counts all symbols. Skips letters, digits and white spaces (except the tab character)\n\t\t\t\tallSymbols.add(ch);\n\t\t\t\tincrement(symbols, ch);\n\t\t\t} else if ((ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) && symbols.size() > 0) { //got a newline and collected some symbols? Good!\n\t\t\t\tafterNewLine = true;\n\t\t\t\tsymbolsPerRow.add(symbols);\n\t\t\t\tif (symbolsPerRow.size() == MAX_ROW_SAMPLES) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsymbols = new HashMap<Character, Integer>();\n\t\t\t}\n\t\t}\n\n\t\tif (i >= length && symbolsPerRow.size() > 1) { // if got to the end of the buffer, discard last row. It's probably incomplete anyway.\n\t\t\tsymbolsPerRow.remove(symbolsPerRow.size() - 1);\n\t\t}\n\n\t\tMap<Character, Integer> totals = calculateTotals(symbolsPerRow);\n\n\t\tMap<Character, Integer> sums = new HashMap<Character, Integer>();\n\t\tSet<Character> toRemove = new HashSet<Character>();\n\n\t\t//combines the number of symbols found in each row and sums the difference.\n\t\tfor (Map<Character, Integer> previous : symbolsPerRow) {\n\t\t\tfor (Map<Character, Integer> current : symbolsPerRow) {\n\t\t\t\tfor (Character symbol : allSymbols) {\n\t\t\t\t\tInteger previousCount = previous.get(symbol);\n\t\t\t\t\tInteger currentCount = current.get(symbol);\n\n\t\t\t\t\tif (previousCount == null && currentCount == null) { // got a symbol that does not appear in all rows? Discard it.\n\t\t\t\t\t\ttoRemove.add(symbol);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (previousCount == null || currentCount == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tincrement(sums, symbol, Math.abs(previousCount - currentCount)); // we expect to always get 0 or close to 0 here, so the symbol occurs in all rows\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsums.keySet().removeAll(toRemove);\n\n\t\tchar delimiterMax = max(sums, totals, suggestedDelimiter);\n\t\tchar delimiterMin = min(sums, totals, suggestedDelimiter);\n\n\t\tchar delimiter;\n\t\tout:\n\t\tif (delimiterMax != delimiterMin) {\n\t\t\tif (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\n\t\t\tif(totals.get(delimiterMin) > totals.get(delimiterMax)){\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\t\t\tdelimiter = delimiterMax;\n\t\t} else {\n\t\t\tdelimiter = delimiterMax;\n\t\t}\n\n\t\tchar quote = doubleQuoteCount >= singleQuoteCount ? '\"' : '\\'';\n\n\t\tescape.remove(delimiter);\n\t\tchar quoteEscape = max(escape, totals, quote);\n\t\tapply(delimiter, quote, quoteEscape);\n\t}"
    },
    "37": {
        "buggy_function": "\tvoid mapValuesToFields(T instance, Object[] row, Context context) {\n\t\tif (row.length > lastFieldIndexMapped) {\n\t\t\tthis.lastFieldIndexMapped = row.length;\n\t\t\tmapFieldIndexes(context, row, context.headers(), context.extractedFieldIndexes(), context.columnsReordered());\n\t\t}\n\n\t\tint last = row.length < readOrder.length ? row.length : readOrder.length;\n\t\tint i = 0;\n\t\tfor (; i < last; i++) {\n\t\t\tFieldMapping field = readOrder[i];\n\t\t\tif (field != null) {\n\t\t\t\tObject value = row[i];\n\t\t\t\tfield.write(instance, value);\n\t\t\t}\n\t\t}\n\n\t\tif (row.length < readOrder.length) {\n\t\t\ti = last;\n\t\t\tfor (; i < readOrder.length; i++) {\n\t\t\t\tFieldMapping field = readOrder[i];\n\t\t\t\tif (field != null) {\n\t\t\t\t\tObject value = conversions.applyConversions(i, null, null);\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (missing != null) {\n\t\t\tfor (i = 0; i < missing.length; i++) {\n\t\t\t\tObject value = valuesForMissing[i];\n\t\t\t\tif (value != null) {\n\t\t\t\t\tFieldMapping field = missing[i];\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n",
        "patched_function": "\tvoid mapValuesToFields(T instance, Object[] row, Context context) {\n\t\tif (row.length > lastFieldIndexMapped) {\n\t\t\tthis.lastFieldIndexMapped = row.length;\n\t\t\tmapFieldIndexes(context, row, context.headers(), context.extractedFieldIndexes(), context.columnsReordered());\n\t\t}\n\n\t\tint last = row.length < readOrder.length ? row.length : readOrder.length;\n\t\tint i = 0;\n\t\tfor (; i < last; i++) {\n\t\t\tFieldMapping field = readOrder[i];\n\t\t\tif (field != null) {\n\t\t\t\tObject value = row[i];\n\t\t\t\tfield.write(instance, value);\n\t\t\t}\n\t\t}\n\n\t\tif (conversions != null && row.length < readOrder.length) {\n\t\t\ti = last;\n\t\t\tfor (; i < readOrder.length; i++) {\n\t\t\t\tFieldMapping field = readOrder[i];\n\t\t\t\tif (field != null) {\n\t\t\t\t\tObject value = conversions.applyConversions(i, null, null);\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (missing != null) {\n\t\t\tfor (i = 0; i < missing.length; i++) {\n\t\t\t\tObject value = valuesForMissing[i];\n\t\t\t\tif (value != null) {\n\t\t\t\t\tFieldMapping field = missing[i];\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}"
    },
    "38": {
        "buggy_function": "\tprivate void updateBuffer() {\n\t\tif (length - recordStart > 0 && buffer != null) {\n\t\t\ttmp.append(buffer, recordStart, length - recordStart);\n\t\t}\n\t\trecordStart = 0;\n\t\treloadBuffer();\n\n\t\tcharCount += i;\n\t\ti = 0;\n\n\t\tif (length == -1) {\n\t\t\tstop();\n\t\t\tincrementLineCount = true;\n\t\t}\n\n\t\tif (inputAnalysisProcesses != null) {\n\t\t\ttry {\n\t\t\t\tfor (InputAnalysisProcess process : inputAnalysisProcesses) {\n\t\t\t\t\tprocess.execute(buffer, length);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tinputAnalysisProcesses = null;\n\t\t\t}\n\t\t}\n\t}\n",
        "patched_function": "\tprivate void updateBuffer() {\n\t\tif (length - recordStart > 0 && buffer != null) {\n\t\t\ttmp.append(buffer, recordStart, length - recordStart);\n\t\t}\n\t\trecordStart = 0;\n\t\treloadBuffer();\n\n\t\tcharCount += i;\n\t\ti = 0;\n\n\t\tif (length == -1) {\n\t\t\tstop();\n\t\t\tincrementLineCount = true;\n\t\t}\n\n\t\tif (inputAnalysisProcesses != null) {\n\t\t\ttry {\n\t\t\t\tfor (InputAnalysisProcess process : inputAnalysisProcesses) {\n\t\t\t\t\tprocess.execute(buffer, length);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif(length > 4) {\n\t\t\t\t\tinputAnalysisProcesses = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
    },
    "39": {
        "buggy_function": "\tprivate void parseQuotedValue() {\n\t\tif (prev != '\\0' && parseUnescapedQuotesUntilDelimiter) {\n\t\t\tif (quoteHandling == SKIP_VALUE) {\n\t\t\t\tskipValue();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!keepQuotes) {\n\t\t\t\toutput.appender.prepend(quote);\n\t\t\t}\n\t\t\tch = input.nextChar();\n\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t} else {\n\t\t\tif (keepQuotes && prev == '\\0') {\n\t\t\t\toutput.appender.append(quote);\n\t\t\t}\n\t\t\tch = input.nextChar();\n\t\t\twhile (true) {\n\t\t\t\tif (prev == quote && (ch <= ' ' && whitespaceRangeStart < ch || ch == delimiter || ch == newLine)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ch != quote && ch != quoteEscape) {\n\t\t\t\t\tif (prev == quote) { //unescaped quote detected\n\t\t\t\t\t\tif (handleUnescapedQuote()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (prev == quoteEscape && quoteEscape != '\\0') {\n\t\t\t\t\t\toutput.appender.append(quoteEscape);\n\t\t\t\t\t}\n\t\t\t\t\tch = output.appender.appendUntil(ch, input, quote, quoteEscape, escapeEscape);\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t} else {\n\t\t\t\t\tprocessQuoteEscape();\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\tif(unescaped && ch == delimiter || ch == newLine){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// handles whitespaces after quoted value: whitespaces are ignored. Content after whitespaces may be parsed if 'parseUnescapedQuotes' is enabled.\n\t\t\tif (ch != delimiter && ch != newLine && ch <= ' ' && whitespaceRangeStart < ch) {\n\t\t\t\twhitespaceAppender.reset();\n\t\t\t\tdo {\n\t\t\t\t\t//saves whitespaces after value\n\t\t\t\t\twhitespaceAppender.append(ch);\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t//found a new line, go to next record.\n\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} while (ch <= ' ' && whitespaceRangeStart < ch);\n\n\t\t\t\t//there's more stuff after the quoted value, not only empty spaces.\n\t\t\t\tif (ch != delimiter && parseUnescapedQuotes) {\n\t\t\t\t\tif (output.appender instanceof DefaultCharAppender) {\n\t\t\t\t\t\t//puts the quote before whitespaces back, then restores the whitespaces\n\t\t\t\t\t\toutput.appender.append(quote);\n\t\t\t\t\t\t((DefaultCharAppender) output.appender).append(whitespaceAppender);\n\t\t\t\t\t}\n\t\t\t\t\t//the next character is not the escape character, put it there\n\t\t\t\t\tif (parseUnescapedQuotesUntilDelimiter || ch != quote && ch != quoteEscape) {\n\t\t\t\t\t\toutput.appender.append(ch);\n\t\t\t\t\t}\n\n\t\t\t\t\t//sets this character as the previous character (may be escaping)\n\t\t\t\t\t//calls recursively to keep parsing potentially quoted content\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t} else if (keepQuotes) {\n\t\t\t\t\toutput.appender.append(quote);\n\t\t\t\t}\n\t\t\t} else if (keepQuotes) {\n\t\t\t\toutput.appender.append(quote);\n\t\t\t}\n\n\t\t\tif (ch != delimiter && ch != newLine) {\n\t\t\t\tthrow new TextParsingException(context, \"Unexpected character '\" + ch + \"' following quoted value of CSV field. Expecting '\" + delimiter + \"'. Cannot parse CSV input.\");\n\t\t\t}\n\t\t}\n\t}\n",
        "patched_function": "\tprivate void parseQuotedValue() {\n\t\tif (prev != '\\0' && parseUnescapedQuotesUntilDelimiter) {\n\t\t\tif (quoteHandling == SKIP_VALUE) {\n\t\t\t\tskipValue();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!keepQuotes) {\n\t\t\t\toutput.appender.prepend(quote);\n\t\t\t}\n\t\t\tch = input.nextChar();\n\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t} else {\n\t\t\tif (keepQuotes && prev == '\\0') {\n\t\t\t\toutput.appender.append(quote);\n\t\t\t}\n\t\t\tch = input.nextChar();\n\t\t\twhile (true) {\n\t\t\t\tif (prev == quote && (ch <= ' ' && whitespaceRangeStart < ch || ch == delimiter || ch == newLine)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ch != quote && ch != quoteEscape) {\n\t\t\t\t\tif (prev == quote) { //unescaped quote detected\n\t\t\t\t\t\tif (handleUnescapedQuote()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (prev == quoteEscape && quoteEscape != '\\0') {\n\t\t\t\t\t\toutput.appender.append(quoteEscape);\n\t\t\t\t\t}\n\t\t\t\t\tch = output.appender.appendUntil(ch, input, quote, quoteEscape, escapeEscape);\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t} else {\n\t\t\t\t\tprocessQuoteEscape();\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\tif(unescaped && (ch == delimiter || ch == newLine)){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// handles whitespaces after quoted value: whitespaces are ignored. Content after whitespaces may be parsed if 'parseUnescapedQuotes' is enabled.\n\t\t\tif (ch != delimiter && ch != newLine && ch <= ' ' && whitespaceRangeStart < ch) {\n\t\t\t\twhitespaceAppender.reset();\n\t\t\t\tdo {\n\t\t\t\t\t//saves whitespaces after value\n\t\t\t\t\twhitespaceAppender.append(ch);\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t//found a new line, go to next record.\n\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} while (ch <= ' ' && whitespaceRangeStart < ch);\n\n\t\t\t\t//there's more stuff after the quoted value, not only empty spaces.\n\t\t\t\tif (ch != delimiter && parseUnescapedQuotes) {\n\t\t\t\t\tif (output.appender instanceof DefaultCharAppender) {\n\t\t\t\t\t\t//puts the quote before whitespaces back, then restores the whitespaces\n\t\t\t\t\t\toutput.appender.append(quote);\n\t\t\t\t\t\t((DefaultCharAppender) output.appender).append(whitespaceAppender);\n\t\t\t\t\t}\n\t\t\t\t\t//the next character is not the escape character, put it there\n\t\t\t\t\tif (parseUnescapedQuotesUntilDelimiter || ch != quote && ch != quoteEscape) {\n\t\t\t\t\t\toutput.appender.append(ch);\n\t\t\t\t\t}\n\n\t\t\t\t\t//sets this character as the previous character (may be escaping)\n\t\t\t\t\t//calls recursively to keep parsing potentially quoted content\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t} else if (keepQuotes) {\n\t\t\t\t\toutput.appender.append(quote);\n\t\t\t\t}\n\t\t\t} else if (keepQuotes) {\n\t\t\t\toutput.appender.append(quote);\n\t\t\t}\n\n\t\t\tif (ch != delimiter && ch != newLine) {\n\t\t\t\tthrow new TextParsingException(context, \"Unexpected character '\" + ch + \"' following quoted value of CSV field. Expecting '\" + delimiter + \"'. Cannot parse CSV input.\");\n\t\t\t}\n\t\t}\n\t}"
    },
    "40": {
        "buggy_function": "    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.normalName();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n",
        "patched_function": "    private void popStackToClose(Token.EndTag endTag) {\n        String elName = settings.normalizeTag(endTag.tagName);\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }"
    },
    "41": {
        "buggy_function": "        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n",
        "patched_function": "        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = tb.settings.normalizeTag(t.asEndTag().name()); // matches with case sensitivity if enabled\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }"
    },
    "42": {
        "buggy_function": "    public static boolean isInvisibleChar(int c) {\n        return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);\n        // zero width sp, zw non join, zw join, soft hyphen\n    }\n",
        "patched_function": "    public static boolean isInvisibleChar(int c) {\n        return c == 8203 || c == 173; // zero width sp, soft hyphen\n        // previously also included zw non join, zw join - but removing those breaks semantic meaning of text\n    }"
    },
    "43": {
        "buggy_function": "    public String getValue() {\n        return val;\n    }\n",
        "patched_function": "    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }"
    },
    "44": {
        "buggy_function": "    public final float scanFieldFloat(char[] fieldName) {\n        matchStat = UNKNOWN;\n\n        if (!charArrayCompare(fieldName)) {\n            matchStat = NOT_MATCH_NAME;\n            return 0;\n        }\n\n        int offset = fieldName.length;\n        char chLocal = charAt(bp + (offset++));\n\n        final boolean quote = chLocal == '\"';\n        if (quote) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        boolean negative = chLocal == '-';\n        if (negative) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        float value;\n        if (chLocal >= '0' && chLocal <= '9') {\n            int intVal = chLocal - '0';\n            for (;;) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            int power = 1;\n            boolean small = (chLocal == '.');\n            if (small) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    power = 10;\n                    for (;;) {\n                        chLocal = charAt(bp + (offset++));\n                        if (chLocal >= '0' && chLocal <= '9') {\n                            intVal = intVal * 10 + (chLocal - '0');\n                            power *= 10;\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                } else {\n                    matchStat = NOT_MATCH;\n                    return 0;\n                }\n            }\n\n            boolean exp = chLocal == 'e' || chLocal == 'E';\n            if (exp) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal == '+' || chLocal == '-') {\n                    chLocal = charAt(bp + (offset++));\n                }\n                for (;;) {\n                    if (chLocal >= '0' && chLocal <= '9') {\n                        chLocal = charAt(bp + (offset++));\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            int start, count;\n            if (quote) {\n                if (chLocal != '\"') {\n                    matchStat = NOT_MATCH;\n                    return 0;\n                } else {\n                    chLocal = charAt(bp + (offset++));\n                }\n                start = bp + fieldName.length + 1;\n                count = bp + offset - start - 2;\n            } else {\n                start = bp + fieldName.length;\n                count = bp + offset - start - 1;\n            }\n\n            if (!exp && count < 20) {\n                value = ((float) intVal) / power;\n                if (negative) {\n                    value = -value;\n                }\n            } else {\n                String text = this.subString(start, count);\n                value = Float.parseFloat(text);\n            }\n        } else if (chLocal == 'n' && charAt(bp + offset) == 'u' && charAt(bp + offset + 1) == 'l' && charAt(bp + offset + 2) == 'l') {\n            matchStat = VALUE_NULL;\n            value = 0;\n            offset += 3;\n            chLocal = charAt(bp + offset++);\n\n            if (quote && chLocal == '\"') {\n                chLocal = charAt(bp + offset++);\n            }\n\n            for (;;) {\n                if (chLocal == ',') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.COMMA;\n                    return value;\n                } else if (chLocal == '}') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.RBRACE;\n                    return value;\n                } else if (isWhitespace(chLocal)) {\n                    chLocal = charAt(bp + offset++);\n                    continue;\n                }\n                break;\n            }\n            matchStat = NOT_MATCH;\n            return 0;\n        } else {\n            matchStat = NOT_MATCH;\n            return 0;\n        }\n\n        if (chLocal == ',') {\n            bp += offset;\n            this.ch = this.charAt(bp);\n            matchStat = VALUE;\n            token = JSONToken.COMMA;\n            return value;\n        }\n\n        if (chLocal == '}') {\n            chLocal = charAt(bp + (offset++));\n            if (chLocal == ',') {\n                token = JSONToken.COMMA;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == ']') {\n                token = JSONToken.RBRACKET;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == '}') {\n                token = JSONToken.RBRACE;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == EOI) {\n                bp += (offset - 1);\n                token = JSONToken.EOF;\n                ch = EOI;\n            } else {\n                matchStat = NOT_MATCH;\n                return 0;\n            }\n            matchStat = END;\n        } else {\n            matchStat = NOT_MATCH;\n            return 0;\n        }\n\n        return value;\n    }\n",
        "patched_function": "    public final float scanFieldFloat(char[] fieldName) {\n        matchStat = UNKNOWN;\n\n        if (!charArrayCompare(fieldName)) {\n            matchStat = NOT_MATCH_NAME;\n            return 0;\n        }\n\n        int offset = fieldName.length;\n        char chLocal = charAt(bp + (offset++));\n\n        final boolean quote = chLocal == '\"';\n        if (quote) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        boolean negative = chLocal == '-';\n        if (negative) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        float value;\n        if (chLocal >= '0' && chLocal <= '9') {\n            int intVal = chLocal - '0';\n            for (;;) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            int power = 1;\n            boolean small = (chLocal == '.');\n            if (small) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    power = 10;\n                    for (;;) {\n                        chLocal = charAt(bp + (offset++));\n                        if (chLocal >= '0' && chLocal <= '9') {\n                            intVal = intVal * 10 + (chLocal - '0');\n                            power *= 10;\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                } else {\n                    matchStat = NOT_MATCH;\n                    return 0;\n                }\n            }\n\n            boolean exp = chLocal == 'e' || chLocal == 'E';\n            if (exp) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal == '+' || chLocal == '-') {\n                    chLocal = charAt(bp + (offset++));\n                }\n                for (;;) {\n                    if (chLocal >= '0' && chLocal <= '9') {\n                        chLocal = charAt(bp + (offset++));\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            int start, count;\n            if (quote) {\n                if (chLocal != '\"') {\n                    matchStat = NOT_MATCH;\n                    return 0;\n                } else {\n                    chLocal = charAt(bp + (offset++));\n                }\n                start = bp + fieldName.length + 1;\n                count = bp + offset - start - 2;\n            } else {\n                start = bp + fieldName.length;\n                count = bp + offset - start - 1;\n            }\n\n            if (!exp && count < 18) {\n                value = ((float) intVal) / power;\n                if (negative) {\n                    value = -value;\n                }\n            } else {\n                String text = this.subString(start, count);\n                value = Float.parseFloat(text);\n            }\n        } else if (chLocal == 'n' && charAt(bp + offset) == 'u' && charAt(bp + offset + 1) == 'l' && charAt(bp + offset + 2) == 'l') {\n            matchStat = VALUE_NULL;\n            value = 0;\n            offset += 3;\n            chLocal = charAt(bp + offset++);\n\n            if (quote && chLocal == '\"') {\n                chLocal = charAt(bp + offset++);\n            }\n\n            for (;;) {\n                if (chLocal == ',') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.COMMA;\n                    return value;\n                } else if (chLocal == '}') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.RBRACE;\n                    return value;\n                } else if (isWhitespace(chLocal)) {\n                    chLocal = charAt(bp + offset++);\n                    continue;\n                }\n                break;\n            }\n            matchStat = NOT_MATCH;\n            return 0;\n        } else {\n            matchStat = NOT_MATCH;\n            return 0;\n        }\n\n        if (chLocal == ',') {\n            bp += offset;\n            this.ch = this.charAt(bp);\n            matchStat = VALUE;\n            token = JSONToken.COMMA;\n            return value;\n        }\n\n        if (chLocal == '}') {\n            chLocal = charAt(bp + (offset++));\n            if (chLocal == ',') {\n                token = JSONToken.COMMA;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == ']') {\n                token = JSONToken.RBRACKET;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == '}') {\n                token = JSONToken.RBRACE;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == EOI) {\n                bp += (offset - 1);\n                token = JSONToken.EOF;\n                ch = EOI;\n            } else {\n                matchStat = NOT_MATCH;\n                return 0;\n            }\n            matchStat = END;\n        } else {\n            matchStat = NOT_MATCH;\n            return 0;\n        }\n\n        return value;\n    }"
    },
    "46": {
        "buggy_function": "        Object parseArrayAccessFilter(boolean acceptBracket) {\n            if (acceptBracket) {\n                accept('[');\n            }\n\n            boolean predicateFlag = false;\n            int lparanCount = 0;\n\n            if (ch == '?') {\n                next();\n                accept('(');\n                lparanCount++;\n                while (ch == '(') {\n                    next();\n                    lparanCount++;\n                }\n                predicateFlag = true;\n            }\n\n            //\n\n            if (predicateFlag\n                    || IOUtils.firstIdentifier(ch)\n                    || Character.isJavaIdentifierStart(ch)\n                    || ch == '\\\\'\n                    || ch == '@') {\n                boolean self = false;\n                if (ch == '@') {\n                    next();\n                    accept('.');\n                    self = true;\n                }\n                String propertyName = readName();\n\n                skipWhitespace();\n\n                if (predicateFlag && ch == ')') {\n                    next();\n\n                    Filter filter = new NotNullSegement(propertyName);\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n                    return filter;\n                }\n\n                if (acceptBracket && ch == ']') {\n                    next();\n                    Filter filter = new NotNullSegement(propertyName);\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    accept(')');\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n                    return filter;\n                }\n\n                Operator op = readOp();\n\n                skipWhitespace();\n\n                if (op == Operator.BETWEEN || op == Operator.NOT_BETWEEN) {\n                    final boolean not = (op == Operator.NOT_BETWEEN);\n\n                    Object startValue = readValue();\n\n                    String name = readName();\n\n                    if (!\"and\".equalsIgnoreCase(name)) {\n                        throw new JSONPathException(path);\n                    }\n\n                    Object endValue = readValue();\n\n                    if (startValue == null || endValue == null) {\n                        throw new JSONPathException(path);\n                    }\n\n                    if (isInt(startValue.getClass()) && isInt(endValue.getClass())) {\n                        Filter filter = new IntBetweenSegement(propertyName\n                                , TypeUtils.longExtractValue((Number) startValue)\n                                , TypeUtils.longExtractValue((Number) endValue)\n                                , not);\n                        return filter;\n                    }\n\n                    throw new JSONPathException(path);\n                }\n\n                if (op == Operator.IN || op == Operator.NOT_IN) {\n                    final boolean not = (op == Operator.NOT_IN);\n                    accept('(');\n\n                    List<Object> valueList = new JSONArray();\n                    {\n                        Object value = readValue();\n                        valueList.add(value);\n\n                        for (;;) {\n                            skipWhitespace();\n                            if (ch != ',') {\n                                break;\n                            }\n                            next();\n\n                            value = readValue();\n                            valueList.add(value);\n                        }\n                    }\n\n                    boolean isInt = true;\n                    boolean isIntObj = true;\n                    boolean isString = true;\n                    for (Object item : valueList) {\n                        if (item == null) {\n                            if (isInt) {\n                                isInt = false;\n                            }\n                            continue;\n                        }\n\n                        Class<?> clazz = item.getClass();\n                        if (isInt && !(clazz == Byte.class || clazz == Short.class || clazz == Integer.class\n                                       || clazz == Long.class)) {\n                            isInt = false;\n                            isIntObj = false;\n                        }\n\n                        if (isString && clazz != String.class) {\n                            isString = false;\n                        }\n                    }\n\n                    if (valueList.size() == 1 && valueList.get(0) == null) {\n                        Filter filter;\n                        if (not) {\n                            filter = new NotNullSegement(propertyName);\n                        } else {\n                            filter = new NullSegement(propertyName);\n                        }\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isInt) {\n                        if (valueList.size() == 1) {\n                            long value = TypeUtils.longExtractValue((Number) valueList.get(0));\n                            Operator intOp = not ? Operator.NE : Operator.EQ;\n                            Filter filter = new IntOpSegement(propertyName, value, intOp);\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n\n                            accept(')');\n                            if (predicateFlag) {\n                                accept(')');\n                            }\n\n                            if (acceptBracket) {\n                                accept(']');\n                            }\n\n                            return filter;\n                        }\n\n                        long[] values = new long[valueList.size()];\n                        for (int i = 0; i < values.length; ++i) {\n                            values[i] = TypeUtils.longExtractValue((Number) valueList.get(i));\n                        }\n\n                        Filter filter = new IntInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isString) {\n                        if (valueList.size() == 1) {\n                            String value = (String) valueList.get(0);\n\n                            Operator intOp = not ? Operator.NE : Operator.EQ;\n                            Filter filter = new StringOpSegement(propertyName, value, intOp);\n\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n\n                            accept(')');\n                            if (predicateFlag) {\n                                accept(')');\n                            }\n\n                            if (acceptBracket) {\n                                accept(']');\n                            }\n\n                            return filter;\n                        }\n\n                        String[] values = new String[valueList.size()];\n                        valueList.toArray(values);\n\n                        Filter filter = new StringInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isIntObj) {\n                        Long[] values = new Long[valueList.size()];\n                        for (int i = 0; i < values.length; ++i) {\n                            Number item = (Number) valueList.get(i);\n                            if (item != null) {\n                                values[i] = TypeUtils.longExtractValue(item);\n                            }\n                        }\n\n                        Filter filter = new IntObjInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    throw new UnsupportedOperationException();\n                }\n\n                if (ch == '\\'' || ch == '\"') {\n                    String strValue = readString();\n\n                    Filter filter = null;\n                    if (op == Operator.RLIKE) {\n                        filter = new RlikeSegement(propertyName, strValue, false);\n                    } else if (op == Operator.NOT_RLIKE) {\n                        filter = new RlikeSegement(propertyName, strValue, true);\n                    } else  if (op == Operator.LIKE || op == Operator.NOT_LIKE) {\n                        while (strValue.indexOf(\"%%\") != -1) {\n                            strValue = strValue.replaceAll(\"%%\", \"%\");\n                        }\n\n                        final boolean not = (op == Operator.NOT_LIKE);\n\n                        int p0 = strValue.indexOf('%');\n                        if (p0 == -1) {\n                            if (op == Operator.LIKE) {\n                                op = Operator.EQ;\n                            } else {\n                                op = Operator.NE;\n                            }\n                            filter = new StringOpSegement(propertyName, strValue, op);\n                        } else {\n                            String[] items = strValue.split(\"%\");\n\n                            String startsWithValue = null;\n                            String endsWithValue = null;\n                            String[] containsValues = null;\n                            if (p0 == 0) {\n                                if (strValue.charAt(strValue.length() - 1) == '%') {\n                                    containsValues = new String[items.length - 1];\n                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                } else {\n                                    endsWithValue = items[items.length - 1];\n                                    if (items.length > 2) {\n                                        containsValues = new String[items.length - 2];\n                                        System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                    }\n                                }\n                            } else if (strValue.charAt(strValue.length() - 1) == '%') {\n                                if (items.length == 1) {\n                                    startsWithValue = items[0];\n                                } else {\n                                    containsValues = items;\n                                }\n                            } else {\n                                if (items.length == 1) {\n                                    startsWithValue = items[0];\n                                } else if (items.length == 2) {\n                                    startsWithValue = items[0];\n                                    endsWithValue = items[1];\n                                } else {\n                                    startsWithValue = items[0];\n                                    endsWithValue = items[items.length - 1];\n                                    containsValues = new String[items.length - 2];\n                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                }\n                            }\n\n                            filter = new MatchSegement(propertyName, startsWithValue, endsWithValue,\n                                    containsValues, not);\n                        }\n                    } else {\n                        filter = new StringOpSegement(propertyName, strValue, op);\n                    }\n\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n                    \n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                }\n\n                if (isDigitFirst(ch)) {\n                    long value = readLongValue();\n                    double doubleValue = 0D;\n                    if (ch == '.') {\n                        doubleValue = readDoubleValue(value);\n                        \n                    }\n\n                    Filter filter;\n\n                    if (doubleValue == 0) {\n                        filter = new IntOpSegement(propertyName, value, op);\n                    } else {\n                        filter = new DoubleOpSegement(propertyName, doubleValue, op);\n                    }\n\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (lparanCount > 1 && ch == ')') {\n                        next();\n                        lparanCount--;\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (predicateFlag) {\n                        lparanCount--;\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                } else if (ch == '$') {\n                    Segment segment = readSegement();\n                    RefOpSegement filter = new RefOpSegement(propertyName, segment, op);\n                    hasRefSegment = true;\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                } else if (ch == '/') {\n                    int flags = 0;\n                    StringBuilder regBuf = new StringBuilder();\n                    for (;;) {\n                        next();\n                        if (ch == '/') {\n                            next();\n                            if (ch == 'i') {\n                                next();\n                                flags |= Pattern.CASE_INSENSITIVE;\n                            }\n                            break;\n                        }\n\n                        if (ch == '\\\\') {\n                            next();\n                            regBuf.append(ch);\n                        } else {\n                            regBuf.append(ch);\n                        }\n                    }\n\n                    Pattern pattern = Pattern.compile(regBuf.toString(), flags);\n                    RegMatchSegement filter = new RegMatchSegement(propertyName, pattern, op);\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                }\n\n                if (ch == 'n') {\n                    String name = readName();\n                    if (\"null\".equals(name)) {\n                        Filter filter = null;\n                        if (op == Operator.EQ) {\n                            filter = new NullSegement(propertyName);\n                        } else if (op == Operator.NE) {\n                            filter = new NotNullSegement(propertyName);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                } else if (ch == 't') {\n                    String name = readName();\n                    \n                    if (\"true\".equals(name)) {\n                        Filter filter = null;\n\n                        if (op == Operator.EQ) {\n                            filter = new ValueSegment(propertyName, Boolean.TRUE, true);\n                        } else if (op == Operator.NE) {\n                            filter = new ValueSegment(propertyName, Boolean.TRUE, false);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                } else if (ch == 'f') {\n                    String name = readName();\n                    \n                    if (\"false\".equals(name)) {\n                        Filter filter = null;\n\n                        if (op == Operator.EQ) {\n                            filter = new ValueSegment(propertyName, Boolean.FALSE, true);\n                        } else if (op == Operator.NE) {\n                            filter = new ValueSegment(propertyName, Boolean.FALSE, false);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                }\n\n                throw new UnsupportedOperationException();\n                // accept(')');\n            }\n\n            int start = pos - 1;\n            char startCh = ch;\n            while (ch != ']' && ch != '/' && !isEOF()) {\n                if (ch == '.' //\n                        && (!predicateFlag) // \n                        && !predicateFlag\n                        && startCh != '\\''\n                ) {\n                    break;\n                }\n                \n                if (ch == '\\\\') {\n                    next();\n                }\n                next();\n            }\n            \n            int end;\n            if (acceptBracket) {\n                end = pos - 1;\n            } else {\n                if (ch == '/' || ch == '.') {\n                    end = pos - 1;\n                } else {\n                    end = pos;\n                }\n            }\n            \n            String text = path.substring(start, end);\n            \n            if (text.indexOf(\"\\\\.\") != -1) {\n                String propName;\n                if (startCh == '\\'' && text.length() > 2 && text.charAt(text.length() - 1) == startCh) {\n                    propName = text.substring(1, text.length() - 1);\n                } else {\n                    propName = text.replaceAll(\"\\\\\\\\\\\\.\", \"\\\\.\");\n                    if (propName.indexOf(\"\\\\-\") != -1) {\n                        propName = propName.replaceAll(\"\\\\\\\\-\", \"-\");\n                    }\n                }\n\n                if (predicateFlag) {\n                    accept(')');\n                }\n\n                return new PropertySegment(propName, false);\n            }\n\n            Segment segment = buildArraySegement(text);\n\n            if (acceptBracket && !isEOF()) {\n                accept(']');\n            }\n\n            return segment;\n        }\n",
        "patched_function": "        Object parseArrayAccessFilter(boolean acceptBracket) {\n            if (acceptBracket) {\n                accept('[');\n            }\n\n            boolean predicateFlag = false;\n            int lparanCount = 0;\n\n            if (ch == '?') {\n                next();\n                accept('(');\n                lparanCount++;\n                while (ch == '(') {\n                    next();\n                    lparanCount++;\n                }\n                predicateFlag = true;\n            }\n\n            //\n\n            if (predicateFlag\n                    || IOUtils.firstIdentifier(ch)\n                    || Character.isJavaIdentifierStart(ch)\n                    || ch == '\\\\'\n                    || ch == '@') {\n                boolean self = false;\n                if (ch == '@') {\n                    next();\n                    accept('.');\n                    self = true;\n                }\n                String propertyName = readName();\n\n                skipWhitespace();\n\n                if (predicateFlag && ch == ')') {\n                    next();\n\n                    Filter filter = new NotNullSegement(propertyName);\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n                    return filter;\n                }\n\n                if (acceptBracket && ch == ']') {\n                    next();\n                    Filter filter = new NotNullSegement(propertyName);\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    accept(')');\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n                    return filter;\n                }\n\n                Operator op = readOp();\n\n                skipWhitespace();\n\n                if (op == Operator.BETWEEN || op == Operator.NOT_BETWEEN) {\n                    final boolean not = (op == Operator.NOT_BETWEEN);\n\n                    Object startValue = readValue();\n\n                    String name = readName();\n\n                    if (!\"and\".equalsIgnoreCase(name)) {\n                        throw new JSONPathException(path);\n                    }\n\n                    Object endValue = readValue();\n\n                    if (startValue == null || endValue == null) {\n                        throw new JSONPathException(path);\n                    }\n\n                    if (isInt(startValue.getClass()) && isInt(endValue.getClass())) {\n                        Filter filter = new IntBetweenSegement(propertyName\n                                , TypeUtils.longExtractValue((Number) startValue)\n                                , TypeUtils.longExtractValue((Number) endValue)\n                                , not);\n                        return filter;\n                    }\n\n                    throw new JSONPathException(path);\n                }\n\n                if (op == Operator.IN || op == Operator.NOT_IN) {\n                    final boolean not = (op == Operator.NOT_IN);\n                    accept('(');\n\n                    List<Object> valueList = new JSONArray();\n                    {\n                        Object value = readValue();\n                        valueList.add(value);\n\n                        for (;;) {\n                            skipWhitespace();\n                            if (ch != ',') {\n                                break;\n                            }\n                            next();\n\n                            value = readValue();\n                            valueList.add(value);\n                        }\n                    }\n\n                    boolean isInt = true;\n                    boolean isIntObj = true;\n                    boolean isString = true;\n                    for (Object item : valueList) {\n                        if (item == null) {\n                            if (isInt) {\n                                isInt = false;\n                            }\n                            continue;\n                        }\n\n                        Class<?> clazz = item.getClass();\n                        if (isInt && !(clazz == Byte.class || clazz == Short.class || clazz == Integer.class\n                                       || clazz == Long.class)) {\n                            isInt = false;\n                            isIntObj = false;\n                        }\n\n                        if (isString && clazz != String.class) {\n                            isString = false;\n                        }\n                    }\n\n                    if (valueList.size() == 1 && valueList.get(0) == null) {\n                        Filter filter;\n                        if (not) {\n                            filter = new NotNullSegement(propertyName);\n                        } else {\n                            filter = new NullSegement(propertyName);\n                        }\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isInt) {\n                        if (valueList.size() == 1) {\n                            long value = TypeUtils.longExtractValue((Number) valueList.get(0));\n                            Operator intOp = not ? Operator.NE : Operator.EQ;\n                            Filter filter = new IntOpSegement(propertyName, value, intOp);\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n\n                            accept(')');\n                            if (predicateFlag) {\n                                accept(')');\n                            }\n\n                            if (acceptBracket) {\n                                accept(']');\n                            }\n\n                            return filter;\n                        }\n\n                        long[] values = new long[valueList.size()];\n                        for (int i = 0; i < values.length; ++i) {\n                            values[i] = TypeUtils.longExtractValue((Number) valueList.get(i));\n                        }\n\n                        Filter filter = new IntInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isString) {\n                        if (valueList.size() == 1) {\n                            String value = (String) valueList.get(0);\n\n                            Operator intOp = not ? Operator.NE : Operator.EQ;\n                            Filter filter = new StringOpSegement(propertyName, value, intOp);\n\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n\n                            accept(')');\n                            if (predicateFlag) {\n                                accept(')');\n                            }\n\n                            if (acceptBracket) {\n                                accept(']');\n                            }\n\n                            return filter;\n                        }\n\n                        String[] values = new String[valueList.size()];\n                        valueList.toArray(values);\n\n                        Filter filter = new StringInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isIntObj) {\n                        Long[] values = new Long[valueList.size()];\n                        for (int i = 0; i < values.length; ++i) {\n                            Number item = (Number) valueList.get(i);\n                            if (item != null) {\n                                values[i] = TypeUtils.longExtractValue(item);\n                            }\n                        }\n\n                        Filter filter = new IntObjInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    throw new UnsupportedOperationException();\n                }\n\n                if (ch == '\\'' || ch == '\"') {\n                    String strValue = readString();\n\n                    Filter filter = null;\n                    if (op == Operator.RLIKE) {\n                        filter = new RlikeSegement(propertyName, strValue, false);\n                    } else if (op == Operator.NOT_RLIKE) {\n                        filter = new RlikeSegement(propertyName, strValue, true);\n                    } else  if (op == Operator.LIKE || op == Operator.NOT_LIKE) {\n                        while (strValue.indexOf(\"%%\") != -1) {\n                            strValue = strValue.replaceAll(\"%%\", \"%\");\n                        }\n\n                        final boolean not = (op == Operator.NOT_LIKE);\n\n                        int p0 = strValue.indexOf('%');\n                        if (p0 == -1) {\n                            if (op == Operator.LIKE) {\n                                op = Operator.EQ;\n                            } else {\n                                op = Operator.NE;\n                            }\n                            filter = new StringOpSegement(propertyName, strValue, op);\n                        } else {\n                            String[] items = strValue.split(\"%\");\n\n                            String startsWithValue = null;\n                            String endsWithValue = null;\n                            String[] containsValues = null;\n                            if (p0 == 0) {\n                                if (strValue.charAt(strValue.length() - 1) == '%') {\n                                    containsValues = new String[items.length - 1];\n                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                } else {\n                                    endsWithValue = items[items.length - 1];\n                                    if (items.length > 2) {\n                                        containsValues = new String[items.length - 2];\n                                        System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                    }\n                                }\n                            } else if (strValue.charAt(strValue.length() - 1) == '%') {\n                                if (items.length == 1) {\n                                    startsWithValue = items[0];\n                                } else {\n                                    containsValues = items;\n                                }\n                            } else {\n                                if (items.length == 1) {\n                                    startsWithValue = items[0];\n                                } else if (items.length == 2) {\n                                    startsWithValue = items[0];\n                                    endsWithValue = items[1];\n                                } else {\n                                    startsWithValue = items[0];\n                                    endsWithValue = items[items.length - 1];\n                                    containsValues = new String[items.length - 2];\n                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                }\n                            }\n\n                            filter = new MatchSegement(propertyName, startsWithValue, endsWithValue,\n                                    containsValues, not);\n                        }\n                    } else {\n                        filter = new StringOpSegement(propertyName, strValue, op);\n                    }\n\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n                    \n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                }\n\n                if (isDigitFirst(ch)) {\n                    long value = readLongValue();\n                    double doubleValue = 0D;\n                    if (ch == '.') {\n                        doubleValue = readDoubleValue(value);\n                        \n                    }\n\n                    Filter filter;\n\n                    if (doubleValue == 0) {\n                        filter = new IntOpSegement(propertyName, value, op);\n                    } else {\n                        filter = new DoubleOpSegement(propertyName, doubleValue, op);\n                    }\n\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (lparanCount > 1 && ch == ')') {\n                        next();\n                        lparanCount--;\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (predicateFlag) {\n                        lparanCount--;\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                } else if (ch == '$') {\n                    Segment segment = readSegement();\n                    RefOpSegement filter = new RefOpSegement(propertyName, segment, op);\n                    hasRefSegment = true;\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                } else if (ch == '/') {\n                    int flags = 0;\n                    StringBuilder regBuf = new StringBuilder();\n                    for (;;) {\n                        next();\n                        if (ch == '/') {\n                            next();\n                            if (ch == 'i') {\n                                next();\n                                flags |= Pattern.CASE_INSENSITIVE;\n                            }\n                            break;\n                        }\n\n                        if (ch == '\\\\') {\n                            next();\n                            regBuf.append(ch);\n                        } else {\n                            regBuf.append(ch);\n                        }\n                    }\n\n                    Pattern pattern = Pattern.compile(regBuf.toString(), flags);\n                    RegMatchSegement filter = new RegMatchSegement(propertyName, pattern, op);\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                }\n\n                if (ch == 'n') {\n                    String name = readName();\n                    if (\"null\".equals(name)) {\n                        Filter filter = null;\n                        if (op == Operator.EQ) {\n                            filter = new NullSegement(propertyName);\n                        } else if (op == Operator.NE) {\n                            filter = new NotNullSegement(propertyName);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                } else if (ch == 't') {\n                    String name = readName();\n                    \n                    if (\"true\".equals(name)) {\n                        Filter filter = null;\n\n                        if (op == Operator.EQ) {\n                            filter = new ValueSegment(propertyName, Boolean.TRUE, true);\n                        } else if (op == Operator.NE) {\n                            filter = new ValueSegment(propertyName, Boolean.TRUE, false);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                } else if (ch == 'f') {\n                    String name = readName();\n                    \n                    if (\"false\".equals(name)) {\n                        Filter filter = null;\n\n                        if (op == Operator.EQ) {\n                            filter = new ValueSegment(propertyName, Boolean.FALSE, true);\n                        } else if (op == Operator.NE) {\n                            filter = new ValueSegment(propertyName, Boolean.FALSE, false);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                }\n\n                throw new UnsupportedOperationException();\n                // accept(')');\n            }\n\n            int start = pos - 1;\n            char startCh = ch;\n            while (ch != ']' && ch != '/' && !isEOF()) {\n                if (ch == '.' //\n                        && (!predicateFlag) // \n                        && !predicateFlag\n                        && startCh != '\\''\n                ) {\n                    break;\n                }\n                \n                if (ch == '\\\\') {\n                    next();\n                }\n                next();\n            }\n            \n            int end;\n            if (acceptBracket) {\n                end = pos - 1;\n            } else {\n                if (ch == '/' || ch == '.') {\n                    end = pos - 1;\n                } else {\n                    end = pos;\n                }\n            }\n            \n            String text = path.substring(start, end);\n\n            if (text.indexOf(\"\\\\@\") != -1) {\n                text = text.replaceAll(\"\\\\\\\\@\", \"@\");\n            }\n            \n            if (text.indexOf(\"\\\\.\") != -1) {\n                String propName;\n                if (startCh == '\\'' && text.length() > 2 && text.charAt(text.length() - 1) == startCh) {\n                    propName = text.substring(1, text.length() - 1);\n                } else {\n                    propName = text.replaceAll(\"\\\\\\\\\\\\.\", \"\\\\.\");\n                    if (propName.indexOf(\"\\\\-\") != -1) {\n                        propName = propName.replaceAll(\"\\\\\\\\-\", \"-\");\n                    }\n                }\n\n                if (predicateFlag) {\n                    accept(')');\n                }\n\n                return new PropertySegment(propName, false);\n            }\n\n            Segment segment = buildArraySegement(text);\n\n            if (acceptBracket && !isEOF()) {\n                accept(']');\n            }\n\n            return segment;\n        }"
    },
    "47": {
        "buggy_function": "    public Object createInstance(Map<String, Object> map, ParserConfig config) //\n                                                                               throws IllegalArgumentException,\n                                                                               IllegalAccessException,\n                                                                               InvocationTargetException {\n        Object object = null;\n        \n        if (beanInfo.creatorConstructor == null && beanInfo.factoryMethod == null) {\n            object = createInstance(null, clazz);\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser == null) {\n                    continue;\n                }\n\n                final FieldInfo fieldInfo = fieldDeser.fieldInfo;\n                Field field = fieldDeser.fieldInfo.field;\n                Type paramType = fieldInfo.fieldType;\n\n                if (fieldInfo.declaringClass != null\n                        && fieldInfo.getAnnotation() != null\n                        && fieldInfo.getAnnotation().deserializeUsing() != Void.class\n                        && fieldInfo.fieldClass.isInstance(value)) {\n                    DefaultJSONParser parser = new DefaultJSONParser(JSON.toJSONString(value));\n                    fieldDeser.parseField(parser, object, paramType, null);\n                    continue;\n                }\n\n                if (field != null) {\n                    Class fieldType = field.getType();\n                    if (fieldType == boolean.class) {\n                        if (value == Boolean.FALSE) {\n                            field.setBoolean(object, false);\n                            continue;\n                        }\n\n                        if (value == Boolean.TRUE) {\n                            field.setBoolean(object, true);\n                            continue;\n                        }\n                    } else if (fieldType == int.class) {\n                        if (value instanceof Number) {\n                            field.setInt(object, ((Number) value).intValue());\n                            continue;\n                        }\n                    } else if (fieldType == long.class) {\n                        if (value instanceof Number) {\n                            field.setLong(object, ((Number) value).longValue());\n                            continue;\n                        }\n                    } else if (fieldType == float.class) {\n                        if (value instanceof Number) {\n                            field.setFloat(object, ((Number) value).floatValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            float floatValue;\n                            if (strVal.length() <= 10) {\n                                floatValue = TypeUtils.parseFloat(strVal);\n                            } else {\n                                floatValue = Float.parseFloat(strVal);\n                            }\n\n                            field.setFloat(object, floatValue);\n                            continue;\n                        }\n                    } else if (fieldType == double.class) {\n                        if (value instanceof Number) {\n                            field.setDouble(object, ((Number) value).doubleValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            double doubleValue;\n                            if (strVal.length() <= 10) {\n                                doubleValue = TypeUtils.parseDouble(strVal);\n                            } else {\n                                doubleValue = Double.parseDouble(strVal);\n                            }\n\n                            field.setDouble(object, doubleValue);\n                            continue;\n                        }\n                    } else if (value != null && paramType == value.getClass()) {\n                        field.set(object, value);\n                        continue;\n                    }\n                }\n\n                String format = fieldInfo.format;\n                if (format != null && paramType == Date.class) {\n                    value = TypeUtils.castToDate(value, format);\n                } else if (format != null && (paramType instanceof Class) && (((Class) paramType).getName().equals(\"java.time.LocalDateTime\"))) {\n                    value = TypeUtils.castToLocalDateTime(value, format);\n                } else {\n                    if (paramType instanceof ParameterizedType) {\n                        value = TypeUtils.cast(value, (ParameterizedType) paramType, config);\n                    } else {\n                        value = TypeUtils.cast(value, paramType, config);\n                    }\n                }\n\n                fieldDeser.setValue(object, value);\n            }\n\n            if (beanInfo.buildMethod != null) {\n                Object builtObj;\n                try {\n                    builtObj = beanInfo.buildMethod.invoke(object);\n                } catch (Exception e) {\n                    throw new JSONException(\"build object error\", e);\n                }\n\n                return builtObj;\n            }\n\n            return object;\n        }\n\n        \n        FieldInfo[] fieldInfoList = beanInfo.fields;\n        int size = fieldInfoList.length;\n        Object[] params = new Object[size];\n        Map<String, Integer> missFields = null;\n        for (int i = 0; i < size; ++i) {\n            FieldInfo fieldInfo = fieldInfoList[i];\n            Object param = map.get(fieldInfo.name);\n\n            if (param == null) {\n                Class<?> fieldClass = fieldInfo.fieldClass;\n                if (fieldClass == int.class) {\n                    param = 0;\n                } else if (fieldClass == long.class) {\n                    param = 0L;\n                } else if (fieldClass == short.class) {\n                    param = Short.valueOf((short) 0);\n                } else if (fieldClass == byte.class) {\n                    param = Byte.valueOf((byte) 0);\n                } else if (fieldClass == float.class) {\n                    param = Float.valueOf(0);\n                } else if (fieldClass == double.class) {\n                    param = Double.valueOf(0);\n                } else if (fieldClass == char.class) {\n                    param = '0';\n                } else if (fieldClass == boolean.class) {\n                    param = false;\n                }\n                if (missFields == null) {\n                    missFields = new HashMap<String, Integer>();\n                }\n                missFields.put(fieldInfo.name, i);\n            }\n            params[i] = param;\n        }\n\n        if (missFields != null) {\n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser != null) {\n                    Integer index = missFields.get(fieldDeser.fieldInfo.name);\n                    if (index != null) {\n                        params[index] = value;\n                    }\n                }\n            }\n        }\n\n        if (beanInfo.creatorConstructor != null) {\n            boolean hasNull = false;\n            if (beanInfo.kotlin) {\n                for (int i = 0; i < params.length; i++) {\n                    if (params[i] == null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                        FieldInfo fieldInfo = beanInfo.fields[i];\n                        if (fieldInfo.fieldClass == String.class) {\n                            hasNull = true;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            if (hasNull && beanInfo.kotlinDefaultConstructor != null) {\n                try {\n                    object = beanInfo.kotlinDefaultConstructor.newInstance();\n\n                    for (int i = 0; i < params.length; i++) {\n                        final Object param = params[i];\n                        if (param != null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                            FieldInfo fieldInfo = beanInfo.fields[i];\n                            fieldInfo.set(object, param);\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            } else {\n                try {\n                    object = beanInfo.creatorConstructor.newInstance(params);\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            }\n        } else if (beanInfo.factoryMethod != null) {\n            try {\n                object = beanInfo.factoryMethod.invoke(null, params);\n            } catch (Exception e) {\n                throw new JSONException(\"create factory method error, \" + beanInfo.factoryMethod.toString(), e);\n            }\n        }\n        \n        return object;\n    }\n",
        "patched_function": "    public Object createInstance(Map<String, Object> map, ParserConfig config) //\n                                                                               throws IllegalArgumentException,\n                                                                               IllegalAccessException,\n                                                                               InvocationTargetException {\n        Object object = null;\n        \n        if (beanInfo.creatorConstructor == null && beanInfo.factoryMethod == null) {\n            object = createInstance(null, clazz);\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser == null) {\n                    continue;\n                }\n\n                final FieldInfo fieldInfo = fieldDeser.fieldInfo;\n                Field field = fieldDeser.fieldInfo.field;\n                Type paramType = fieldInfo.fieldType;\n\n                if (fieldInfo.declaringClass != null\n                        && fieldInfo.getAnnotation() != null\n                        && fieldInfo.getAnnotation().deserializeUsing() != Void.class\n                        && fieldInfo.fieldClass.isInstance(value)) {\n                    DefaultJSONParser parser = new DefaultJSONParser(JSON.toJSONString(value));\n                    fieldDeser.parseField(parser, object, paramType, null);\n                    continue;\n                }\n\n                if (field != null && fieldInfo.method == null) {\n                    Class fieldType = field.getType();\n                    if (fieldType == boolean.class) {\n                        if (value == Boolean.FALSE) {\n                            field.setBoolean(object, false);\n                            continue;\n                        }\n\n                        if (value == Boolean.TRUE) {\n                            field.setBoolean(object, true);\n                            continue;\n                        }\n                    } else if (fieldType == int.class) {\n                        if (value instanceof Number) {\n                            field.setInt(object, ((Number) value).intValue());\n                            continue;\n                        }\n                    } else if (fieldType == long.class) {\n                        if (value instanceof Number) {\n                            field.setLong(object, ((Number) value).longValue());\n                            continue;\n                        }\n                    } else if (fieldType == float.class) {\n                        if (value instanceof Number) {\n                            field.setFloat(object, ((Number) value).floatValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            float floatValue;\n                            if (strVal.length() <= 10) {\n                                floatValue = TypeUtils.parseFloat(strVal);\n                            } else {\n                                floatValue = Float.parseFloat(strVal);\n                            }\n\n                            field.setFloat(object, floatValue);\n                            continue;\n                        }\n                    } else if (fieldType == double.class) {\n                        if (value instanceof Number) {\n                            field.setDouble(object, ((Number) value).doubleValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            double doubleValue;\n                            if (strVal.length() <= 10) {\n                                doubleValue = TypeUtils.parseDouble(strVal);\n                            } else {\n                                doubleValue = Double.parseDouble(strVal);\n                            }\n\n                            field.setDouble(object, doubleValue);\n                            continue;\n                        }\n                    } else if (value != null && paramType == value.getClass()) {\n                        field.set(object, value);\n                        continue;\n                    }\n                }\n\n                String format = fieldInfo.format;\n                if (format != null && paramType == Date.class) {\n                    value = TypeUtils.castToDate(value, format);\n                } else if (format != null && (paramType instanceof Class) && (((Class) paramType).getName().equals(\"java.time.LocalDateTime\"))) {\n                    value = TypeUtils.castToLocalDateTime(value, format);\n                } else {\n                    if (paramType instanceof ParameterizedType) {\n                        value = TypeUtils.cast(value, (ParameterizedType) paramType, config);\n                    } else {\n                        value = TypeUtils.cast(value, paramType, config);\n                    }\n                }\n\n                fieldDeser.setValue(object, value);\n            }\n\n            if (beanInfo.buildMethod != null) {\n                Object builtObj;\n                try {\n                    builtObj = beanInfo.buildMethod.invoke(object);\n                } catch (Exception e) {\n                    throw new JSONException(\"build object error\", e);\n                }\n\n                return builtObj;\n            }\n\n            return object;\n        }\n\n        \n        FieldInfo[] fieldInfoList = beanInfo.fields;\n        int size = fieldInfoList.length;\n        Object[] params = new Object[size];\n        Map<String, Integer> missFields = null;\n        for (int i = 0; i < size; ++i) {\n            FieldInfo fieldInfo = fieldInfoList[i];\n            Object param = map.get(fieldInfo.name);\n\n            if (param == null) {\n                Class<?> fieldClass = fieldInfo.fieldClass;\n                if (fieldClass == int.class) {\n                    param = 0;\n                } else if (fieldClass == long.class) {\n                    param = 0L;\n                } else if (fieldClass == short.class) {\n                    param = Short.valueOf((short) 0);\n                } else if (fieldClass == byte.class) {\n                    param = Byte.valueOf((byte) 0);\n                } else if (fieldClass == float.class) {\n                    param = Float.valueOf(0);\n                } else if (fieldClass == double.class) {\n                    param = Double.valueOf(0);\n                } else if (fieldClass == char.class) {\n                    param = '0';\n                } else if (fieldClass == boolean.class) {\n                    param = false;\n                }\n                if (missFields == null) {\n                    missFields = new HashMap<String, Integer>();\n                }\n                missFields.put(fieldInfo.name, i);\n            }\n            params[i] = param;\n        }\n\n        if (missFields != null) {\n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser != null) {\n                    Integer index = missFields.get(fieldDeser.fieldInfo.name);\n                    if (index != null) {\n                        params[index] = value;\n                    }\n                }\n            }\n        }\n\n        if (beanInfo.creatorConstructor != null) {\n            boolean hasNull = false;\n            if (beanInfo.kotlin) {\n                for (int i = 0; i < params.length; i++) {\n                    if (params[i] == null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                        FieldInfo fieldInfo = beanInfo.fields[i];\n                        if (fieldInfo.fieldClass == String.class) {\n                            hasNull = true;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            if (hasNull && beanInfo.kotlinDefaultConstructor != null) {\n                try {\n                    object = beanInfo.kotlinDefaultConstructor.newInstance();\n\n                    for (int i = 0; i < params.length; i++) {\n                        final Object param = params[i];\n                        if (param != null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                            FieldInfo fieldInfo = beanInfo.fields[i];\n                            fieldInfo.set(object, param);\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            } else {\n                try {\n                    object = beanInfo.creatorConstructor.newInstance(params);\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            }\n        } else if (beanInfo.factoryMethod != null) {\n            try {\n                object = beanInfo.factoryMethod.invoke(null, params);\n            } catch (Exception e) {\n                throw new JSONException(\"create factory method error, \" + beanInfo.factoryMethod.toString(), e);\n            }\n        }\n        \n        return object;\n    }"
    },
    "48": {
        "buggy_function": "    protected Object getVariable(Frame frame, LexicalScope block, ASTIdentifier identifier) {\n        int symbol = identifier.getSymbol();\n        // if we have a symbol, we have a scope thus a frame\n        if (options.isLexicalShade() && identifier.isShaded()) {\n            return undefinedVariable(identifier, identifier.getName());\n        }\n        if (symbol >= 0) {\n            if (frame.has(symbol)) {\n                Object value = frame.get(symbol);\n                if (value != Scope.UNDEFINED) {\n                    return value;\n                }\n            }\n        }\n        String name = identifier.getName();\n        Object value = context.get(name);\n        if (value == null\n            && !(identifier.jjtGetParent() instanceof ASTReference)\n            && !(context.has(name))) {\n                return isSafe()\n                    ? null\n                    : unsolvableVariable(identifier, name, true); // undefined\n        }\n        return value;\n    }\n",
        "patched_function": "    protected Object getVariable(Frame frame, LexicalScope block, ASTIdentifier identifier) {\n        int symbol = identifier.getSymbol();\n        // if we have a symbol, we have a scope thus a frame\n        if (options.isLexicalShade() && identifier.isShaded()) {\n            return undefinedVariable(identifier, identifier.getName());\n        }\n        if (symbol >= 0) {\n            if (frame.has(symbol)) {\n                Object value = frame.get(symbol);\n                if (value != Scope.UNDEFINED) {\n                    return value;\n                }\n            }\n        }\n        String name = identifier.getName();\n        Object value = context.get(name);\n        if (value == null\n            && !(identifier.jjtGetParent() instanceof ASTReference)\n            && !(context.has(name))) {\n                return unsolvableVariable(identifier, name, true); // undefined\n        }\n        return value;\n    }"
    },
    "52": {
        "buggy_function": "  @Override\n  public void update(final Sketch sketchIn) { //Only valid for theta Sketches using SerVer = 3\n    //UNION Empty Rule: AND the empty states.\n\n    if ((sketchIn == null) || sketchIn.isEmpty()) {\n      //null and empty is interpreted as (Theta = 1.0, count = 0, empty = T).  Nothing changes\n      return;\n    }\n    //sketchIn is valid and not empty\n    Util.checkSeedHashes(seedHash_, sketchIn.getSeedHash());\n    Sketch.checkSketchAndMemoryFlags(sketchIn);\n\n    unionThetaLong_ = min(unionThetaLong_, sketchIn.getThetaLong()); //Theta rule\n    unionEmpty_ = unionEmpty_ && sketchIn.isEmpty();\n    final int curCountIn = sketchIn.getRetainedEntries(true);\n    if (curCountIn > 0) {\n      if (sketchIn.isOrdered()) { //Only true if Compact. Use early stop\n        //Ordered, thus compact\n        if (sketchIn.hasMemory()) {\n          final Memory skMem = ((CompactSketch) sketchIn).getMemory();\n          final int preambleLongs = skMem.getByte(PREAMBLE_LONGS_BYTE) & 0X3F;\n          for (int i = 0; i < curCountIn; i++ ) {\n            final int offsetBytes = (preambleLongs + i) << 3;\n            final long hashIn = skMem.getLong(offsetBytes);\n            if (hashIn >= unionThetaLong_) { break; } // \"early stop\"\n            gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          }\n        }\n        else { //sketchIn is on the Java Heap or has array\n          final long[] cacheIn = sketchIn.getCache(); //not a copy!\n          for (int i = 0; i < curCountIn; i++ ) {\n            final long hashIn = cacheIn[i];\n            if (hashIn >= unionThetaLong_) { break; } // \"early stop\"\n            gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          }\n        }\n      } //End ordered, compact\n      else { //either not-ordered compact or Hash Table form. A HT may have dirty values.\n        final long[] cacheIn = sketchIn.getCache(); //if off-heap this will be a copy\n        final int arrLongs = cacheIn.length;\n        for (int i = 0, c = 0; (i < arrLongs) && (c < curCountIn); i++ ) {\n          final long hashIn = cacheIn[i];\n          if ((hashIn <= 0L) || (hashIn >= unionThetaLong_)) { continue; } //rejects dirty values\n          gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          c++; //insures against invalid state inside the incoming sketch\n        }\n      }\n    }\n    unionThetaLong_ = min(unionThetaLong_, gadget_.getThetaLong()); //Theta rule with gadget\n  }\n",
        "patched_function": "  @Override\n  public void update(final Sketch sketchIn) { //Only valid for theta Sketches using SerVer = 3\n    //UNION Empty Rule: AND the empty states.\n\n    if ((sketchIn == null) || sketchIn.isEmpty()) {\n      //null and empty is interpreted as (Theta = 1.0, count = 0, empty = T).  Nothing changes\n      return;\n    }\n    //sketchIn is valid and not empty\n    Util.checkSeedHashes(seedHash_, sketchIn.getSeedHash());\n    Sketch.checkSketchAndMemoryFlags(sketchIn);\n\n    unionThetaLong_ = min(unionThetaLong_, sketchIn.getThetaLong()); //Theta rule\n    unionEmpty_ = unionEmpty_ && sketchIn.isEmpty();\n    final int curCountIn = sketchIn.getRetainedEntries(true);\n    if (curCountIn > 0) {\n      if (sketchIn.isOrdered()) { //Only true if Compact. Use early stop\n        //Ordered, thus compact\n        if (sketchIn.hasMemory()) {\n          final Memory skMem = ((CompactSketch) sketchIn).getMemory();\n          final int preambleLongs = skMem.getByte(PREAMBLE_LONGS_BYTE) & 0X3F;\n          for (int i = 0; i < curCountIn; i++ ) {\n            final int offsetBytes = (preambleLongs + i) << 3;\n            final long hashIn = skMem.getLong(offsetBytes);\n            if (hashIn >= unionThetaLong_) { break; } // \"early stop\"\n            gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          }\n        }\n        else { //sketchIn is on the Java Heap or has array\n          final long[] cacheIn = sketchIn.getCache(); //not a copy!\n          for (int i = 0; i < curCountIn; i++ ) {\n            final long hashIn = cacheIn[i];\n            if (hashIn >= unionThetaLong_) { break; } // \"early stop\"\n            gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          }\n        }\n      } //End ordered, compact\n      else { //either not-ordered compact or Hash Table form. A HT may have dirty values.\n        final long[] cacheIn = sketchIn.getCache(); //if off-heap this will be a copy\n        final int arrLongs = cacheIn.length;\n        for (int i = 0, c = 0; (i < arrLongs) && (c < curCountIn); i++ ) {\n          final long hashIn = cacheIn[i];\n          if ((hashIn <= 0L) || (hashIn >= unionThetaLong_)) { continue; } //rejects dirty values\n          gadget_.hashUpdate(hashIn); //backdoor update, hash function is bypassed\n          c++; //insures against invalid state inside the incoming sketch\n        }\n      }\n    }\n    unionThetaLong_ = min(unionThetaLong_, gadget_.getThetaLong()); //Theta rule with gadget\n    if (gadget_.hasMemory()) {\n      final WritableMemory wmem = (WritableMemory)gadget_.getMemory();\n      PreambleUtil.insertUnionThetaLong(wmem, unionThetaLong_);\n      if (unionEmpty_) {\n        PreambleUtil.setEmpty(wmem);\n      } else {\n        PreambleUtil.clearEmpty(wmem);\n      }\n    }\n  }"
    },
    "54": {
        "buggy_function": "\tprivate <T> void fillOutputRow(T[] row) {\n\t\tif (!columnReorderingEnabled && row.length > outputRow.length) {\n\t\t\toutputRow = Arrays.copyOf(outputRow, row.length);\n\t\t}\n\t\tif (indexesToWrite.length < row.length) {\n\t\t\tfor (int i = 0; i < indexesToWrite.length; i++) {\n\t\t\t\toutputRow[indexesToWrite[i]] = row[indexesToWrite[i]];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < row.length && i < indexesToWrite.length; i++) {\n\t\t\t\tif (indexesToWrite[i] != -1) {\n\t\t\t\t\toutputRow[indexesToWrite[i]] = row[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
        "patched_function": "\tprivate <T> void fillOutputRow(T[] row) {\n\t\tif (!columnReorderingEnabled && row.length > outputRow.length) {\n\t\t\toutputRow = Arrays.copyOf(outputRow, row.length);\n\t\t}\n\t\tif (indexesToWrite.length < row.length) {\n\t\t\tfor (int i = 0; i < indexesToWrite.length; i++) {\n\t\t\t\toutputRow[i] = row[indexesToWrite[i]];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < row.length && i < indexesToWrite.length; i++) {\n\t\t\t\tif (indexesToWrite[i] != -1) {\n\t\t\t\t\toutputRow[indexesToWrite[i]] = row[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
    },
    "55": {
        "buggy_function": "\t@Override\n\tpublic void execute(char[] characters, int length) {\n\n\t\tSet<Character> allSymbols = new HashSet<Character>();\n\t\tMap<Character, Integer> symbols = new HashMap<Character, Integer>();\n\t\tMap<Character, Integer> escape = new HashMap<Character, Integer>();\n\t\tList<Map<Character, Integer>> symbolsPerRow = new ArrayList<Map<Character, Integer>>();\n\n\t\tint doubleQuoteCount = 0;\n\t\tint singleQuoteCount = 0;\n\n\t\tint i;\n\t\tchar inQuote = '\\0';\n\t\tboolean afterNewLine = true;\n\t\tfor (i = 0; i < length; i++) {\n\n\t\t\tchar ch = characters[i];\n\n\t\t\tif (afterNewLine && ch == comment) {\n\t\t\t\twhile (++i < length) {\n\t\t\t\t\tch = characters[i];\n\t\t\t\t\tif (ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) {\n\t\t\t\t\t\tif (ch == '\\r' && i + 1 < characters.length && characters[i + 1] == '\\n') {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ch == '\"' || ch == '\\'') {\n\t\t\t\tif (inQuote == ch) { //closing quotes (potentially)\n\t\t\t\t\tif (ch == '\"') {\n\t\t\t\t\t\tdoubleQuoteCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsingleQuoteCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\t\tchar next = characters[i + 1];\n\t\t\t\t\t\tif (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\\n' && next != '\\r')) { //no special characters after quote, might be escaping\n\t\t\t\t\t\t\t//special character before (potentially) closing quote, might be an escape\n\t\t\t\t\t\t\tchar prev = characters[i - 1];\n\t\t\t\t\t\t\tif (!Character.isLetterOrDigit(prev) && prev != '\\n' && prev != '\\r') {\n\t\t\t\t\t\t\t\tincrement(escape, prev);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tinQuote = '\\0';\n\t\t\t\t} else if (inQuote == '\\0') {\n\t\t\t\t\tchar prev = '\\0';\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (prev <= ' ' && --j >= 0) {\n\t\t\t\t\t\tprev = characters[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j < 0 || !Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\tinQuote = ch;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inQuote != '\\0') { //keep looping until the quote is closed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tafterNewLine = false;\n\n\t\t\tif (isSymbol(ch)) { //counts all symbols. Skips letters and digits\n\t\t\t\tallSymbols.add(ch);\n\t\t\t\tincrement(symbols, ch);\n\t\t\t} else if ((ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) && symbols.size() > 0) { //got a newline and collected some symbols? Good!\n\t\t\t\tafterNewLine = true;\n\t\t\t\tsymbolsPerRow.add(symbols);\n\t\t\t\tif (symbolsPerRow.size() == MAX_ROW_SAMPLES) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsymbols = new HashMap<Character, Integer>();\n\t\t\t}\n\t\t}\n\n\t\tif (symbols.size() > 0 && length < characters.length) {\n\t\t\tsymbolsPerRow.add(symbols);\n\t\t}\n\n\t\tif (length >= characters.length && i >= length && symbolsPerRow.size() > 1) { // if got to the end of the buffer, discard last row. It's probably incomplete anyway.\n\t\t\tsymbolsPerRow.remove(symbolsPerRow.size() - 1);\n\t\t}\n\n\t\tMap<Character, Integer> totals = calculateTotals(symbolsPerRow);\n\n\t\tMap<Character, Integer> sums = new HashMap<Character, Integer>();\n\t\tSet<Character> toRemove = new HashSet<Character>();\n\n\t\t//combines the number of symbols found in each row and sums the difference.\n\t\tfor (Map<Character, Integer> previous : symbolsPerRow) {\n\t\t\tfor (Map<Character, Integer> current : symbolsPerRow) {\n\t\t\t\tfor (Character symbol : allSymbols) {\n\t\t\t\t\tInteger previousCount = previous.get(symbol);\n\t\t\t\t\tInteger currentCount = current.get(symbol);\n\n\t\t\t\t\tif (previousCount == null && currentCount == null) { // got a symbol that does not appear in all rows? Discard it.\n\t\t\t\t\t\ttoRemove.add(symbol);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (previousCount == null || currentCount == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tincrement(sums, symbol, Math.abs(previousCount - currentCount)); // we expect to always get 0 or close to 0 here, so the symbol occurs in all rows\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsums.keySet().removeAll(toRemove);\n\n\t\tif (allowedDelimiters.length > 0) {\n\t\t\tSet<Character> toRetain = new HashSet<Character>();\n\t\t\tfor (char c : allowedDelimiters) {\n\t\t\t\ttoRetain.add(c);\n\t\t\t}\n\t\t\tsums.keySet().retainAll(toRetain);\n\t\t}\n\n\t\tchar delimiterMax = max(sums, totals, suggestedDelimiter);\n\t\tchar delimiterMin = min(sums, totals, suggestedDelimiter);\n\n\t\tchar delimiter;\n\t\tout:\n\t\tif (delimiterMax != delimiterMin) {\n\t\t\tif (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\n\t\t\tfor (char c : allowedDelimiters) {\n\t\t\t\tif (c == delimiterMin) {\n\t\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\t\tbreak out;\n\t\t\t\t} else if (c == delimiterMax) {\n\t\t\t\t\tdelimiter = delimiterMax;\n\t\t\t\t\tbreak out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (totals.get(delimiterMin) > totals.get(delimiterMax)) {\n\t\t\t\tdelimiter = delimiterMin;\n\t\t\t\tbreak out;\n\t\t\t}\n\t\t\tdelimiter = delimiterMax;\n\t\t} else {\n\t\t\tdelimiter = delimiterMax;\n\t\t}\n\n\t\tchar quote;\n\t\tif(doubleQuoteCount == 0 && singleQuoteCount == 0){\n\t\t\tquote = suggestedQuote;\n\t\t} else {\n\t\t\tquote = doubleQuoteCount >= singleQuoteCount ? '\"' : '\\'';\n\t\t}\n\n\t\tescape.remove(delimiter);\n\t\tchar quoteEscape = doubleQuoteCount == 0 && singleQuoteCount == 0 ? suggestedQuoteEscape : max(escape, totals, quote);\n\t\tapply(delimiter, quote, quoteEscape);\n\t}\n",
        "patched_function": "\t@Override\n\tpublic void execute(char[] characters, int length) {\n\n\t\tSet<Character> allSymbols = new HashSet<Character>();\n\t\tMap<Character, Integer> symbols = new HashMap<Character, Integer>();\n\t\tMap<Character, Integer> escape = new HashMap<Character, Integer>();\n\t\tList<Map<Character, Integer>> symbolsPerRow = new ArrayList<Map<Character, Integer>>();\n\n\t\tint doubleQuoteCount = 0;\n\t\tint singleQuoteCount = 0;\n\n\t\tint i;\n\t\tchar inQuote = '\\0';\n\t\tboolean afterNewLine = true;\n\t\tfor (i = 0; i < length; i++) {\n\n\t\t\tchar ch = characters[i];\n\n\t\t\tif (afterNewLine && ch == comment) {\n\t\t\t\twhile (++i < length) {\n\t\t\t\t\tch = characters[i];\n\t\t\t\t\tif (ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) {\n\t\t\t\t\t\tif (ch == '\\r' && i + 1 < characters.length && characters[i + 1] == '\\n') {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ch == '\"' || ch == '\\'') {\n\t\t\t\tif (inQuote == ch) { //closing quotes (potentially)\n\t\t\t\t\tif (ch == '\"') {\n\t\t\t\t\t\tdoubleQuoteCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsingleQuoteCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\t\tchar next = characters[i + 1];\n\t\t\t\t\t\tif (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\\n' && next != '\\r')) { //no special characters after quote, might be escaping\n\t\t\t\t\t\t\t//special character before (potentially) closing quote, might be an escape\n\t\t\t\t\t\t\tchar prev = characters[i - 1];\n\t\t\t\t\t\t\tif (!Character.isLetterOrDigit(prev) && prev != '\\n' && prev != '\\r') {\n\t\t\t\t\t\t\t\tincrement(escape, prev);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tinQuote = '\\0';\n\t\t\t\t} else if (inQuote == '\\0') {\n\t\t\t\t\tchar prev = '\\0';\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (prev <= ' ' && --j >= 0) {\n\t\t\t\t\t\tprev = characters[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j < 0 || !Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\tinQuote = ch;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inQuote != '\\0') { //keep looping until the quote is closed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tafterNewLine = false;\n\n\t\t\tif (isSymbol(ch)) { //counts all symbols. Skips letters and digits\n\t\t\t\tallSymbols.add(ch);\n\t\t\t\tincrement(symbols, ch);\n\t\t\t} else if ((ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) && symbols.size() > 0) { //got a newline and collected some symbols? Good!\n\t\t\t\tafterNewLine = true;\n\t\t\t\tsymbolsPerRow.add(symbols);\n\t\t\t\tif (symbolsPerRow.size() == MAX_ROW_SAMPLES) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsymbols = new HashMap<Character, Integer>();\n\t\t\t}\n\t\t}\n\n\t\tif (symbols.size() > 0 && length < characters.length) {\n\t\t\tsymbolsPerRow.add(symbols);\n\t\t}\n\n\t\tif (length >= characters.length && i >= length && symbolsPerRow.size() > 1) { // if got to the end of the buffer, discard last row. It's probably incomplete anyway.\n\t\t\tsymbolsPerRow.remove(symbolsPerRow.size() - 1);\n\t\t}\n\n\t\tMap<Character, Integer> totals = calculateTotals(symbolsPerRow);\n\n\t\tMap<Character, Integer> sums = new HashMap<Character, Integer>();\n\t\tSet<Character> toRemove = new HashSet<Character>();\n\n\t\t//combines the number of symbols found in each row and sums the difference.\n\t\tfor (Map<Character, Integer> previous : symbolsPerRow) {\n\t\t\tfor (Map<Character, Integer> current : symbolsPerRow) {\n\t\t\t\tfor (Character symbol : allSymbols) {\n\t\t\t\t\tInteger previousCount = previous.get(symbol);\n\t\t\t\t\tInteger currentCount = current.get(symbol);\n\n\t\t\t\t\tif (previousCount == null && currentCount == null) { // got a symbol that does not appear in all rows? Discard it.\n\t\t\t\t\t\ttoRemove.add(symbol);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (previousCount == null || currentCount == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tincrement(sums, symbol, Math.abs(previousCount - currentCount)); // we expect to always get 0 or close to 0 here, so the symbol occurs in all rows\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toRemove.size() == sums.size()) { //will discard all symbols. Stick with the symbols that showed up more consistently across all rows.\n\t\t\tMap<Character, Integer> lineCount = new HashMap<Character, Integer>();\n\t\t\tfor (i = 0; i < symbolsPerRow.size(); i++) {\n\t\t\t\tfor (Character symbolInRow : symbolsPerRow.get(i).keySet()) {\n\t\t\t\t\tInteger count = lineCount.get(symbolInRow);\n\t\t\t\t\tif (count == null) {\n\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t}\n\t\t\t\t\tlineCount.put(symbolInRow, count + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInteger highestLineCount = null;\n\t\t\tfor (Map.Entry<Character, Integer> e : lineCount.entrySet()) {\n\t\t\t\tif (highestLineCount == null || highestLineCount < e.getValue()) {\n\t\t\t\t\thighestLineCount = e.getValue();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCharacter bestCandidate = null;\n\t\t\tfor (Map.Entry<Character, Integer> e : lineCount.entrySet()) {\n\t\t\t\tif (e.getValue().equals(highestLineCount)) {\n\t\t\t\t\tif (bestCandidate == null) {\n\t\t\t\t\t\tbestCandidate = e.getKey();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// multiple characters can be the delimiter, unable to detect reliably.\n\t\t\t\t\t\tbestCandidate = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bestCandidate != null) {\n\t\t\t\ttoRemove.remove(bestCandidate);\n\t\t\t}\n\t\t}\n\n\t\tsums.keySet().removeAll(toRemove);\n\n\t\tif (allowedDelimiters.length > 0) {\n\t\t\tSet<Character> toRetain = new HashSet<Character>();\n\t\t\tfor (char c : allowedDelimiters) {\n\t\t\t\ttoRetain.add(c);\n\t\t\t}\n\t\t\tsums.keySet().retainAll(toRetain);\n\t\t}\n\n\t\tchar delimiter = pickDelimiter(sums, totals);\n\n\t\tchar quote;\n\t\tif (doubleQuoteCount == 0 && singleQuoteCount == 0) {\n\t\t\tquote = suggestedQuote;\n\t\t} else {\n\t\t\tquote = doubleQuoteCount >= singleQuoteCount ? '\"' : '\\'';\n\t\t}\n\n\t\tescape.remove(delimiter);\n\t\tchar quoteEscape = doubleQuoteCount == 0 && singleQuoteCount == 0 ? suggestedQuoteEscape : max(escape, totals, quote);\n\t\tapply(delimiter, quote, quoteEscape);\n\t}"
    },
    "56": {
        "buggy_function": "    public static boolean containsAnySpecialChars(String str) {\n        if (str.indexOf(PERCENT_CHAR) >= 0) {\n            return true;\n        }\n        for (char c : SPECIAL_CHARS) {\n            if (str.indexOf(c) >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
        "patched_function": "    public static boolean containsAnySpecialChars(String str) {\n        for (char c : SPECIAL_CHARS) {\n            if (str.indexOf(c) >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }"
    },
    "63": {
        "buggy_function": "    private void buildPossibleExpressions(final CronDefinition cronDefinition) {\n        final List<CronParserField> sortedExpression = cronDefinition.getFieldDefinitions().stream()\n                .map(this::toCronParserField)\n                .sorted(CronParserField.createFieldTypeComparator())\n                .collect(Collectors.toList());\n\n        if (lastFieldIsOptional(sortedExpression)) {\n            expressions.put(sortedExpression.size() - 1, new ArrayList<>(sortedExpression.subList(0, sortedExpression.size() - 1)));\n        }\n        expressions.put(sortedExpression.size(), sortedExpression);\n    }\n",
        "patched_function": "    private void buildPossibleExpressions(final CronDefinition cronDefinition) {\n        final List<CronParserField> sortedExpression = cronDefinition.getFieldDefinitions().stream()\n                .map(this::toCronParserField)\n                .sorted(CronParserField.createFieldTypeComparator())\n                .collect(Collectors.toList());\n\n        List<CronParserField> tempExpression = sortedExpression;\n\n        while(lastFieldIsOptional(tempExpression)) {\n            int expressionLength = tempExpression.size() - 1;\n            ArrayList<CronParserField> possibleExpression = new ArrayList<>(tempExpression.subList(0, expressionLength));\n\n            expressions.put(expressionLength, possibleExpression);\n            tempExpression = possibleExpression;\n        }\n\n        expressions.put(sortedExpression.size(), sortedExpression);\n    }"
    },
    "65": {
        "buggy_function": "    public static String lowerCase(final String input) {\n        return input.toLowerCase(Locale.ENGLISH);\n    }\n",
        "patched_function": "    public static String lowerCase(final String input) {\n        return input != null ? input.toLowerCase(Locale.ENGLISH) : \"\";\n    }"
    },
    "66": {
        "buggy_function": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n",
        "patched_function": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }"
    },
    "72": {
        "buggy_function": "    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public final Object parseObject(final Map object, Object fieldName) {\n        final JSONLexer lexer = this.lexer;\n\n        if (lexer.token() == JSONToken.NULL) {\n            lexer.nextToken();\n            return null;\n        }\n\n        if (lexer.token() == JSONToken.RBRACE) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() == JSONToken.LITERAL_STRING && lexer.stringVal().length() == 0) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() != JSONToken.LBRACE && lexer.token() != JSONToken.COMMA) {\n            throw new JSONException(\"syntax error, expect {, actual \" + lexer.tokenName() + \", \" + lexer.info());\n        }\n\n       ParseContext context = this.context;\n        try {\n            Map map = object instanceof JSONObject ? ((JSONObject) object).getInnerMap() : object;\n\n            boolean setContextFlag = false;\n            for (;;) {\n                lexer.skipWhitespace();\n                char ch = lexer.getCurrent();\n                if (lexer.isEnabled(Feature.AllowArbitraryCommas)) {\n                    while (ch == ',') {\n                        lexer.next();\n                        lexer.skipWhitespace();\n                        ch = lexer.getCurrent();\n                    }\n                }\n\n                boolean isObjectKey = false;\n                Object key;\n                if (ch == '\"') {\n                    key = lexer.scanSymbol(symbolTable, '\"');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", name \" + key);\n                    }\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    if (!setContextFlag) {\n                        if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                            context = this.context;\n                        } else {\n                            ParseContext contextR = setContext(object, fieldName);\n                            if (context == null) {\n                                context = contextR;\n                            }\n                            setContextFlag = true;\n                        }\n                    }\n\n                    return object;\n                } else if (ch == '\\'') {\n                    if (!lexer.isEnabled(Feature.AllowSingleQuotes)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbol(symbolTable, '\\'');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos());\n                    }\n                } else if (ch == EOI) {\n                    throw new JSONException(\"syntax error\");\n                } else if (ch == ',') {\n                    throw new JSONException(\"syntax error\");\n                } else if ((ch >= '0' && ch <= '9') || ch == '-') {\n                    lexer.resetStringPosition();\n                    lexer.scanNumber();\n                    try {\n                        if (lexer.token() == JSONToken.LITERAL_INT) {\n                            key = lexer.integerValue();\n                        } else {\n                            key = lexer.decimalValue(true);\n                        }\n                        if (lexer.isEnabled(Feature.NonStringKeyAsString)) {\n                            key = key.toString();\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                } else if (ch == '{' || ch == '[') {\n                    lexer.nextToken();\n                    key = parse();\n                    isObjectKey = true;\n                } else {\n                    if (!lexer.isEnabled(Feature.AllowUnQuotedFieldNames)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbolUnQuoted(symbolTable);\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", actual \" + ch);\n                    }\n                }\n\n                if (!isObjectKey) {\n                    lexer.next();\n                    lexer.skipWhitespace();\n                }\n\n                ch = lexer.getCurrent();\n\n                lexer.resetStringPosition();\n\n                if (key == JSON.DEFAULT_TYPE_KEY\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    String typeName = lexer.scanSymbol(symbolTable, '\"');\n\n                    if (lexer.isEnabled(Feature.IgnoreAutoType)) {\n                        continue;\n                    }\n\n                    Class<?> clazz = null;\n                    if (object != null\n                            && object.getClass().getName().equals(typeName)) {\n                        clazz = object.getClass();\n                    } else {\n\n                        boolean allDigits = true;\n                        for (int i = 0; i < typeName.length(); ++i) {\n                            char c = typeName.charAt(i);\n                            if (c < '0' || c > '9') {\n                                allDigits = false;\n                                break;\n                            }\n                        }\n\n                        if (!allDigits) {\n                            clazz = config.checkAutoType(typeName, null, lexer.getFeatures());\n                        }\n                    }\n\n                    if (clazz == null) {\n                        map.put(JSON.DEFAULT_TYPE_KEY, typeName);\n                        continue;\n                    }\n\n                    lexer.nextToken(JSONToken.COMMA);\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken(JSONToken.COMMA);\n                        try {\n                            Object instance = null;\n                            ObjectDeserializer deserializer = this.config.getDeserializer(clazz);\n                            if (deserializer instanceof JavaBeanDeserializer) {\n                            \tinstance = TypeUtils.cast(object, clazz, this.config);\n                            }\n\n                            if (instance == null) {\n                                if (clazz == Cloneable.class) {\n                                    instance = new HashMap();\n                                } else if (\"java.util.Collections$EmptyMap\".equals(typeName)) {\n                                    instance = Collections.emptyMap();\n                                } else if (\"java.util.Collections$UnmodifiableMap\".equals(typeName)) {\n                                    instance = Collections.unmodifiableMap(new HashMap());\n                                } else {\n                                    instance = clazz.newInstance();\n                                }\n                            }\n\n                            return instance;\n                        } catch (Exception e) {\n                            throw new JSONException(\"create instance error\", e);\n                        }\n                    }\n\n                    this.setResolveStatus(TypeNameRedirect);\n\n                    if (this.context != null\n                            && fieldName != null\n                            && !(fieldName instanceof Integer)\n                            && !(this.context.fieldName instanceof Integer)) {\n                        this.popContext();\n                    }\n\n                    if (object.size() > 0) {\n                        Object newObj = TypeUtils.cast(object, clazz, this.config);\n                        this.setResolveStatus(NONE);\n                        this.parseObject(newObj);\n                        return newObj;\n                    }\n\n                    ObjectDeserializer deserializer = config.getDeserializer(clazz);\n                    Class deserClass = deserializer.getClass();\n                    if (JavaBeanDeserializer.class.isAssignableFrom(deserClass)\n                            && deserClass != JavaBeanDeserializer.class\n                            && deserClass != ThrowableDeserializer.class) {\n                        this.setResolveStatus(NONE);\n                    } else if (deserializer instanceof MapDeserializer) {\n                        this.setResolveStatus(NONE);\n                    }\n                    Object obj = deserializer.deserialze(this, clazz, fieldName);\n                    return obj;\n                }\n\n                if (key == \"$ref\"\n                        && context != null\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    lexer.nextToken(JSONToken.LITERAL_STRING);\n                    if (lexer.token() == JSONToken.LITERAL_STRING) {\n                        String ref = lexer.stringVal();\n                        lexer.nextToken(JSONToken.RBRACE);\n\n                        if (lexer.token() == JSONToken.COMMA) {\n                            map.put(key, ref);\n                            continue;\n                        }\n\n                        Object refValue = null;\n                        if (\"@\".equals(ref)) {\n                            if (this.context != null) {\n                                ParseContext thisContext = this.context;\n                                Object thisObj = thisContext.object;\n                                if (thisObj instanceof Object[] || thisObj instanceof Collection<?>) {\n                                    refValue = thisObj;\n                                } else if (thisContext.parent != null) {\n                                    refValue = thisContext.parent.object;\n                                }\n                            }\n                        } else if (\"..\".equals(ref)) {\n                            if (context.object != null) {\n                                refValue = context.object;\n                            } else {\n                                addResolveTask(new ResolveTask(context, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else if (\"$\".equals(ref)) {\n                            ParseContext rootContext = context;\n                            while (rootContext.parent != null) {\n                                rootContext = rootContext.parent;\n                            }\n\n                            if (rootContext.object != null) {\n                                refValue = rootContext.object;\n                            } else {\n                                addResolveTask(new ResolveTask(rootContext, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else {\n                            addResolveTask(new ResolveTask(context, ref));\n                            setResolveStatus(DefaultJSONParser.NeedToResolve);\n                        }\n\n                        if (lexer.token() != JSONToken.RBRACE) {\n                            throw new JSONException(\"syntax error, \" + lexer.info());\n                        }\n                        lexer.nextToken(JSONToken.COMMA);\n\n                        return refValue;\n                    } else {\n                        throw new JSONException(\"illegal ref, \" + JSONToken.name(lexer.token()));\n                    }\n                }\n\n                if (!setContextFlag) {\n                    if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                        context = this.context;\n                    } else {\n                        ParseContext contextR = setContext(object, fieldName);\n                        if (context == null) {\n                            context = contextR;\n                        }\n                        setContextFlag = true;\n                    }\n                }\n\n                if (object.getClass() == JSONObject.class) {\n                    if (key == null) {\n                        key = \"null\";\n                    }\n                }\n\n                Object value;\n                if (ch == '\"') {\n                    lexer.scanString();\n                    String strValue = lexer.stringVal();\n                    value = strValue;\n\n                    if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {\n                        JSONScanner iso8601Lexer = new JSONScanner(strValue);\n                        if (iso8601Lexer.scanISO8601DateIfMatch()) {\n                            value = iso8601Lexer.getCalendar().getTime();\n                        }\n                        iso8601Lexer.close();\n                    }\n\n                    map.put(key, value);\n                } else if (ch >= '0' && ch <= '9' || ch == '-') {\n                    lexer.scanNumber();\n                    if (lexer.token() == JSONToken.LITERAL_INT) {\n                        value = lexer.integerValue();\n                    } else {\n                        value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal));\n                    }\n\n                    map.put(key, value);\n                } else if (ch == '[') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9android\n                    lexer.nextToken();\n\n                    JSONArray list = new JSONArray();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n//                    if (!parentIsArray) {\n//                        this.setContext(context);\n//                    }\n                    if (fieldName == null) {\n                        this.setContext(context);\n                    }\n\n                    this.parseArray(list, key);\n\n                    if (lexer.isEnabled(Feature.UseObjectArray)) {\n                        value = list.toArray();\n                    } else {\n                        value = list;\n                    }\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error\");\n                    }\n                } else if (ch == '{') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9 Android\n                    lexer.nextToken();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n\n                    Map input;\n                    if (lexer.isEnabled(Feature.CustomMapDeserializer)) {\n                        MapDeserializer mapDeserializer = (MapDeserializer) config.getDeserializer(Map.class);\n\n\n                        input = (lexer.getFeatures() & Feature.OrderedField.mask) != 0\n                                ? mapDeserializer.createMap(Map.class, lexer.getFeatures())\n                                : mapDeserializer.createMap(Map.class);\n                    } else {\n                        input = new JSONObject(lexer.isEnabled(Feature.OrderedField));\n                    }\n                    ParseContext ctxLocal = null;\n\n                    if (!parentIsArray) {\n                        ctxLocal = setContext(context, input, key);\n                    }\n\n                    Object obj = null;\n                    boolean objParsed = false;\n                    if (fieldTypeResolver != null) {\n                        String resolveFieldName = key != null ? key.toString() : null;\n                        Type fieldType = fieldTypeResolver.resolve(object, resolveFieldName);\n                        if (fieldType != null) {\n                            ObjectDeserializer fieldDeser = config.getDeserializer(fieldType);\n                            obj = fieldDeser.deserialze(this, fieldType, key);\n                            objParsed = true;\n                        }\n                    }\n                    if (!objParsed) {\n                        obj = this.parseObject(input, key);\n                    }\n\n                    if (ctxLocal != null && input != obj) {\n                        ctxLocal.object = object;\n                    }\n\n                    if (key != null) {\n                        checkMapResolve(object, key.toString());\n                    }\n\n                    map.put(key, obj);\n\n                    if (parentIsArray) {\n                        //setContext(context, obj, key);\n                        setContext(obj, key);\n                    }\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n\n                        setContext(context);\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        if (parentIsArray) {\n                            this.popContext();\n                        } else {\n                            this.setContext(context);\n                        }\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, \" + lexer.tokenName());\n                    }\n                } else {\n                    lexer.nextToken();\n                    value = parse();\n\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                    }\n                }\n\n                lexer.skipWhitespace();\n                ch = lexer.getCurrent();\n                if (ch == ',') {\n                    lexer.next();\n                    continue;\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    // this.setContext(object, fieldName);\n                    this.setContext(value, key);\n\n                    return object;\n                } else {\n                    throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                }\n\n            }\n        } finally {\n            this.setContext(context);\n        }\n\n    }\n",
        "patched_function": "    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public final Object parseObject(final Map object, Object fieldName) {\n        final JSONLexer lexer = this.lexer;\n\n        if (lexer.token() == JSONToken.NULL) {\n            lexer.nextToken();\n            return null;\n        }\n\n        if (lexer.token() == JSONToken.RBRACE) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() == JSONToken.LITERAL_STRING && lexer.stringVal().length() == 0) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() != JSONToken.LBRACE && lexer.token() != JSONToken.COMMA) {\n            throw new JSONException(\"syntax error, expect {, actual \" + lexer.tokenName() + \", \" + lexer.info());\n        }\n\n       ParseContext context = this.context;\n        try {\n            boolean isJsonObjectMap = object instanceof JSONObject;\n            Map map = isJsonObjectMap ? ((JSONObject) object).getInnerMap() : object;\n\n            boolean setContextFlag = false;\n            for (;;) {\n                lexer.skipWhitespace();\n                char ch = lexer.getCurrent();\n                if (lexer.isEnabled(Feature.AllowArbitraryCommas)) {\n                    while (ch == ',') {\n                        lexer.next();\n                        lexer.skipWhitespace();\n                        ch = lexer.getCurrent();\n                    }\n                }\n\n                boolean isObjectKey = false;\n                Object key;\n                if (ch == '\"') {\n                    key = lexer.scanSymbol(symbolTable, '\"');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", name \" + key);\n                    }\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    if (!setContextFlag) {\n                        if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                            context = this.context;\n                        } else {\n                            ParseContext contextR = setContext(object, fieldName);\n                            if (context == null) {\n                                context = contextR;\n                            }\n                            setContextFlag = true;\n                        }\n                    }\n\n                    return object;\n                } else if (ch == '\\'') {\n                    if (!lexer.isEnabled(Feature.AllowSingleQuotes)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbol(symbolTable, '\\'');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos());\n                    }\n                } else if (ch == EOI) {\n                    throw new JSONException(\"syntax error\");\n                } else if (ch == ',') {\n                    throw new JSONException(\"syntax error\");\n                } else if ((ch >= '0' && ch <= '9') || ch == '-') {\n                    lexer.resetStringPosition();\n                    lexer.scanNumber();\n                    try {\n                        if (lexer.token() == JSONToken.LITERAL_INT) {\n                            key = lexer.integerValue();\n                        } else {\n                            key = lexer.decimalValue(true);\n                        }\n                        if (lexer.isEnabled(Feature.NonStringKeyAsString) || isJsonObjectMap) {\n                            key = key.toString();\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                } else if (ch == '{' || ch == '[') {\n                    lexer.nextToken();\n                    key = parse();\n                    isObjectKey = true;\n                } else {\n                    if (!lexer.isEnabled(Feature.AllowUnQuotedFieldNames)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbolUnQuoted(symbolTable);\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", actual \" + ch);\n                    }\n                }\n\n                if (!isObjectKey) {\n                    lexer.next();\n                    lexer.skipWhitespace();\n                }\n\n                ch = lexer.getCurrent();\n\n                lexer.resetStringPosition();\n\n                if (key == JSON.DEFAULT_TYPE_KEY\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    String typeName = lexer.scanSymbol(symbolTable, '\"');\n\n                    if (lexer.isEnabled(Feature.IgnoreAutoType)) {\n                        continue;\n                    }\n\n                    Class<?> clazz = null;\n                    if (object != null\n                            && object.getClass().getName().equals(typeName)) {\n                        clazz = object.getClass();\n                    } else {\n\n                        boolean allDigits = true;\n                        for (int i = 0; i < typeName.length(); ++i) {\n                            char c = typeName.charAt(i);\n                            if (c < '0' || c > '9') {\n                                allDigits = false;\n                                break;\n                            }\n                        }\n\n                        if (!allDigits) {\n                            clazz = config.checkAutoType(typeName, null, lexer.getFeatures());\n                        }\n                    }\n\n                    if (clazz == null) {\n                        map.put(JSON.DEFAULT_TYPE_KEY, typeName);\n                        continue;\n                    }\n\n                    lexer.nextToken(JSONToken.COMMA);\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken(JSONToken.COMMA);\n                        try {\n                            Object instance = null;\n                            ObjectDeserializer deserializer = this.config.getDeserializer(clazz);\n                            if (deserializer instanceof JavaBeanDeserializer) {\n                            \tinstance = TypeUtils.cast(object, clazz, this.config);\n                            }\n\n                            if (instance == null) {\n                                if (clazz == Cloneable.class) {\n                                    instance = new HashMap();\n                                } else if (\"java.util.Collections$EmptyMap\".equals(typeName)) {\n                                    instance = Collections.emptyMap();\n                                } else if (\"java.util.Collections$UnmodifiableMap\".equals(typeName)) {\n                                    instance = Collections.unmodifiableMap(new HashMap());\n                                } else {\n                                    instance = clazz.newInstance();\n                                }\n                            }\n\n                            return instance;\n                        } catch (Exception e) {\n                            throw new JSONException(\"create instance error\", e);\n                        }\n                    }\n\n                    this.setResolveStatus(TypeNameRedirect);\n\n                    if (this.context != null\n                            && fieldName != null\n                            && !(fieldName instanceof Integer)\n                            && !(this.context.fieldName instanceof Integer)) {\n                        this.popContext();\n                    }\n\n                    if (object.size() > 0) {\n                        Object newObj = TypeUtils.cast(object, clazz, this.config);\n                        this.setResolveStatus(NONE);\n                        this.parseObject(newObj);\n                        return newObj;\n                    }\n\n                    ObjectDeserializer deserializer = config.getDeserializer(clazz);\n                    Class deserClass = deserializer.getClass();\n                    if (JavaBeanDeserializer.class.isAssignableFrom(deserClass)\n                            && deserClass != JavaBeanDeserializer.class\n                            && deserClass != ThrowableDeserializer.class) {\n                        this.setResolveStatus(NONE);\n                    } else if (deserializer instanceof MapDeserializer) {\n                        this.setResolveStatus(NONE);\n                    }\n                    Object obj = deserializer.deserialze(this, clazz, fieldName);\n                    return obj;\n                }\n\n                if (key == \"$ref\"\n                        && context != null\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    lexer.nextToken(JSONToken.LITERAL_STRING);\n                    if (lexer.token() == JSONToken.LITERAL_STRING) {\n                        String ref = lexer.stringVal();\n                        lexer.nextToken(JSONToken.RBRACE);\n\n                        if (lexer.token() == JSONToken.COMMA) {\n                            map.put(key, ref);\n                            continue;\n                        }\n\n                        Object refValue = null;\n                        if (\"@\".equals(ref)) {\n                            if (this.context != null) {\n                                ParseContext thisContext = this.context;\n                                Object thisObj = thisContext.object;\n                                if (thisObj instanceof Object[] || thisObj instanceof Collection<?>) {\n                                    refValue = thisObj;\n                                } else if (thisContext.parent != null) {\n                                    refValue = thisContext.parent.object;\n                                }\n                            }\n                        } else if (\"..\".equals(ref)) {\n                            if (context.object != null) {\n                                refValue = context.object;\n                            } else {\n                                addResolveTask(new ResolveTask(context, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else if (\"$\".equals(ref)) {\n                            ParseContext rootContext = context;\n                            while (rootContext.parent != null) {\n                                rootContext = rootContext.parent;\n                            }\n\n                            if (rootContext.object != null) {\n                                refValue = rootContext.object;\n                            } else {\n                                addResolveTask(new ResolveTask(rootContext, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else {\n                            addResolveTask(new ResolveTask(context, ref));\n                            setResolveStatus(DefaultJSONParser.NeedToResolve);\n                        }\n\n                        if (lexer.token() != JSONToken.RBRACE) {\n                            throw new JSONException(\"syntax error, \" + lexer.info());\n                        }\n                        lexer.nextToken(JSONToken.COMMA);\n\n                        return refValue;\n                    } else {\n                        throw new JSONException(\"illegal ref, \" + JSONToken.name(lexer.token()));\n                    }\n                }\n\n                if (!setContextFlag) {\n                    if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                        context = this.context;\n                    } else {\n                        ParseContext contextR = setContext(object, fieldName);\n                        if (context == null) {\n                            context = contextR;\n                        }\n                        setContextFlag = true;\n                    }\n                }\n\n                if (object.getClass() == JSONObject.class) {\n                    if (key == null) {\n                        key = \"null\";\n                    }\n                }\n\n                Object value;\n                if (ch == '\"') {\n                    lexer.scanString();\n                    String strValue = lexer.stringVal();\n                    value = strValue;\n\n                    if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {\n                        JSONScanner iso8601Lexer = new JSONScanner(strValue);\n                        if (iso8601Lexer.scanISO8601DateIfMatch()) {\n                            value = iso8601Lexer.getCalendar().getTime();\n                        }\n                        iso8601Lexer.close();\n                    }\n\n                    map.put(key, value);\n                } else if (ch >= '0' && ch <= '9' || ch == '-') {\n                    lexer.scanNumber();\n                    if (lexer.token() == JSONToken.LITERAL_INT) {\n                        value = lexer.integerValue();\n                    } else {\n                        value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal));\n                    }\n\n                    map.put(key, value);\n                } else if (ch == '[') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9android\n                    lexer.nextToken();\n\n                    JSONArray list = new JSONArray();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n//                    if (!parentIsArray) {\n//                        this.setContext(context);\n//                    }\n                    if (fieldName == null) {\n                        this.setContext(context);\n                    }\n\n                    this.parseArray(list, key);\n\n                    if (lexer.isEnabled(Feature.UseObjectArray)) {\n                        value = list.toArray();\n                    } else {\n                        value = list;\n                    }\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error\");\n                    }\n                } else if (ch == '{') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9 Android\n                    lexer.nextToken();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n\n                    Map input;\n                    if (lexer.isEnabled(Feature.CustomMapDeserializer)) {\n                        MapDeserializer mapDeserializer = (MapDeserializer) config.getDeserializer(Map.class);\n\n\n                        input = (lexer.getFeatures() & Feature.OrderedField.mask) != 0\n                                ? mapDeserializer.createMap(Map.class, lexer.getFeatures())\n                                : mapDeserializer.createMap(Map.class);\n                    } else {\n                        input = new JSONObject(lexer.isEnabled(Feature.OrderedField));\n                    }\n                    ParseContext ctxLocal = null;\n\n                    if (!parentIsArray) {\n                        ctxLocal = setContext(context, input, key);\n                    }\n\n                    Object obj = null;\n                    boolean objParsed = false;\n                    if (fieldTypeResolver != null) {\n                        String resolveFieldName = key != null ? key.toString() : null;\n                        Type fieldType = fieldTypeResolver.resolve(object, resolveFieldName);\n                        if (fieldType != null) {\n                            ObjectDeserializer fieldDeser = config.getDeserializer(fieldType);\n                            obj = fieldDeser.deserialze(this, fieldType, key);\n                            objParsed = true;\n                        }\n                    }\n                    if (!objParsed) {\n                        obj = this.parseObject(input, key);\n                    }\n\n                    if (ctxLocal != null && input != obj) {\n                        ctxLocal.object = object;\n                    }\n\n                    if (key != null) {\n                        checkMapResolve(object, key.toString());\n                    }\n\n                    map.put(key, obj);\n\n                    if (parentIsArray) {\n                        //setContext(context, obj, key);\n                        setContext(obj, key);\n                    }\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n\n                        setContext(context);\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        if (parentIsArray) {\n                            this.popContext();\n                        } else {\n                            this.setContext(context);\n                        }\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, \" + lexer.tokenName());\n                    }\n                } else {\n                    lexer.nextToken();\n                    value = parse();\n\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                    }\n                }\n\n                lexer.skipWhitespace();\n                ch = lexer.getCurrent();\n                if (ch == ',') {\n                    lexer.next();\n                    continue;\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    // this.setContext(object, fieldName);\n                    this.setContext(value, key);\n\n                    return object;\n                } else {\n                    throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                }\n\n            }\n        } finally {\n            this.setContext(context);\n        }\n\n    }"
    },
    "73": {
        "buggy_function": "    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public final Object parseObject(final Map object, Object fieldName) {\n        final JSONLexer lexer = this.lexer;\n\n        if (lexer.token() == JSONToken.NULL) {\n            lexer.nextToken();\n            return null;\n        }\n\n        if (lexer.token() == JSONToken.RBRACE) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() == JSONToken.LITERAL_STRING && lexer.stringVal().length() == 0) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() != JSONToken.LBRACE && lexer.token() != JSONToken.COMMA) {\n            throw new JSONException(\"syntax error, expect {, actual \" + lexer.tokenName() + \", \" + lexer.info());\n        }\n\n       ParseContext context = this.context;\n        try {\n            boolean isJsonObjectMap = object instanceof JSONObject;\n            Map map = isJsonObjectMap ? ((JSONObject) object).getInnerMap() : object;\n\n            boolean setContextFlag = false;\n            for (;;) {\n                lexer.skipWhitespace();\n                char ch = lexer.getCurrent();\n                if (lexer.isEnabled(Feature.AllowArbitraryCommas)) {\n                    while (ch == ',') {\n                        lexer.next();\n                        lexer.skipWhitespace();\n                        ch = lexer.getCurrent();\n                    }\n                }\n\n                boolean isObjectKey = false;\n                Object key;\n                if (ch == '\"') {\n                    key = lexer.scanSymbol(symbolTable, '\"');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", name \" + key);\n                    }\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    if (!setContextFlag) {\n                        if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                            context = this.context;\n                        } else {\n                            ParseContext contextR = setContext(object, fieldName);\n                            if (context == null) {\n                                context = contextR;\n                            }\n                            setContextFlag = true;\n                        }\n                    }\n\n                    return object;\n                } else if (ch == '\\'') {\n                    if (!lexer.isEnabled(Feature.AllowSingleQuotes)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbol(symbolTable, '\\'');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos());\n                    }\n                } else if (ch == EOI) {\n                    throw new JSONException(\"syntax error\");\n                } else if (ch == ',') {\n                    throw new JSONException(\"syntax error\");\n                } else if ((ch >= '0' && ch <= '9') || ch == '-') {\n                    lexer.resetStringPosition();\n                    lexer.scanNumber();\n                    try {\n                        if (lexer.token() == JSONToken.LITERAL_INT) {\n                            key = lexer.integerValue();\n                        } else {\n                            key = lexer.decimalValue(true);\n                        }\n                        if (lexer.isEnabled(Feature.NonStringKeyAsString) || isJsonObjectMap) {\n                            key = key.toString();\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                } else if (ch == '{' || ch == '[') {\n                    if (objectKeyLevel++ > 512) {\n                        throw new JSONException(\"object key level > 512\");\n                    }\n                    lexer.nextToken();\n                    key = parse();\n                    isObjectKey = true;\n                } else {\n                    if (!lexer.isEnabled(Feature.AllowUnQuotedFieldNames)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbolUnQuoted(symbolTable);\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", actual \" + ch);\n                    }\n                }\n\n                if (!isObjectKey) {\n                    lexer.next();\n                    lexer.skipWhitespace();\n                }\n\n                ch = lexer.getCurrent();\n\n                lexer.resetStringPosition();\n\n                if (key == JSON.DEFAULT_TYPE_KEY\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    String typeName = lexer.scanSymbol(symbolTable, '\"');\n\n                    if (lexer.isEnabled(Feature.IgnoreAutoType)) {\n                        continue;\n                    }\n\n                    Class<?> clazz = null;\n                    if (object != null\n                            && object.getClass().getName().equals(typeName)) {\n                        clazz = object.getClass();\n                    } else {\n\n                        boolean allDigits = true;\n                        for (int i = 0; i < typeName.length(); ++i) {\n                            char c = typeName.charAt(i);\n                            if (c < '0' || c > '9') {\n                                allDigits = false;\n                                break;\n                            }\n                        }\n\n                        if (!allDigits) {\n                            clazz = config.checkAutoType(typeName, null, lexer.getFeatures());\n                        }\n                    }\n\n                    if (clazz == null) {\n                        map.put(JSON.DEFAULT_TYPE_KEY, typeName);\n                        continue;\n                    }\n\n                    lexer.nextToken(JSONToken.COMMA);\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken(JSONToken.COMMA);\n                        try {\n                            Object instance = null;\n                            ObjectDeserializer deserializer = this.config.getDeserializer(clazz);\n                            if (deserializer instanceof JavaBeanDeserializer) {\n                            \tinstance = TypeUtils.cast(object, clazz, this.config);\n                            }\n\n                            if (instance == null) {\n                                if (clazz == Cloneable.class) {\n                                    instance = new HashMap();\n                                } else if (\"java.util.Collections$EmptyMap\".equals(typeName)) {\n                                    instance = Collections.emptyMap();\n                                } else if (\"java.util.Collections$UnmodifiableMap\".equals(typeName)) {\n                                    instance = Collections.unmodifiableMap(new HashMap());\n                                } else {\n                                    instance = clazz.newInstance();\n                                }\n                            }\n\n                            return instance;\n                        } catch (Exception e) {\n                            throw new JSONException(\"create instance error\", e);\n                        }\n                    }\n\n                    this.setResolveStatus(TypeNameRedirect);\n\n                    if (this.context != null\n                            && fieldName != null\n                            && !(fieldName instanceof Integer)\n                            && !(this.context.fieldName instanceof Integer)) {\n                        this.popContext();\n                    }\n\n                    if (object.size() > 0) {\n                        Object newObj = TypeUtils.cast(object, clazz, this.config);\n                        this.setResolveStatus(NONE);\n                        this.parseObject(newObj);\n                        return newObj;\n                    }\n\n                    ObjectDeserializer deserializer = config.getDeserializer(clazz);\n                    Class deserClass = deserializer.getClass();\n                    if (JavaBeanDeserializer.class.isAssignableFrom(deserClass)\n                            && deserClass != JavaBeanDeserializer.class\n                            && deserClass != ThrowableDeserializer.class) {\n                        this.setResolveStatus(NONE);\n                    } else if (deserializer instanceof MapDeserializer) {\n                        this.setResolveStatus(NONE);\n                    }\n                    Object obj = deserializer.deserialze(this, clazz, fieldName);\n                    return obj;\n                }\n\n                if (key == \"$ref\"\n                        && context != null\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    lexer.nextToken(JSONToken.LITERAL_STRING);\n                    if (lexer.token() == JSONToken.LITERAL_STRING) {\n                        String ref = lexer.stringVal();\n                        lexer.nextToken(JSONToken.RBRACE);\n\n                        if (lexer.token() == JSONToken.COMMA) {\n                            map.put(key, ref);\n                            continue;\n                        }\n\n                        Object refValue = null;\n                        if (\"@\".equals(ref)) {\n                            if (this.context != null) {\n                                ParseContext thisContext = this.context;\n                                Object thisObj = thisContext.object;\n                                if (thisObj instanceof Object[] || thisObj instanceof Collection<?>) {\n                                    refValue = thisObj;\n                                } else if (thisContext.parent != null) {\n                                    refValue = thisContext.parent.object;\n                                }\n                            }\n                        } else if (\"..\".equals(ref)) {\n                            if (context.object != null) {\n                                refValue = context.object;\n                            } else {\n                                addResolveTask(new ResolveTask(context, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else if (\"$\".equals(ref)) {\n                            ParseContext rootContext = context;\n                            while (rootContext.parent != null) {\n                                rootContext = rootContext.parent;\n                            }\n\n                            if (rootContext.object != null) {\n                                refValue = rootContext.object;\n                            } else {\n                                addResolveTask(new ResolveTask(rootContext, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else {\n                            addResolveTask(new ResolveTask(context, ref));\n                            setResolveStatus(DefaultJSONParser.NeedToResolve);\n                        }\n\n                        if (lexer.token() != JSONToken.RBRACE) {\n                            throw new JSONException(\"syntax error, \" + lexer.info());\n                        }\n                        lexer.nextToken(JSONToken.COMMA);\n\n                        return refValue;\n                    } else {\n                        throw new JSONException(\"illegal ref, \" + JSONToken.name(lexer.token()));\n                    }\n                }\n\n                if (!setContextFlag) {\n                    if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                        context = this.context;\n                    } else {\n                        ParseContext contextR = setContext(object, fieldName);\n                        if (context == null) {\n                            context = contextR;\n                        }\n                        setContextFlag = true;\n                    }\n                }\n\n                if (object.getClass() == JSONObject.class) {\n                    if (key == null) {\n                        key = \"null\";\n                    }\n                }\n\n                Object value;\n                if (ch == '\"') {\n                    lexer.scanString();\n                    String strValue = lexer.stringVal();\n                    value = strValue;\n\n                    if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {\n                        JSONScanner iso8601Lexer = new JSONScanner(strValue);\n                        if (iso8601Lexer.scanISO8601DateIfMatch()) {\n                            value = iso8601Lexer.getCalendar().getTime();\n                        }\n                        iso8601Lexer.close();\n                    }\n\n                    map.put(key, value);\n                } else if (ch >= '0' && ch <= '9' || ch == '-') {\n                    lexer.scanNumber();\n                    if (lexer.token() == JSONToken.LITERAL_INT) {\n                        value = lexer.integerValue();\n                    } else {\n                        value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal));\n                    }\n\n                    map.put(key, value);\n                } else if (ch == '[') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9android\n                    lexer.nextToken();\n\n                    JSONArray list = new JSONArray();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n//                    if (!parentIsArray) {\n//                        this.setContext(context);\n//                    }\n                    if (fieldName == null) {\n                        this.setContext(context);\n                    }\n\n                    this.parseArray(list, key);\n\n                    if (lexer.isEnabled(Feature.UseObjectArray)) {\n                        value = list.toArray();\n                    } else {\n                        value = list;\n                    }\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error\");\n                    }\n                } else if (ch == '{') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9 Android\n                    lexer.nextToken();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n\n                    Map input;\n                    if (lexer.isEnabled(Feature.CustomMapDeserializer)) {\n                        MapDeserializer mapDeserializer = (MapDeserializer) config.getDeserializer(Map.class);\n\n\n                        input = (lexer.getFeatures() & Feature.OrderedField.mask) != 0\n                                ? mapDeserializer.createMap(Map.class, lexer.getFeatures())\n                                : mapDeserializer.createMap(Map.class);\n                    } else {\n                        input = new JSONObject(lexer.isEnabled(Feature.OrderedField));\n                    }\n                    ParseContext ctxLocal = null;\n\n                    if (!parentIsArray) {\n                        ctxLocal = setContext(context, input, key);\n                    }\n\n                    Object obj = null;\n                    boolean objParsed = false;\n                    if (fieldTypeResolver != null) {\n                        String resolveFieldName = key != null ? key.toString() : null;\n                        Type fieldType = fieldTypeResolver.resolve(object, resolveFieldName);\n                        if (fieldType != null) {\n                            ObjectDeserializer fieldDeser = config.getDeserializer(fieldType);\n                            obj = fieldDeser.deserialze(this, fieldType, key);\n                            objParsed = true;\n                        }\n                    }\n                    if (!objParsed) {\n                        obj = this.parseObject(input, key);\n                    }\n\n                    if (ctxLocal != null && input != obj) {\n                        ctxLocal.object = object;\n                    }\n\n                    if (key != null) {\n                        checkMapResolve(object, key.toString());\n                    }\n\n                    map.put(key, obj);\n\n                    if (parentIsArray) {\n                        //setContext(context, obj, key);\n                        setContext(obj, key);\n                    }\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n\n                        setContext(context);\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        if (parentIsArray) {\n                            this.popContext();\n                        } else {\n                            this.setContext(context);\n                        }\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, \" + lexer.tokenName());\n                    }\n                } else {\n                    lexer.nextToken();\n                    value = parse();\n\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                    }\n                }\n\n                lexer.skipWhitespace();\n                ch = lexer.getCurrent();\n                if (ch == ',') {\n                    lexer.next();\n                    continue;\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    // this.setContext(object, fieldName);\n                    this.setContext(value, key);\n\n                    return object;\n                } else {\n                    throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                }\n\n            }\n        } finally {\n            this.setContext(context);\n        }\n\n    }\n",
        "patched_function": "    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public final Object parseObject(final Map object, Object fieldName) {\n        final JSONLexer lexer = this.lexer;\n\n        if (lexer.token() == JSONToken.NULL) {\n            lexer.nextToken();\n            return null;\n        }\n\n        if (lexer.token() == JSONToken.RBRACE) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() == JSONToken.LITERAL_STRING && lexer.stringVal().length() == 0) {\n            lexer.nextToken();\n            return object;\n        }\n\n        if (lexer.token() != JSONToken.LBRACE && lexer.token() != JSONToken.COMMA) {\n            throw new JSONException(\"syntax error, expect {, actual \" + lexer.tokenName() + \", \" + lexer.info());\n        }\n\n       ParseContext context = this.context;\n        try {\n            boolean isJsonObjectMap = object instanceof JSONObject;\n            Map map = isJsonObjectMap ? ((JSONObject) object).getInnerMap() : object;\n\n            boolean setContextFlag = false;\n            for (;;) {\n                lexer.skipWhitespace();\n                char ch = lexer.getCurrent();\n                if (lexer.isEnabled(Feature.AllowArbitraryCommas)) {\n                    while (ch == ',') {\n                        lexer.next();\n                        lexer.skipWhitespace();\n                        ch = lexer.getCurrent();\n                    }\n                }\n\n                boolean isObjectKey = false;\n                Object key;\n                if (ch == '\"') {\n                    key = lexer.scanSymbol(symbolTable, '\"');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", name \" + key);\n                    }\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    if (!setContextFlag) {\n                        if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                            context = this.context;\n                        } else {\n                            ParseContext contextR = setContext(object, fieldName);\n                            if (context == null) {\n                                context = contextR;\n                            }\n                            setContextFlag = true;\n                        }\n                    }\n\n                    return object;\n                } else if (ch == '\\'') {\n                    if (!lexer.isEnabled(Feature.AllowSingleQuotes)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbol(symbolTable, '\\'');\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos());\n                    }\n                } else if (ch == EOI) {\n                    throw new JSONException(\"syntax error\");\n                } else if (ch == ',') {\n                    throw new JSONException(\"syntax error\");\n                } else if ((ch >= '0' && ch <= '9') || ch == '-') {\n                    lexer.resetStringPosition();\n                    lexer.scanNumber();\n                    try {\n                        if (lexer.token() == JSONToken.LITERAL_INT) {\n                            key = lexer.integerValue();\n                        } else {\n                            key = lexer.decimalValue(true);\n                        }\n                        if (lexer.isEnabled(Feature.NonStringKeyAsString) || isJsonObjectMap) {\n                            key = key.toString();\n                        }\n                    } catch (NumberFormatException e) {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"parse number key error\" + lexer.info());\n                    }\n                } else if (ch == '{' || ch == '[') {\n                    if (objectKeyLevel++ > 512) {\n                        throw new JSONException(\"object key level > 512\");\n                    }\n                    lexer.nextToken();\n                    key = parse();\n                    isObjectKey = true;\n                } else {\n                    if (!lexer.isEnabled(Feature.AllowUnQuotedFieldNames)) {\n                        throw new JSONException(\"syntax error\");\n                    }\n\n                    key = lexer.scanSymbolUnQuoted(symbolTable);\n                    lexer.skipWhitespace();\n                    ch = lexer.getCurrent();\n                    if (ch != ':') {\n                        throw new JSONException(\"expect ':' at \" + lexer.pos() + \", actual \" + ch);\n                    }\n                }\n\n                if (!isObjectKey) {\n                    lexer.next();\n                    lexer.skipWhitespace();\n                }\n\n                ch = lexer.getCurrent();\n\n                lexer.resetStringPosition();\n\n                if (key == JSON.DEFAULT_TYPE_KEY\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    String typeName = lexer.scanSymbol(symbolTable, '\"');\n\n                    if (lexer.isEnabled(Feature.IgnoreAutoType)) {\n                        continue;\n                    }\n\n                    Class<?> clazz = null;\n                    if (object != null\n                            && object.getClass().getName().equals(typeName)) {\n                        clazz = object.getClass();\n                    } else {\n\n                        boolean allDigits = true;\n                        for (int i = 0; i < typeName.length(); ++i) {\n                            char c = typeName.charAt(i);\n                            if (c < '0' || c > '9') {\n                                allDigits = false;\n                                break;\n                            }\n                        }\n\n                        if (!allDigits) {\n                            clazz = config.checkAutoType(typeName, null, lexer.getFeatures());\n                        }\n                    }\n\n                    if (clazz == null) {\n                        map.put(JSON.DEFAULT_TYPE_KEY, typeName);\n                        continue;\n                    }\n\n                    lexer.nextToken(JSONToken.COMMA);\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken(JSONToken.COMMA);\n                        try {\n                            Object instance = null;\n                            ObjectDeserializer deserializer = this.config.getDeserializer(clazz);\n                            if (deserializer instanceof JavaBeanDeserializer) {\n                            \tinstance = TypeUtils.cast(object, clazz, this.config);\n                            }\n\n                            if (instance == null) {\n                                if (clazz == Cloneable.class) {\n                                    instance = new HashMap();\n                                } else if (\"java.util.Collections$EmptyMap\".equals(typeName)) {\n                                    instance = Collections.emptyMap();\n                                } else if (\"java.util.Collections$UnmodifiableMap\".equals(typeName)) {\n                                    instance = Collections.unmodifiableMap(new HashMap());\n                                } else {\n                                    instance = clazz.newInstance();\n                                }\n                            }\n\n                            return instance;\n                        } catch (Exception e) {\n                            throw new JSONException(\"create instance error\", e);\n                        }\n                    }\n\n                    this.setResolveStatus(TypeNameRedirect);\n\n                    if (this.context != null\n                            && fieldName != null\n                            && !(fieldName instanceof Integer)\n                            && !(this.context.fieldName instanceof Integer)) {\n                        this.popContext();\n                    }\n\n                    if (object.size() > 0) {\n                        Object newObj = TypeUtils.cast(object, clazz, this.config);\n                        this.setResolveStatus(NONE);\n                        this.parseObject(newObj);\n                        return newObj;\n                    }\n\n                    ObjectDeserializer deserializer = config.getDeserializer(clazz);\n                    Class deserClass = deserializer.getClass();\n                    if (JavaBeanDeserializer.class.isAssignableFrom(deserClass)\n                            && deserClass != JavaBeanDeserializer.class\n                            && deserClass != ThrowableDeserializer.class) {\n                        this.setResolveStatus(NONE);\n                    } else if (deserializer instanceof MapDeserializer) {\n                        this.setResolveStatus(NONE);\n                    }\n                    Object obj = deserializer.deserialze(this, clazz, fieldName);\n                    return obj;\n                }\n\n                if (key == \"$ref\"\n                        && context != null\n                        && (object == null || object.size() == 0)\n                        && !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {\n                    lexer.nextToken(JSONToken.LITERAL_STRING);\n                    if (lexer.token() == JSONToken.LITERAL_STRING) {\n                        String ref = lexer.stringVal();\n                        lexer.nextToken(JSONToken.RBRACE);\n\n                        if (lexer.token() == JSONToken.COMMA) {\n                            map.put(key, ref);\n                            continue;\n                        }\n\n                        Object refValue = null;\n                        if (\"@\".equals(ref)) {\n                            if (this.context != null) {\n                                ParseContext thisContext = this.context;\n                                Object thisObj = thisContext.object;\n                                if (thisObj instanceof Object[] || thisObj instanceof Collection<?>) {\n                                    refValue = thisObj;\n                                } else if (thisContext.parent != null) {\n                                    refValue = thisContext.parent.object;\n                                }\n                            }\n                        } else if (\"..\".equals(ref)) {\n                            if (context.object != null) {\n                                refValue = context.object;\n                            } else {\n                                addResolveTask(new ResolveTask(context, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else if (\"$\".equals(ref)) {\n                            ParseContext rootContext = context;\n                            while (rootContext.parent != null) {\n                                rootContext = rootContext.parent;\n                            }\n\n                            if (rootContext.object != null) {\n                                refValue = rootContext.object;\n                            } else {\n                                addResolveTask(new ResolveTask(rootContext, ref));\n                                setResolveStatus(DefaultJSONParser.NeedToResolve);\n                            }\n                        } else {\n                            addResolveTask(new ResolveTask(context, ref));\n                            setResolveStatus(DefaultJSONParser.NeedToResolve);\n                        }\n\n                        if (lexer.token() != JSONToken.RBRACE) {\n                            throw new JSONException(\"syntax error, \" + lexer.info());\n                        }\n                        lexer.nextToken(JSONToken.COMMA);\n\n                        return refValue;\n                    } else {\n                        throw new JSONException(\"illegal ref, \" + JSONToken.name(lexer.token()));\n                    }\n                }\n\n                if (!setContextFlag) {\n                    if (this.context != null && fieldName == this.context.fieldName && object == this.context.object) {\n                        context = this.context;\n                    } else {\n                        ParseContext contextR = setContext(object, fieldName);\n                        if (context == null) {\n                            context = contextR;\n                        }\n                        setContextFlag = true;\n                    }\n                }\n\n                if (object.getClass() == JSONObject.class) {\n                    if (key == null) {\n                        key = \"null\";\n                    }\n                }\n\n                Object value;\n                if (ch == '\"') {\n                    lexer.scanString();\n                    String strValue = lexer.stringVal();\n                    value = strValue;\n\n                    if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {\n                        JSONScanner iso8601Lexer = new JSONScanner(strValue);\n                        if (iso8601Lexer.scanISO8601DateIfMatch()) {\n                            value = iso8601Lexer.getCalendar().getTime();\n                        }\n                        iso8601Lexer.close();\n                    }\n\n                    map.put(key, value);\n                } else if (ch >= '0' && ch <= '9' || ch == '-') {\n                    lexer.scanNumber();\n                    if (lexer.token() == JSONToken.LITERAL_INT) {\n                        value = lexer.integerValue();\n                    } else {\n                        value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal));\n                    }\n\n                    map.put(key, value);\n                } else if (ch == '[') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9android\n                    lexer.nextToken();\n\n                    JSONArray list = new JSONArray();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n//                    if (!parentIsArray) {\n//                        this.setContext(context);\n//                    }\n                    if (fieldName == null) {\n                        this.setContext(context);\n                    }\n\n                    this.parseArray(list, key);\n\n                    if (lexer.isEnabled(Feature.UseObjectArray)) {\n                        value = list.toArray();\n                    } else {\n                        value = list;\n                    }\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error\");\n                    }\n                } else if (ch == '{') { // \u51cf\u5c11\u5d4c\u5957\uff0c\u517c\u5bb9 Android\n                    lexer.nextToken();\n\n                    final boolean parentIsArray = fieldName != null && fieldName.getClass() == Integer.class;\n\n                    Map input;\n                    if (lexer.isEnabled(Feature.CustomMapDeserializer)) {\n                        MapDeserializer mapDeserializer = (MapDeserializer) config.getDeserializer(Map.class);\n\n\n                        input = (lexer.getFeatures() & Feature.OrderedField.mask) != 0\n                                ? mapDeserializer.createMap(Map.class, lexer.getFeatures())\n                                : mapDeserializer.createMap(Map.class);\n                    } else {\n                        input = new JSONObject(lexer.isEnabled(Feature.OrderedField));\n                    }\n                    ParseContext ctxLocal = null;\n\n                    if (!parentIsArray) {\n                        ctxLocal = setContext(context, input, key);\n                    }\n\n                    Object obj = null;\n                    boolean objParsed = false;\n                    if (fieldTypeResolver != null) {\n                        String resolveFieldName = key != null ? key.toString() : null;\n                        Type fieldType = fieldTypeResolver.resolve(object, resolveFieldName);\n                        if (fieldType != null) {\n                            ObjectDeserializer fieldDeser = config.getDeserializer(fieldType);\n                            obj = fieldDeser.deserialze(this, fieldType, key);\n                            objParsed = true;\n                        }\n                    }\n                    if (!objParsed) {\n                        obj = this.parseObject(input, key);\n                    }\n\n                    if (ctxLocal != null && input != obj) {\n                        ctxLocal.object = object;\n                    }\n\n                    if (key != null) {\n                        checkMapResolve(object, key.toString());\n                    }\n\n                    map.put(key, obj);\n\n                    if (parentIsArray) {\n                        //setContext(context, obj, key);\n                        setContext(obj, key);\n                    }\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n\n                        setContext(context);\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        if (parentIsArray) {\n                            this.popContext();\n                        } else {\n                            this.setContext(context);\n                        }\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, \" + lexer.tokenName());\n                    }\n                } else {\n                    lexer.nextToken();\n                    value = parse();\n\n                    map.put(key, value);\n\n                    if (lexer.token() == JSONToken.RBRACE) {\n                        lexer.nextToken();\n                        return object;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        continue;\n                    } else {\n                        throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                    }\n                }\n\n                lexer.skipWhitespace();\n                ch = lexer.getCurrent();\n                if (ch == ',') {\n                    lexer.next();\n                    continue;\n                } else if (ch == '}') {\n                    lexer.next();\n                    lexer.resetStringPosition();\n                    lexer.nextToken();\n\n                    // this.setContext(object, fieldName);\n                    this.setContext(value, key);\n\n                    return object;\n                } else {\n                    throw new JSONException(\"syntax error, position at \" + lexer.pos() + \", name \" + key);\n                }\n\n            }\n        } finally {\n            this.setContext(context);\n        }\n\n    }"
    },
    "74": {
        "buggy_function": "    public String scanString(char expectNextChar) {\n        matchStat = UNKNOWN;\n\n        int offset = 0;\n        char chLocal = charAt(bp + (offset++));\n\n        if (chLocal == 'n') {\n            if (charAt(bp + offset) == 'u' && charAt(bp + offset + 1) == 'l' && charAt(bp + offset + 2) == 'l') {\n                offset += 3;\n                chLocal = charAt(bp + (offset++));\n            } else {\n                matchStat = NOT_MATCH;\n                return null;\n            }\n\n            if (chLocal == expectNextChar) {\n                bp += offset;\n                this.ch = this.charAt(bp);\n                matchStat = VALUE;\n                return null;\n            } else {\n                matchStat = NOT_MATCH;\n                return null;\n            }\n        }\n\n        final String strVal;\n        for (;;) {\n            if (chLocal == '\"') {\n                int startIndex = bp + offset;\n                int endIndex = indexOf('\"', startIndex);\n                if (endIndex == -1) {\n                    throw new JSONException(\"unclosed str\");\n                }\n\n                String stringVal = subString(bp + offset, endIndex - startIndex);\n                if (stringVal.indexOf('\\\\') != -1) {\n                    for (; ; ) {\n                        int slashCount = 0;\n                        for (int i = endIndex - 1; i >= 0; --i) {\n                            if (charAt(i) == '\\\\') {\n                                slashCount++;\n                            } else {\n                                break;\n                            }\n                        }\n                        if (slashCount % 2 == 0) {\n                            break;\n                        }\n                        endIndex = indexOf('\"', endIndex + 1);\n                    }\n\n                    int chars_len = endIndex - startIndex;\n                    char[] chars = sub_chars(bp + 1, chars_len);\n\n                    stringVal = readString(chars, chars_len);\n                }\n\n                offset += (endIndex - startIndex + 1);\n                chLocal = charAt(bp + (offset++));\n                strVal = stringVal;\n                break;\n            } else if (isWhitespace(chLocal)) {\n                chLocal = charAt(bp + (offset++));\n                continue;\n            } else {\n                matchStat = NOT_MATCH;\n\n                return stringDefaultValue();\n            }\n        }\n\n        for (;;) {\n            if (chLocal == expectNextChar) {\n                bp += offset;\n                this.ch = charAt(bp);\n                matchStat = VALUE;\n                token = JSONToken.COMMA;\n                return strVal;\n            } else if (isWhitespace(chLocal)) {\n                chLocal = charAt(bp + (offset++));\n                continue;\n            } else {\n                matchStat = NOT_MATCH;\n                return strVal;\n            }\n        }\n    }\n",
        "patched_function": "    public String scanString(char expectNextChar) {\n        matchStat = UNKNOWN;\n\n        int offset = 0;\n        char chLocal = charAt(bp + (offset++));\n\n        if (chLocal == 'n') {\n            if (charAt(bp + offset) == 'u' && charAt(bp + offset + 1) == 'l' && charAt(bp + offset + 2) == 'l') {\n                offset += 3;\n                chLocal = charAt(bp + (offset++));\n            } else {\n                matchStat = NOT_MATCH;\n                return null;\n            }\n\n            if (chLocal == expectNextChar) {\n                bp += offset;\n                this.ch = this.charAt(bp);\n                matchStat = VALUE;\n                return null;\n            } else {\n                matchStat = NOT_MATCH;\n                return null;\n            }\n        }\n\n        final String strVal;\n        for (;;) {\n            if (chLocal == '\"') {\n                int startIndex = bp + offset;\n                int endIndex = indexOf('\"', startIndex);\n                if (endIndex == -1) {\n                    throw new JSONException(\"unclosed str\");\n                }\n\n                String stringVal = subString(bp + offset, endIndex - startIndex);\n                if (stringVal.indexOf('\\\\') != -1) {\n                    for (; ; ) {\n                        int slashCount = 0;\n                        for (int i = endIndex - 1; i >= 0; --i) {\n                            if (charAt(i) == '\\\\') {\n                                slashCount++;\n                            } else {\n                                break;\n                            }\n                        }\n                        if (slashCount % 2 == 0) {\n                            break;\n                        }\n                        endIndex = indexOf('\"', endIndex + 1);\n                    }\n\n                    int chars_len = endIndex - startIndex;\n                    char[] chars = sub_chars(bp + 1, chars_len);\n\n                    stringVal = readString(chars, chars_len);\n                }\n\n                offset += (endIndex - startIndex + 1);\n                chLocal = charAt(bp + (offset++));\n                strVal = stringVal;\n                break;\n            } else if (isWhitespace(chLocal)) {\n                chLocal = charAt(bp + (offset++));\n                continue;\n            } else {\n                matchStat = NOT_MATCH;\n\n                return stringDefaultValue();\n            }\n        }\n\n        for (;;) {\n            if (chLocal == expectNextChar) {\n                bp += offset;\n                this.ch = charAt(bp);\n                matchStat = VALUE;\n                token = JSONToken.COMMA;\n                return strVal;\n            } else if (isWhitespace(chLocal)) {\n                chLocal = charAt(bp + (offset++));\n                continue;\n            } else {\n                if (chLocal == ']') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = NOT_MATCH;\n                }\n                return strVal;\n            }\n        }\n    }"
    },
    "75": {
        "buggy_function": "    public static Type getFieldType(final Class<?> clazz, final Type type, Type fieldType) {\n        if (clazz == null || type == null) {\n            return fieldType;\n        }\n\n        if (fieldType instanceof GenericArrayType) {\n            GenericArrayType genericArrayType = (GenericArrayType) fieldType;\n            Type componentType = genericArrayType.getGenericComponentType();\n            Type componentTypeX = getFieldType(clazz, type, componentType);\n            if (componentType != componentTypeX) {\n                Type fieldTypeX = Array.newInstance(TypeUtils.getClass(componentTypeX), 0).getClass();\n                return fieldTypeX;\n            }\n\n            return fieldType;\n        }\n\n        if (!TypeUtils.isGenericParamType(type)) {\n            return fieldType;\n        }\n\n        if (fieldType instanceof TypeVariable) {\n            ParameterizedType paramType = (ParameterizedType) TypeUtils.getGenericParamType(type);\n            Class<?> parameterizedClass = TypeUtils.getClass(paramType);\n            final TypeVariable<?> typeVar = (TypeVariable<?>) fieldType;\n            \n            TypeVariable<?>[] typeVariables = parameterizedClass.getTypeParameters();\n            for (int i = 0; i < typeVariables.length; ++i) {\n                if (typeVariables[i].getName().equals(typeVar.getName())) {\n                    fieldType = paramType.getActualTypeArguments()[i];\n                    return fieldType;\n                }\n            }\n        }\n\n        if (fieldType instanceof ParameterizedType) {\n            ParameterizedType parameterizedFieldType = (ParameterizedType) fieldType;\n\n            Type[] arguments = parameterizedFieldType.getActualTypeArguments();\n            TypeVariable<?>[] typeVariables = null;\n            ParameterizedType paramType = null;\n            if (type instanceof ParameterizedType) {\n                paramType = (ParameterizedType) type;\n                typeVariables = clazz.getTypeParameters();\n            } else if(clazz.getGenericSuperclass() instanceof ParameterizedType) {\n                paramType = (ParameterizedType) clazz.getGenericSuperclass();\n                typeVariables = clazz.getSuperclass().getTypeParameters();\n            }\n\n            boolean changed = getArgument(arguments, typeVariables, paramType.getActualTypeArguments());\n            if (changed) {\n                fieldType = new ParameterizedTypeImpl(arguments, parameterizedFieldType.getOwnerType(),\n                                                      parameterizedFieldType.getRawType());\n                return fieldType;\n            }\n        }\n\n        return fieldType;\n    }\n",
        "patched_function": "    public static Type getFieldType(final Class<?> clazz, final Type type, Type fieldType) {\n        if (clazz == null || type == null) {\n            return fieldType;\n        }\n\n        if (fieldType instanceof GenericArrayType) {\n            GenericArrayType genericArrayType = (GenericArrayType) fieldType;\n            Type componentType = genericArrayType.getGenericComponentType();\n            Type componentTypeX = getFieldType(clazz, type, componentType);\n            if (componentType != componentTypeX) {\n                Type fieldTypeX = Array.newInstance(TypeUtils.getClass(componentTypeX), 0).getClass();\n                return fieldTypeX;\n            }\n\n            return fieldType;\n        }\n\n        if (!TypeUtils.isGenericParamType(type)) {\n            return fieldType;\n        }\n\n        if (fieldType instanceof TypeVariable) {\n            ParameterizedType paramType = (ParameterizedType) TypeUtils.getGenericParamType(type);\n            Class<?> parameterizedClass = TypeUtils.getClass(paramType);\n            final TypeVariable<?> typeVar = (TypeVariable<?>) fieldType;\n            \n            TypeVariable<?>[] typeVariables = parameterizedClass.getTypeParameters();\n            for (int i = 0; i < typeVariables.length; ++i) {\n                if (typeVariables[i].getName().equals(typeVar.getName())) {\n                    fieldType = paramType.getActualTypeArguments()[i];\n                    return fieldType;\n                }\n            }\n        }\n\n        if (fieldType instanceof ParameterizedType) {\n            ParameterizedType parameterizedFieldType = (ParameterizedType) fieldType;\n\n            Type[] arguments = parameterizedFieldType.getActualTypeArguments();\n            TypeVariable<?>[] typeVariables = type.getClass().getTypeParameters();\n            ParameterizedType paramType = parameterizedFieldType;\n            if (type instanceof ParameterizedType) {\n                paramType = (ParameterizedType) type;\n                typeVariables = clazz.getTypeParameters();\n            } else if(clazz.getGenericSuperclass() instanceof ParameterizedType) {\n                paramType = (ParameterizedType) clazz.getGenericSuperclass();\n                typeVariables = clazz.getSuperclass().getTypeParameters();\n            }\n\n            boolean changed = getArgument(arguments, typeVariables, paramType.getActualTypeArguments());\n            if (changed) {\n                fieldType = new ParameterizedTypeImpl(arguments, parameterizedFieldType.getOwnerType(),\n                                                      parameterizedFieldType.getRawType());\n                return fieldType;\n            }\n        }\n\n        return fieldType;\n    }"
    },
    "76": {
        "buggy_function": "    private static CronDefinition quartz() {\n        return CronDefinitionBuilder.defineCron()\n                .withSeconds().withStrictRange().and()\n                .withMinutes().withStrictRange().and()\n                .withHours().withStrictRange().and()\n                .withDayOfMonth().withValidRange(1, 32).supportsL().supportsW().supportsLW().supportsQuestionMark().withStrictRange().and()\n                .withMonth().withValidRange(1, 13).and()\n                .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsHash().supportsL().supportsQuestionMark().and()\n                .withYear().withValidRange(1970, 2099).withStrictRange().optional().and()\n                .withCronValidation(CronConstraintsFactory.ensureEitherDayOfWeekOrDayOfMonth())\n                .instance();\n    }\n",
        "patched_function": "    private static CronDefinition quartz() {\n        return CronDefinitionBuilder.defineCron()\n                .withSeconds().and()\n                .withMinutes().and()\n                .withHours().and()\n                .withDayOfMonth().withValidRange(1, 32).supportsL().supportsW().supportsLW().supportsQuestionMark().and()\n                .withMonth().withValidRange(1, 13).and()\n                .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsHash().supportsL().supportsQuestionMark().and()\n                .withYear().withValidRange(1970, 2099).withStrictRange().optional().and()\n                .withCronValidation(CronConstraintsFactory.ensureEitherDayOfWeekOrDayOfMonth())\n                .instance();\n    }"
    },
    "77": {
        "buggy_function": "    private static CronDefinition quartz() {\n        return CronDefinitionBuilder.defineCron()\n                .withSeconds().and()\n                .withMinutes().and()\n                .withHours().and()\n                .withDayOfMonth().supportsL().supportsW().supportsLW().supportsQuestionMark().and()\n                .withMonth().and()\n                .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsHash().supportsL().supportsQuestionMark().and()\n                .withYear().withValidRange(1970, 2099).optional().and()\n                .withCronValidation(CronConstraintsFactory.ensureEitherDayOfWeekOrDayOfMonth())\n                .instance();\n    }\n",
        "patched_function": "    private static CronDefinition quartz() {\n        return CronDefinitionBuilder.defineCron()\n                .withSeconds().and()\n                .withMinutes().and()\n                .withHours().and()\n                .withDayOfMonth().withValidRange(1, 32).supportsL().supportsW().supportsLW().supportsQuestionMark().and()\n                .withMonth().withValidRange(1, 13).and()\n                .withDayOfWeek().withValidRange(1, 7).withMondayDoWValue(2).supportsHash().supportsL().supportsQuestionMark().and()\n                .withYear().withValidRange(1970, 2099).optional().and()\n                .withCronValidation(CronConstraintsFactory.ensureEitherDayOfWeekOrDayOfMonth())\n                .instance();\n    }"
    },
    "81": {
        "buggy_function": "  public RenderOnlySoyMsgBundleImpl(@Nullable String localeString, Iterable<SoyMsg> msgs) {\n\n    this.localeString = localeString;\n    this.locale = localeString == null ? null : new ULocale(localeString);\n    this.isRtl = BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;\n\n    // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n    int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n    this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n    int numBuckets = this.bucketMask + 1;\n\n    // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n    Comparator<SoyMsg> bucketComparator =\n        Comparator.comparingInt((SoyMsg m) -> bucketOf(m.getId())).thenComparingLong(SoyMsg::getId);\n    ImmutableList<SoyMsg> sortedMsgs = ImmutableList.sortedCopyOf(bucketComparator, msgs);\n\n    // Scan the sorted list to discover bucket boundaries and place them into the boundaries array.\n    bucketBoundaries = new int[numBuckets + 1];\n    for (int bucket = 0, idx = 0; bucket < numBuckets; bucket++) {\n      bucketBoundaries[bucket] = idx;\n      for (;\n          (idx < sortedMsgs.size()) && (bucketOf(sortedMsgs.get(idx).getId()) == bucket);\n          idx++) {}\n    }\n    bucketBoundaries[numBuckets] = sortedMsgs.size();\n\n    ids = new long[sortedMsgs.size()];\n    ImmutableList.Builder<SoyMsgPart> partsBuilder = ImmutableList.builder();\n    partRanges = new int[sortedMsgs.size() + 1];\n    partRanges[0] = 0; // The first range always starts at the beginning of the list.\n    long priorId = sortedMsgs.isEmpty() ? -1L : sortedMsgs.get(0).getId() - 1L;\n    int runningPartCount = 0;\n    for (int i = 0, c = sortedMsgs.size(); i < c; i++) {\n      SoyMsg msg = sortedMsgs.get(i);\n      ImmutableList<SoyMsgPart> parts = msg.getParts();\n\n      checkArgument(\n          msg.getId() != priorId, \"Duplicate messages are not permitted in the render-only impl.\");\n      checkArgument(\n          MsgPartUtils.hasPlrselPart(parts) == msg.isPlrselMsg(),\n          \"Message's plural/select status is inconsistent -- internal compiler bug.\");\n\n      priorId = msg.getId();\n      ids[i] = msg.getId();\n      partsBuilder.addAll(parts);\n      runningPartCount += parts.size();\n      partRanges[i + 1] = runningPartCount; // runningPartCount is the end of range, hence +1\n    }\n\n    // This will build the collections in the same order as the sorted map.\n    values = partsBuilder.build();\n  }\n",
        "patched_function": "  public RenderOnlySoyMsgBundleImpl(@Nullable String localeString, Iterable<SoyMsg> msgs) {\n\n    this.localeString = localeString;\n    this.locale = localeString == null ? null : new ULocale(localeString);\n    this.isRtl = BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;\n\n    // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n    int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n    this.bucketMask = maskHigh == 0 ? 0 : (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n    int numBuckets = this.bucketMask + 1;\n\n    // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n    Comparator<SoyMsg> bucketComparator =\n        Comparator.comparingInt((SoyMsg m) -> bucketOf(m.getId())).thenComparingLong(SoyMsg::getId);\n    ImmutableList<SoyMsg> sortedMsgs = ImmutableList.sortedCopyOf(bucketComparator, msgs);\n\n    // Scan the sorted list to discover bucket boundaries and place them into the boundaries array.\n    bucketBoundaries = new int[numBuckets + 1];\n    for (int bucket = 0, idx = 0; bucket < numBuckets; bucket++) {\n      bucketBoundaries[bucket] = idx;\n      for (;\n          (idx < sortedMsgs.size()) && (bucketOf(sortedMsgs.get(idx).getId()) == bucket);\n          idx++) {}\n    }\n    bucketBoundaries[numBuckets] = sortedMsgs.size();\n\n    ids = new long[sortedMsgs.size()];\n    ImmutableList.Builder<SoyMsgPart> partsBuilder = ImmutableList.builder();\n    partRanges = new int[sortedMsgs.size() + 1];\n    partRanges[0] = 0; // The first range always starts at the beginning of the list.\n    long priorId = sortedMsgs.isEmpty() ? -1L : sortedMsgs.get(0).getId() - 1L;\n    int runningPartCount = 0;\n    for (int i = 0, c = sortedMsgs.size(); i < c; i++) {\n      SoyMsg msg = sortedMsgs.get(i);\n      ImmutableList<SoyMsgPart> parts = msg.getParts();\n\n      checkArgument(\n          msg.getId() != priorId, \"Duplicate messages are not permitted in the render-only impl.\");\n      checkArgument(\n          MsgPartUtils.hasPlrselPart(parts) == msg.isPlrselMsg(),\n          \"Message's plural/select status is inconsistent -- internal compiler bug.\");\n\n      priorId = msg.getId();\n      ids[i] = msg.getId();\n      partsBuilder.addAll(parts);\n      runningPartCount += parts.size();\n      partRanges[i + 1] = runningPartCount; // runningPartCount is the end of range, hence +1\n    }\n\n    // This will build the collections in the same order as the sorted map.\n    values = partsBuilder.build();\n  }"
    },
    "82": {
        "buggy_function": "  public RenderOnlySoyMsgBundleImpl(@Nullable String localeString, Iterable<SoyMsg> msgs) {\n\n    this.localeString = localeString;\n    this.locale = localeString == null ? null : new ULocale(localeString);\n    this.isRtl = BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;\n\n    // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n    int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n    this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n    int numBuckets = this.bucketMask + 1;\n\n    // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n    Comparator<SoyMsg> bucketComparator =\n        Comparator.comparingInt((SoyMsg m) -> bucketOf(m.getId())).thenComparingLong(SoyMsg::getId);\n    ImmutableList<SoyMsg> sortedMsgs = ImmutableList.sortedCopyOf(bucketComparator, msgs);\n\n    // Scan the sorted list to discover bucket boundaries and place them into the boundaries array.\n    bucketBoundaries = new int[numBuckets + 1];\n    for (int bucket = 0, idx = 0; bucket < numBuckets; bucket++) {\n      bucketBoundaries[bucket] = idx;\n      for (;\n          (idx < sortedMsgs.size()) && (bucketOf(sortedMsgs.get(idx).getId()) == bucket);\n          idx++) {}\n    }\n    bucketBoundaries[numBuckets] = sortedMsgs.size();\n\n    ids = new long[sortedMsgs.size()];\n    ImmutableList.Builder<SoyMsgPart> partsBuilder = ImmutableList.builder();\n    partRanges = new int[sortedMsgs.size() + 1];\n    partRanges[0] = 0; // The first range always starts at the beginning of the list.\n    long priorId = sortedMsgs.isEmpty() ? -1L : sortedMsgs.get(0).getId() - 1L;\n    int runningPartCount = 0;\n    for (int i = 0, c = sortedMsgs.size(); i < c; i++) {\n      SoyMsg msg = sortedMsgs.get(i);\n      ImmutableList<SoyMsgPart> parts = msg.getParts();\n\n      checkArgument(\n          msg.getId() != priorId, \"Duplicate messages are not permitted in the render-only impl.\");\n      checkArgument(\n          MsgPartUtils.hasPlrselPart(parts) == msg.isPlrselMsg(),\n          \"Message's plural/select status is inconsistent -- internal compiler bug.\");\n\n      priorId = msg.getId();\n      ids[i] = msg.getId();\n      partsBuilder.addAll(parts);\n      runningPartCount += parts.size();\n      partRanges[i + 1] = runningPartCount; // runningPartCount is the end of range, hence +1\n    }\n\n    // This will build the collections in the same order as the sorted map.\n    values = partsBuilder.build();\n  }\n",
        "patched_function": "  public RenderOnlySoyMsgBundleImpl(@Nullable String localeString, Iterable<SoyMsg> msgs) {\n\n    this.localeString = localeString;\n    this.locale = localeString == null ? null : new ULocale(localeString);\n    this.isRtl = BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;\n\n    // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n    int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n    this.bucketMask = (maskHigh | (maskHigh - 1)) >>> BUCKET_SHIFT;\n    int numBuckets = maskHigh == 0 ? 0 : this.bucketMask + 1;\n\n    // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n    Comparator<SoyMsg> bucketComparator =\n        Comparator.comparingInt((SoyMsg m) -> bucketOf(m.getId())).thenComparingLong(SoyMsg::getId);\n    ImmutableList<SoyMsg> sortedMsgs = ImmutableList.sortedCopyOf(bucketComparator, msgs);\n\n    // Scan the sorted list to discover bucket boundaries and place them into the boundaries array.\n    bucketBoundaries = new int[numBuckets + 1];\n    for (int bucket = 0, idx = 0; bucket < numBuckets; bucket++) {\n      bucketBoundaries[bucket] = idx;\n      for (;\n          (idx < sortedMsgs.size()) && (bucketOf(sortedMsgs.get(idx).getId()) == bucket);\n          idx++) {}\n    }\n    bucketBoundaries[numBuckets] = sortedMsgs.size();\n\n    ids = new long[sortedMsgs.size()];\n    ImmutableList.Builder<SoyMsgPart> partsBuilder = ImmutableList.builder();\n    partRanges = new int[sortedMsgs.size() + 1];\n    partRanges[0] = 0; // The first range always starts at the beginning of the list.\n    long priorId = sortedMsgs.isEmpty() ? -1L : sortedMsgs.get(0).getId() - 1L;\n    int runningPartCount = 0;\n    for (int i = 0, c = sortedMsgs.size(); i < c; i++) {\n      SoyMsg msg = sortedMsgs.get(i);\n      ImmutableList<SoyMsgPart> parts = msg.getParts();\n\n      checkArgument(\n          msg.getId() != priorId, \"Duplicate messages are not permitted in the render-only impl.\");\n      checkArgument(\n          MsgPartUtils.hasPlrselPart(parts) == msg.isPlrselMsg(),\n          \"Message's plural/select status is inconsistent -- internal compiler bug.\");\n\n      priorId = msg.getId();\n      ids[i] = msg.getId();\n      partsBuilder.addAll(parts);\n      runningPartCount += parts.size();\n      partRanges[i + 1] = runningPartCount; // runningPartCount is the end of range, hence +1\n    }\n\n    // This will build the collections in the same order as the sorted map.\n    values = partsBuilder.build();\n  }"
    },
    "84": {
        "buggy_function": "  public static Expression concatChunksForceString(List<? extends Expression> chunks) {\n    if (!chunks.isEmpty()\n        && chunks.get(0).isRepresentableAsSingleExpression()\n        && JsExprUtils.isStringLiteral(\n            chunks.get(0).assertExprAndCollectRequires(RequiresCollector.NULL))) {\n      return concatChunks(chunks);\n    } else if (chunks.size() > 1\n        && chunks.get(1).isRepresentableAsSingleExpression()\n        && JsExprUtils.isStringLiteral(\n            chunks.get(1).assertExprAndCollectRequires(RequiresCollector.NULL))) {\n      return concatChunks(chunks);\n    } else {\n      return concatChunks(\n          ImmutableList.of(LITERAL_EMPTY_STRING, Group.create(concatChunks(chunks))));\n    }\n  }\n",
        "patched_function": "  public static Expression concatChunksForceString(List<? extends Expression> chunks) {\n    if (!chunks.isEmpty()\n        && chunks.get(0).isRepresentableAsSingleExpression()\n        && JsExprUtils.isStringLiteral(\n            chunks.get(0).assertExprAndCollectRequires(RequiresCollector.NULL))) {\n      return concatChunks(chunks);\n    } else if (chunks.size() > 1\n        && chunks.get(1).isRepresentableAsSingleExpression()\n        && JsExprUtils.isStringLiteral(\n            chunks.get(1).assertExprAndCollectRequires(RequiresCollector.NULL))) {\n      return concatChunks(chunks);\n    } else {\n      return concatChunks(\n          ImmutableList.<Expression>builder().add(LITERAL_EMPTY_STRING).addAll(chunks).build());\n    }\n  }"
    },
    "95": {
        "buggy_function": "    public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) throws IOException {\n        SerializeWriter out = serializer.out;\n\n        if (object == null) {\n            out.writeNull();\n            return;\n        }\n\n        Class<?> clazz = object.getClass();\n        if (clazz == java.sql.Date.class) {\n            long millis = ((java.sql.Date) object).getTime();\n            TimeZone timeZone = serializer.timeZone;\n            int offset = timeZone.getOffset(millis);\n            //\n            if ((millis + offset) % (24 * 1000 * 3600) == 0\n                    && !SerializerFeature.isEnabled(out.features, features, SerializerFeature.WriteClassName)) {\n                out.writeString(object.toString());\n                return;\n            }\n        }\n\n        if (clazz == java.sql.Time.class) {\n            long millis = ((java.sql.Time) object).getTime();\n            if (\"unixtime\".equals(serializer.getDateFormatPattern())) {\n                long seconds = millis / 1000;\n                out.writeLong(seconds);\n                return;\n            }\n\n            if (\"millis\".equals(serializer.getDateFormatPattern())) {\n                long seconds = millis;\n                out.writeLong(millis);\n                return;\n            }\n\n            if (millis < 24L * 60L * 60L * 1000L) {\n                out.writeString(object.toString());\n                return;\n            }\n        }\n\n        int nanos = 0;\n        if (clazz == java.sql.Timestamp.class) {\n            java.sql.Timestamp ts = (java.sql.Timestamp) object;\n            nanos = ts.getNanos();\n        }\n        \n        Date date;\n        if (object instanceof Date) {\n            date = (Date) object;\n        } else {\n            date = TypeUtils.castToDate(object);\n        }\n\n        if (\"unixtime\".equals(serializer.getDateFormatPattern())) {\n            long seconds = date.getTime() / 1000;\n            out.writeLong(seconds);\n            return;\n        }\n\n        if (\"millis\".equals(serializer.getDateFormatPattern())) {\n            long millis = date.getTime();\n            out.writeLong(millis);\n            return;\n        }\n\n        if (out.isEnabled(SerializerFeature.WriteDateUseDateFormat)) {\n            DateFormat format = serializer.getDateFormat();\n            if (format == null) {\n                format = new SimpleDateFormat(JSON.DEFFAULT_DATE_FORMAT, serializer.locale);\n                format.setTimeZone(serializer.timeZone);\n            }\n            String text = format.format(date);\n            out.writeString(text);\n            return;\n        }\n        \n        if (out.isEnabled(SerializerFeature.WriteClassName)) {\n            if (clazz != fieldType) {\n                if (clazz == java.util.Date.class) {\n                    out.write(\"new Date(\");\n                    out.writeLong(((Date) object).getTime());\n                    out.write(')');\n                } else {\n                    out.write('{');\n                    out.writeFieldName(JSON.DEFAULT_TYPE_KEY);\n                    serializer.write(clazz.getName());\n                    out.writeFieldValue(',', \"val\", ((Date) object).getTime());\n                    out.write('}');\n                }\n                return;\n            }\n        }\n\n        long time = date.getTime();\n        if (out.isEnabled(SerializerFeature.UseISO8601DateFormat)) {\n            char quote = out.isEnabled(SerializerFeature.UseSingleQuotes) ? '\\'' : '\\\"'; \n            out.write(quote);\n\n            Calendar calendar = Calendar.getInstance(serializer.timeZone, serializer.locale);\n            calendar.setTimeInMillis(time);\n\n            int year = calendar.get(Calendar.YEAR);\n            int month = calendar.get(Calendar.MONTH) + 1;\n            int day = calendar.get(Calendar.DAY_OF_MONTH);\n            int hour = calendar.get(Calendar.HOUR_OF_DAY);\n            int minute = calendar.get(Calendar.MINUTE);\n            int second = calendar.get(Calendar.SECOND);\n            int millis = calendar.get(Calendar.MILLISECOND);\n\n            char[] buf;\n            if (nanos > 0) {\n                buf = \"0000-00-00 00:00:00.000000000\".toCharArray();\n                int nanoSize = IOUtils.stringSize(nanos);\n                IOUtils.getChars(nanos, 30 - (9 - nanoSize), buf);\n                IOUtils.getChars(second, 19, buf);\n                IOUtils.getChars(minute, 16, buf);\n                IOUtils.getChars(hour, 13, buf);\n                IOUtils.getChars(day, 10, buf);\n                IOUtils.getChars(month, 7, buf);\n                IOUtils.getChars(year, 4, buf);\n            } else if (millis != 0) {\n                buf = \"0000-00-00T00:00:00.000\".toCharArray();\n                IOUtils.getChars(millis, 23, buf);\n                IOUtils.getChars(second, 19, buf);\n                IOUtils.getChars(minute, 16, buf);\n                IOUtils.getChars(hour, 13, buf);\n                IOUtils.getChars(day, 10, buf);\n                IOUtils.getChars(month, 7, buf);\n                IOUtils.getChars(year, 4, buf);\n\n            } else {\n                if (second == 0 && minute == 0 && hour == 0) {\n                    buf = \"0000-00-00\".toCharArray();\n                    IOUtils.getChars(day, 10, buf);\n                    IOUtils.getChars(month, 7, buf);\n                    IOUtils.getChars(year, 4, buf);\n                } else {\n                    buf = \"0000-00-00T00:00:00\".toCharArray();\n                    IOUtils.getChars(second, 19, buf);\n                    IOUtils.getChars(minute, 16, buf);\n                    IOUtils.getChars(hour, 13, buf);\n                    IOUtils.getChars(day, 10, buf);\n                    IOUtils.getChars(month, 7, buf);\n                    IOUtils.getChars(year, 4, buf);\n                }\n            }\n            \n            out.write(buf);\n            if (nanos > 0) { // java.sql.Timestamp\n                out.write(quote);\n                return;\n            }\n\n            float timeZoneF = calendar.getTimeZone().getOffset(calendar.getTimeInMillis()) / (3600.0f * 1000);\n            int timeZone = (int)timeZoneF;\n            if (timeZone == 0.0) {\n                out.write('Z');\n            } else {\n                if (timeZone > 9) {\n                    out.write('+');\n                    out.writeInt(timeZone);\n                } else if (timeZone > 0) {\n                    out.write('+');\n                    out.write('0');\n                    out.writeInt(timeZone);\n                } else if (timeZone < -9) {\n                    out.write('-');\n                    out.writeInt(-timeZone);\n                } else if (timeZone < 0) {\n                    out.write('-');\n                    out.write('0');\n                    out.writeInt(-timeZone);\n                }\n                out.write(':');\n                // handles uneven timeZones 30 mins, 45 mins\n                // this would always be less than 60\n                int offSet = (int)(Math.abs(timeZoneF - timeZone) * 60);\n                out.append(String.format(\"%02d\", offSet));\n            }\n\n            out.write(quote);\n        } else {\n            out.writeLong(time);\n        }\n    }\n",
        "patched_function": "    public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) throws IOException {\n        SerializeWriter out = serializer.out;\n\n        if (object == null) {\n            out.writeNull();\n            return;\n        }\n\n        Class<?> clazz = object.getClass();\n        if (clazz == java.sql.Date.class) {\n            long millis = ((java.sql.Date) object).getTime();\n            TimeZone timeZone = serializer.timeZone;\n            int offset = timeZone.getOffset(millis);\n            //\n            if ((millis + offset) % (24 * 1000 * 3600) == 0\n                    && !SerializerFeature.isEnabled(out.features, features, SerializerFeature.WriteClassName)) {\n                out.writeString(object.toString());\n                return;\n            }\n        }\n\n        if (clazz == java.sql.Time.class) {\n            long millis = ((java.sql.Time) object).getTime();\n            if (\"unixtime\".equals(serializer.getDateFormatPattern())) {\n                long seconds = millis / 1000;\n                out.writeLong(seconds);\n                return;\n            }\n\n            if (\"millis\".equals(serializer.getDateFormatPattern())) {\n                long seconds = millis;\n                out.writeLong(millis);\n                return;\n            }\n\n            if (millis < 24L * 60L * 60L * 1000L) {\n                out.writeString(object.toString());\n                return;\n            }\n        }\n\n        int nanos = 0;\n        if (clazz == java.sql.Timestamp.class) {\n            java.sql.Timestamp ts = (java.sql.Timestamp) object;\n            nanos = ts.getNanos();\n        }\n        \n        Date date;\n        if (object instanceof Date) {\n            date = (Date) object;\n        } else {\n            date = TypeUtils.castToDate(object);\n        }\n\n        if (\"unixtime\".equals(serializer.getDateFormatPattern())) {\n            long seconds = date.getTime() / 1000;\n            out.writeLong(seconds);\n            return;\n        }\n\n        if (\"millis\".equals(serializer.getDateFormatPattern())) {\n            long millis = date.getTime();\n            out.writeLong(millis);\n            return;\n        }\n\n        if (out.isEnabled(SerializerFeature.WriteDateUseDateFormat)) {\n            DateFormat format = serializer.getDateFormat();\n            if (format == null) {\n                format = new SimpleDateFormat(JSON.DEFFAULT_DATE_FORMAT, serializer.locale);\n                format.setTimeZone(serializer.timeZone);\n            }\n            String text = format.format(date);\n            out.writeString(text);\n            return;\n        }\n        \n        if (out.isEnabled(SerializerFeature.WriteClassName)) {\n            if (clazz != fieldType) {\n                if (clazz == java.util.Date.class) {\n                    out.write(\"new Date(\");\n                    out.writeLong(((Date) object).getTime());\n                    out.write(')');\n                } else {\n                    out.write('{');\n                    out.writeFieldName(JSON.DEFAULT_TYPE_KEY);\n                    serializer.write(clazz.getName());\n                    out.writeFieldValue(',', \"val\", ((Date) object).getTime());\n                    out.write('}');\n                }\n                return;\n            }\n        }\n\n        long time = date.getTime();\n        if (out.isEnabled(SerializerFeature.UseISO8601DateFormat)) {\n            char quote = out.isEnabled(SerializerFeature.UseSingleQuotes) ? '\\'' : '\\\"'; \n            out.write(quote);\n\n            Calendar calendar = Calendar.getInstance(serializer.timeZone, serializer.locale);\n            calendar.setTimeInMillis(time);\n\n            int year = calendar.get(Calendar.YEAR);\n            int month = calendar.get(Calendar.MONTH) + 1;\n            int day = calendar.get(Calendar.DAY_OF_MONTH);\n            int hour = calendar.get(Calendar.HOUR_OF_DAY);\n            int minute = calendar.get(Calendar.MINUTE);\n            int second = calendar.get(Calendar.SECOND);\n            int millis = calendar.get(Calendar.MILLISECOND);\n\n            char[] buf;\n            if (nanos > 0) {\n                buf = \"0000-00-00 00:00:00.000000000\".toCharArray();\n                int nanoSize = IOUtils.stringSize(nanos);\n                IOUtils.getChars(nanos, 29 - (9 - nanoSize), buf);\n                IOUtils.getChars(second, 19, buf);\n                IOUtils.getChars(minute, 16, buf);\n                IOUtils.getChars(hour, 13, buf);\n                IOUtils.getChars(day, 10, buf);\n                IOUtils.getChars(month, 7, buf);\n                IOUtils.getChars(year, 4, buf);\n            } else if (millis != 0) {\n                buf = \"0000-00-00T00:00:00.000\".toCharArray();\n                IOUtils.getChars(millis, 23, buf);\n                IOUtils.getChars(second, 19, buf);\n                IOUtils.getChars(minute, 16, buf);\n                IOUtils.getChars(hour, 13, buf);\n                IOUtils.getChars(day, 10, buf);\n                IOUtils.getChars(month, 7, buf);\n                IOUtils.getChars(year, 4, buf);\n\n            } else {\n                if (second == 0 && minute == 0 && hour == 0) {\n                    buf = \"0000-00-00\".toCharArray();\n                    IOUtils.getChars(day, 10, buf);\n                    IOUtils.getChars(month, 7, buf);\n                    IOUtils.getChars(year, 4, buf);\n                } else {\n                    buf = \"0000-00-00T00:00:00\".toCharArray();\n                    IOUtils.getChars(second, 19, buf);\n                    IOUtils.getChars(minute, 16, buf);\n                    IOUtils.getChars(hour, 13, buf);\n                    IOUtils.getChars(day, 10, buf);\n                    IOUtils.getChars(month, 7, buf);\n                    IOUtils.getChars(year, 4, buf);\n                }\n            }\n            \n            out.write(buf);\n            if (nanos > 0) { // java.sql.Timestamp\n                out.write(quote);\n                return;\n            }\n\n            float timeZoneF = calendar.getTimeZone().getOffset(calendar.getTimeInMillis()) / (3600.0f * 1000);\n            int timeZone = (int)timeZoneF;\n            if (timeZone == 0.0) {\n                out.write('Z');\n            } else {\n                if (timeZone > 9) {\n                    out.write('+');\n                    out.writeInt(timeZone);\n                } else if (timeZone > 0) {\n                    out.write('+');\n                    out.write('0');\n                    out.writeInt(timeZone);\n                } else if (timeZone < -9) {\n                    out.write('-');\n                    out.writeInt(-timeZone);\n                } else if (timeZone < 0) {\n                    out.write('-');\n                    out.write('0');\n                    out.writeInt(-timeZone);\n                }\n                out.write(':');\n                // handles uneven timeZones 30 mins, 45 mins\n                // this would always be less than 60\n                int offSet = (int)(Math.abs(timeZoneF - timeZone) * 60);\n                out.append(String.format(\"%02d\", offSet));\n            }\n\n            out.write(quote);\n        } else {\n            out.writeLong(time);\n        }\n    }"
    },
    "96": {
        "buggy_function": "    public void finish() throws IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                if (this.runLength > 0) {\n                    writeRun();\n                }\n                this.currentChar = -1;\n                endBlock();\n                endCompression();\n            } finally {\n                this.out = null;\n                this.blockSorter = null;\n                this.data = null;\n            }\n        }\n    }\n",
        "patched_function": "    public void finish() throws IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                if (this.runLength > 0) {\n                    writeRun();\n                }\n                this.currentChar = -1;\n                endBlock();\n                endCompression();\n            } finally {\n                this.blockSorter = null;\n                this.data = null;\n            }\n        }\n    }"
    },
    "98": {
        "buggy_function": "    @Override\n    public synchronized int available() throws IOException {\n        if (!refill()) {\n            return EOF;\n        }\n        return byteBuffer.remaining();\n    }\n",
        "patched_function": "    @Override\n    public synchronized int available() throws IOException {\n        if (!fileChannel.isOpen()) {\n            return 0;\n        }\n        if (!refill()) {\n            return EOF;\n        }\n        return byteBuffer.remaining();\n    }"
    },
    "4": {
        "buggy_function": "    public static <P extends Proposition> List<P> computeSmus(final List<P> propositions, final List<Formula> additionalConstraints, final FormulaFactory f,\n                                                              final OptimizationHandler handler) {\n        start(handler);\n        final SATSolver growSolver = MiniSat.miniSat(f);\n        growSolver.add(additionalConstraints == null ? Collections.singletonList(f.verum()) : additionalConstraints);\n        final Map<Variable, P> propositionMapping = new TreeMap<>();\n        for (final P proposition : propositions) {\n            final Variable selector = f.variable(PROPOSITION_SELECTOR + propositionMapping.size());\n            propositionMapping.put(selector, proposition);\n            growSolver.add(f.equivalence(selector, proposition.formula()));\n        }\n        final boolean sat = growSolver.sat(satHandler(handler), propositionMapping.keySet()) == Tristate.TRUE;\n        if (aborted(handler)) {\n            return null;\n        }\n        if (sat) {\n            throw new IllegalArgumentException(\"Cannot compute a smallest MUS for a satisfiable formula set.\");\n        }\n        final SATSolver hSolver = MiniSat.miniSat(f);\n        while (true) {\n            final SortedSet<Variable> h = minimumHs(hSolver, propositionMapping.keySet(), handler);\n            if (aborted(handler)) {\n                return null;\n            }\n            final SortedSet<Variable> c = grow(growSolver, h, propositionMapping.keySet(), handler);\n            if (aborted(handler)) {\n                return null;\n            }\n            if (c == null) {\n                return h.stream().map(propositionMapping::get).collect(Collectors.toList());\n            }\n            hSolver.add(f.or(c));\n        }\n    }\n",
        "patched_function": "    public static <P extends Proposition> List<P> computeSmus(final List<P> propositions, final List<Formula> additionalConstraints, final FormulaFactory f,\n                                                              final OptimizationHandler handler) {\n        start(handler);\n        final SATSolver growSolver = MiniSat.miniSat(f);\n        growSolver.add(additionalConstraints == null ? Collections.singletonList(f.verum()) : additionalConstraints);\n        final Map<Variable, P> propositionMapping = new TreeMap<>();\n        for (final P proposition : propositions) {\n            final Variable selector = f.variable(PROPOSITION_SELECTOR + propositionMapping.size());\n            propositionMapping.put(selector, proposition);\n            growSolver.add(f.equivalence(selector, proposition.formula()));\n        }\n        final boolean sat = growSolver.sat(satHandler(handler), propositionMapping.keySet()) == Tristate.TRUE;\n        if (sat || aborted(handler)) {\n            return null;\n        }\n        final SATSolver hSolver = MiniSat.miniSat(f);\n        while (true) {\n            final SortedSet<Variable> h = minimumHs(hSolver, propositionMapping.keySet(), handler);\n            if (h == null || aborted(handler)) {\n                return null;\n            }\n            final SortedSet<Variable> c = grow(growSolver, h, propositionMapping.keySet(), handler);\n            if (aborted(handler)) {\n                return null;\n            }\n            if (c == null) {\n                return h.stream().map(propositionMapping::get).collect(Collectors.toList());\n            }\n            hSolver.add(f.or(c));\n        }\n    }"
    },
    "11": {
        "buggy_function": "\tprivate static boolean isAssignableFrom(Class<?> target, KType source) {\n\n\t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n\n\t\tif (parameterType instanceof Class) {\n\t\t\treturn target.isAssignableFrom((Class<?>) parameterType);\n\t\t}\n\n\t\treturn false;\n\t}\n",
        "patched_function": "\tprivate static boolean isAssignableFrom(Class<?> target, KType source) {\n\n\t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n\n\t\treturn ResolvableType.forClass(target).isAssignableFrom(ResolvableType.forType(parameterType));\n\t}"
    },
    "15": {
        "buggy_function": "    private Iterator<YamlLine> nodeComment() {\n        enteredComments = false;\n        Iterator<YamlLine> iterator = this.lines.iterator();\n        final List<YamlLine> comment = new ArrayList<>();\n        while (iterator.hasNext()) {\n            final YamlLine line = iterator.next();\n            boolean hasComment = !line.comment().isEmpty();\n            if (enteredComments && !hasComment) {\n                break;\n            } else {\n                if (hasComment) {\n                    enteredComments = true;\n                    if (!\"---\".equals(line.trimmed())) {\n                        if (line.trimmed().startsWith(\"#\")) {\n                            comment.add(line);\n                        }\n                    }\n                }\n            }\n        }\n        iterator = comment.iterator();\n        return iterator;\n    }\n",
        "patched_function": "    private Iterator<YamlLine> nodeComment() {\n        Iterator<YamlLine> iterator = this.lines.iterator();\n        final List<YamlLine> comment = new ArrayList<>();\n        while (iterator.hasNext()) {\n            final YamlLine line = iterator.next();\n            boolean hasComment = !line.comment().isEmpty();\n            boolean notYamlStart = !\"---\".equals(line.trimmed());\n            if(notYamlStart && hasComment) {\n                if(line.trimmed().startsWith(\"#\")) {\n                    comment.add(line);\n                }\n            } else {\n                break;\n            }\n        }\n        iterator = comment.iterator();\n        return iterator;\n    }"
    },
    "16": {
        "buggy_function": "    private void readTo(final int targetArrUsed) throws IOException {\n        // Array does not need to grow larger than the length hint (if the uncompressed size of the zip entry\n        // is an underestimate, classfile will be truncated). If -1, assume 2GB is the max size.\n        final int maxArrLen = classfileLengthHint == -1 ? FileUtils.MAX_BUFFER_SIZE : classfileLengthHint;\n        if (inflaterInputStream == null && randomAccessReader == null) {\n            // If neither inflaterInputStream nor randomAccessReader is set, then slice is an ArraySlice,\n            // and array is already \"fully loaded\" (the ArraySlice's backing array is used as the buffer).\n            throw new IOException(\"Tried to read past end of fixed array buffer\");\n        }\n        if (targetArrUsed > FileUtils.MAX_BUFFER_SIZE || targetArrUsed < 0 || arrUsed == maxArrLen) {\n            throw new IOException(\"Hit 2GB limit while trying to grow buffer array\");\n        }\n\n        // Need to read at least BUF_CHUNK_SIZE (but don't overshoot past 2GB limit)\n        final int maxNewArrUsed = (int) Math.min(Math.max(targetArrUsed, (long) (arrUsed + BUF_CHUNK_SIZE)),\n                maxArrLen);\n\n        // Double the size of the array if it's too small to contain the new chunk of bytes\n        if (arr.length < maxNewArrUsed) {\n            arr = Arrays.copyOf(arr, (int) Math.min(arr.length * 2L, maxArrLen));\n        }\n\n        // Figure out the maximum number of bytes that can be read into the array (which is the minimum\n        // of the number of requested bytes, and the space left in the array)\n        final int maxBytesToRead = Math.min(maxNewArrUsed - arrUsed, arr.length - arrUsed);\n\n        // Read a new chunk into the buffer, starting at position arrUsed\n        if (inflaterInputStream != null) {\n            // Read from inflater input stream\n            final int numRead = inflaterInputStream.read(arr, arrUsed, maxBytesToRead);\n            if (numRead > 0) {\n                arrUsed += numRead;\n            }\n        } else /* randomAccessReader == null, so this is a (non-deflated) FileSlice */ {\n            // Don't read past end of slice\n            final int bytesToRead = Math.min(maxBytesToRead, maxArrLen - arrUsed);\n            // Read bytes from FileSlice into arr\n            final int numBytesRead = randomAccessReader.read(/* srcOffset = */ arrUsed, /* dstArr = */ arr,\n                    /* dstArrStart = */ arrUsed, /* numBytes = */ bytesToRead);\n            if (numBytesRead > 0) {\n                arrUsed += numBytesRead;\n            }\n        }\n\n        // Check the buffer was able to be filled to the requested position\n        if (arrUsed < targetArrUsed) {\n            throw new IOException(\"Buffer underflow\");\n        }\n    }\n",
        "patched_function": "    private void readTo(final int targetArrUsed) throws IOException {\n        // Array does not need to grow larger than the length hint (if the uncompressed size of the zip entry\n        // is an underestimate, classfile will be truncated). If -1, assume 2GB is the max size.\n        final int maxArrLen = classfileLengthHint == -1 ? FileUtils.MAX_BUFFER_SIZE : classfileLengthHint;\n        if (inflaterInputStream == null && randomAccessReader == null) {\n            // If neither inflaterInputStream nor randomAccessReader is set, then slice is an ArraySlice,\n            // and array is already \"fully loaded\" (the ArraySlice's backing array is used as the buffer).\n            throw new IOException(\"Tried to read past end of fixed array buffer\");\n        }\n        if (targetArrUsed > FileUtils.MAX_BUFFER_SIZE || targetArrUsed < 0 || arrUsed == maxArrLen) {\n            throw new IOException(\"Hit 2GB limit while trying to grow buffer array\");\n        }\n\n        // Need to read at least BUF_CHUNK_SIZE (but don't overshoot past 2GB limit)\n        final int maxNewArrUsed = (int) Math.min(Math.max(targetArrUsed, (long) (arrUsed + BUF_CHUNK_SIZE)),\n                maxArrLen);\n\n        // Double the size of the array if it's too small to contain the new chunk of bytes\n        long newArrLength = arr.length;\n        while (newArrLength < maxNewArrUsed) {\n            newArrLength = Math.min(maxNewArrUsed, newArrLength * 2L);\n        }\n        if (newArrLength > FileUtils.MAX_BUFFER_SIZE) {\n            throw new IOException(\"Hit 2GB limit while trying to grow buffer array\");\n        }\n        arr = Arrays.copyOf(arr, (int) Math.min(newArrLength, maxArrLen));\n\n        // Figure out the maximum number of bytes that can be read into the array\n        final int maxBytesToRead = arr.length - arrUsed;\n\n        // Read a new chunk into the buffer, starting at position arrUsed\n        if (inflaterInputStream != null) {\n            // Read from inflater input stream\n            final int numRead = inflaterInputStream.read(arr, arrUsed, maxBytesToRead);\n            if (numRead > 0) {\n                arrUsed += numRead;\n            }\n        } else /* randomAccessReader == null, so this is a (non-deflated) FileSlice */ {\n            // Don't read past end of slice\n            final int bytesToRead = Math.min(maxBytesToRead, maxArrLen - arrUsed);\n            // Read bytes from FileSlice into arr\n            final int numBytesRead = randomAccessReader.read(/* srcOffset = */ arrUsed, /* dstArr = */ arr,\n                    /* dstArrStart = */ arrUsed, /* numBytes = */ bytesToRead);\n            if (numBytesRead > 0) {\n                arrUsed += numBytesRead;\n            }\n        }\n\n        // Check the buffer was able to be filled to the requested position\n        if (arrUsed < targetArrUsed) {\n            throw new IOException(\"Buffer underflow\");\n        }\n    }"
    },
    "18": {
        "buggy_function": "    public BigInteger scanFieldBigInteger(char[] fieldName) {\n        matchStat = UNKNOWN;\n\n        if (!charArrayCompare(fieldName)) {\n            matchStat = NOT_MATCH_NAME;\n            return null;\n        }\n\n        int offset = fieldName.length;\n        char chLocal = charAt(bp + (offset++));\n        final boolean quote = chLocal == '\"';\n        if (quote) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        boolean negative = chLocal == '-';\n        if (negative) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        BigInteger value;\n        if (chLocal >= '0' && chLocal <= '9') {\n            long intVal = chLocal - '0';\n            for (;;) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            int start, count;\n            if (quote) {\n                if (chLocal != '\"') {\n                    matchStat = NOT_MATCH;\n                    return null;\n                } else {\n                    chLocal = charAt(bp + (offset++));\n                }\n                start = bp + fieldName.length + 1;\n                count = bp + offset - start - 2;\n            } else {\n                start = bp + fieldName.length;\n                count = bp + offset - start - 1;\n            }\n\n            if (count < 20 || (negative && count < 21)) {\n                value = BigInteger.valueOf(negative ? -intVal : intVal);\n            } else {\n\n//            char[] chars = this.sub_chars(negative ? start + 1 : start, count);\n//            value = new BigInteger(chars, )\n                String strVal = this.subString(start, count);\n                value = new BigInteger(strVal);\n            }\n        } else if (chLocal == 'n' &&\n                   charAt(bp + offset) == 'u' &&\n                   charAt(bp + offset + 1) == 'l' &&\n                   charAt(bp + offset + 2) == 'l') {\n            matchStat = VALUE_NULL;\n            value = null;\n            offset += 3;\n            chLocal = charAt(bp + offset++);\n\n            if (quote && chLocal == '\"') {\n                chLocal = charAt(bp + offset++);\n            }\n\n            for (;;) {\n                if (chLocal == ',') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.COMMA;\n                    return value;\n                } else if (chLocal == '}') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.RBRACE;\n                    return value;\n                } else if (isWhitespace(chLocal)) {\n                    chLocal = charAt(bp + offset++);\n                    continue;\n                }\n                break;\n            }\n            matchStat = NOT_MATCH;\n            return null;\n        } else {\n            matchStat = NOT_MATCH;\n            return null;\n        }\n\n        if (chLocal == ',') {\n            bp += offset;\n            this.ch = this.charAt(bp);\n            matchStat = VALUE;\n            token = JSONToken.COMMA;\n            return value;\n        }\n\n        if (chLocal == '}') {\n            chLocal = charAt(bp + (offset++));\n            if (chLocal == ',') {\n                token = JSONToken.COMMA;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == ']') {\n                token = JSONToken.RBRACKET;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == '}') {\n                token = JSONToken.RBRACE;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == EOI) {\n                token = JSONToken.EOF;\n                bp += (offset - 1);\n                ch = EOI;\n            } else {\n                matchStat = NOT_MATCH;\n                return null;\n            }\n            matchStat = END;\n        } else {\n            matchStat = NOT_MATCH;\n            return null;\n        }\n\n        return value;\n    }\n",
        "patched_function": "    public BigInteger scanFieldBigInteger(char[] fieldName) {\n        matchStat = UNKNOWN;\n\n        if (!charArrayCompare(fieldName)) {\n            matchStat = NOT_MATCH_NAME;\n            return null;\n        }\n\n        int offset = fieldName.length;\n        char chLocal = charAt(bp + (offset++));\n        final boolean quote = chLocal == '\"';\n        if (quote) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        boolean negative = chLocal == '-';\n        if (negative) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        BigInteger value;\n        if (chLocal >= '0' && chLocal <= '9') {\n            long intVal = chLocal - '0';\n            boolean overflow = false;\n            long temp;\n            for (;;) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    temp = intVal * 10 + (chLocal - '0');\n                    if (temp < intVal) {\n                        overflow = true;\n                        break;\n                    }\n                    intVal = temp;\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            int start, count;\n            if (quote) {\n                if (chLocal != '\"') {\n                    matchStat = NOT_MATCH;\n                    return null;\n                } else {\n                    chLocal = charAt(bp + (offset++));\n                }\n                start = bp + fieldName.length + 1;\n                count = bp + offset - start - 2;\n            } else {\n                start = bp + fieldName.length;\n                count = bp + offset - start - 1;\n            }\n\n            if (!overflow && (count < 20 || (negative && count < 21))) {\n                value = BigInteger.valueOf(negative ? -intVal : intVal);\n            } else {\n\n//            char[] chars = this.sub_chars(negative ? start + 1 : start, count);\n//            value = new BigInteger(chars, )\n                String strVal = this.subString(start, count);\n                value = new BigInteger(strVal);\n            }\n        } else if (chLocal == 'n' &&\n                   charAt(bp + offset) == 'u' &&\n                   charAt(bp + offset + 1) == 'l' &&\n                   charAt(bp + offset + 2) == 'l') {\n            matchStat = VALUE_NULL;\n            value = null;\n            offset += 3;\n            chLocal = charAt(bp + offset++);\n\n            if (quote && chLocal == '\"') {\n                chLocal = charAt(bp + offset++);\n            }\n\n            for (;;) {\n                if (chLocal == ',') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.COMMA;\n                    return value;\n                } else if (chLocal == '}') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.RBRACE;\n                    return value;\n                } else if (isWhitespace(chLocal)) {\n                    chLocal = charAt(bp + offset++);\n                    continue;\n                }\n                break;\n            }\n            matchStat = NOT_MATCH;\n            return null;\n        } else {\n            matchStat = NOT_MATCH;\n            return null;\n        }\n\n        if (chLocal == ',') {\n            bp += offset;\n            this.ch = this.charAt(bp);\n            matchStat = VALUE;\n            token = JSONToken.COMMA;\n            return value;\n        }\n\n        if (chLocal == '}') {\n            chLocal = charAt(bp + (offset++));\n            if (chLocal == ',') {\n                token = JSONToken.COMMA;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == ']') {\n                token = JSONToken.RBRACKET;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == '}') {\n                token = JSONToken.RBRACE;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == EOI) {\n                token = JSONToken.EOF;\n                bp += (offset - 1);\n                ch = EOI;\n            } else {\n                matchStat = NOT_MATCH;\n                return null;\n            }\n            matchStat = END;\n        } else {\n            matchStat = NOT_MATCH;\n            return null;\n        }\n\n        return value;\n    }"
    },
    "26": {
        "buggy_function": "    public static Rectangle mbr(Collection<? extends HasGeometry> items) {\n        Preconditions.checkArgument(!items.isEmpty());\n        double minX1 = Double.MAX_VALUE;\n        double minY1 = Double.MAX_VALUE;\n        double maxX2 = -Double.MAX_VALUE;\n        double maxY2 = -Double.MAX_VALUE;\n        for (final HasGeometry item : items) {\n            Rectangle r = item.geometry().mbr();\n            if (r.x1() < minX1)\n                minX1 = r.x1();\n            if (r.y1() < minY1)\n                minY1 = r.y1();\n            if (r.x2() > maxX2)\n                maxX2 = r.x2();\n            if (r.y2() > maxY2)\n                maxY2 = r.y2();\n        }\n        return Geometries.rectangle(minX1, minY1, maxX2, maxY2);\n    }\n",
        "patched_function": "    public static Rectangle mbr(Collection<? extends HasGeometry> items) {\n        Preconditions.checkArgument(!items.isEmpty());\n        double minX1 = Double.MAX_VALUE;\n        double minY1 = Double.MAX_VALUE;\n        double maxX2 = -Double.MAX_VALUE;\n        double maxY2 = -Double.MAX_VALUE;\n        boolean isDoublePrecision = false;\n        for (final HasGeometry item : items) {\n            Rectangle r = item.geometry().mbr();\n            if (r.isDoublePrecision()) {\n                isDoublePrecision = true;\n            }\n            if (r.x1() < minX1)\n                minX1 = r.x1();\n            if (r.y1() < minY1)\n                minY1 = r.y1();\n            if (r.x2() > maxX2)\n                maxX2 = r.x2();\n            if (r.y2() > maxY2)\n                maxY2 = r.y2();\n        }\n        if (isDoublePrecision) {\n            return Geometries.rectangle(minX1, minY1, maxX2, maxY2);\n        } else {\n            return Geometries.rectangle((float) minX1, (float) minY1, (float) maxX2, (float) maxY2);\n        }\n    }"
    },
    "50": {
        "buggy_function": "        public Frame assign(Object... values) {\n            if (stack != null && values != null && values.length > 0) {\n                int nparm = scope.getArgCount();\n                Object[] copy = stack.clone();\n                int ncopy = Math.min(nparm - curried, Math.min(nparm, values.length));\n                System.arraycopy(values, 0, copy, curried, ncopy);\n                return new Frame(scope, copy, curried + ncopy);\n            }\n            return this;\n        }\n",
        "patched_function": "        public Frame assign(Object... values) {\n            if (stack != null) {\n                int nparm = scope.getArgCount();\n                Object[] copy = stack.clone();\n                int ncopy = 0;\n                if (values != null && values.length > 0) {\n                    ncopy = Math.min(nparm - curried, Math.min(nparm, values.length));\n                    System.arraycopy(values, 0, copy, curried, ncopy);\n                }\n                // unbound parameters are defined as null\n                Arrays.fill(copy, curried + ncopy, nparm, null);\n                return new Frame(scope, copy, curried + ncopy);\n            }\n            return this;\n        }"
    },
    "59": {
        "buggy_function": "\t@Override\n\tpublic OGCGeometry convexHull() {\n\t\tGeometryCursor cursor = OperatorConvexHull.local().execute(\n\t\t\t\tgetEsriGeometryCursor(), false, null);\n\t\tMultiPoint mp = new MultiPoint();\n\t\tPolygon polygon = new Polygon();\n\t\tVertexDescription vd = null;\n\t\tfor (Geometry geom = cursor.next(); geom != null; geom = cursor.next()) {\n\t\t\tvd = geom.getDescription();\n\t\t\tif (geom.isEmpty())\n\t\t\t\tcontinue;\n\n\t\t\tif (geom.getType() == Geometry.Type.Polygon) {\n\t\t\t\tpolygon.add((MultiPath) geom, false);\n\t\t\t}\n\t\t\telse if (geom.getType() == Geometry.Type.Polyline) {\n\t\t\t\tmp.add((MultiVertexGeometry) geom, 0, -1);\n\t\t\t}\n\t\t\telse if (geom.getType() == Geometry.Type.Point) {\n\t\t\t\tmp.add((Point) geom);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new GeometryException(\"internal error\");\n\t\t\t}\n\t\t}\n\n\t\tGeometry resultGeom = null;\n\t\tif (!mp.isEmpty()) {\n\t\t\tresultGeom = OperatorConvexHull.local().execute(mp, null);\n\t\t}\n\n\t\tif (!polygon.isEmpty()) {\n\t\t\tif (!resultGeom.isEmpty()) {\n\t\t\t\tGeometry[] geoms = { resultGeom, polygon };\n\t\t\t\tresultGeom = OperatorConvexHull.local().execute(\n\t\t\t\t\t\tnew SimpleGeometryCursor(geoms), true, null).next();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresultGeom = polygon;\n\t\t\t}\n\t\t}\n\n\t\tif (resultGeom == null) {\n\t\t\tPoint pt = new Point();\n\t\t\tif (vd != null)\n\t\t\t\tpt.assignVertexDescription(vd);\n\n\t\t\treturn new OGCPoint(pt, getEsriSpatialReference());\n\t\t}\n\n\t\treturn OGCGeometry.createFromEsriGeometry(resultGeom, getEsriSpatialReference(), false);\n\t}\n",
        "patched_function": "\t@Override\n\tpublic OGCGeometry convexHull() {\n\t\tGeometryCursor cursor = OperatorConvexHull.local().execute(\n\t\t\t\tgetEsriGeometryCursor(), false, null);\n\t\tMultiPoint mp = new MultiPoint();\n\t\tPolygon polygon = new Polygon();\n\t\tVertexDescription vd = null;\n\t\tfor (Geometry geom = cursor.next(); geom != null; geom = cursor.next()) {\n\t\t\tvd = geom.getDescription();\n\t\t\tif (geom.isEmpty())\n\t\t\t\tcontinue;\n\n\t\t\tif (geom.getType() == Geometry.Type.Polygon) {\n\t\t\t\tpolygon.add((MultiPath) geom, false);\n\t\t\t}\n\t\t\telse if (geom.getType() == Geometry.Type.Polyline) {\n\t\t\t\tmp.add((MultiVertexGeometry) geom, 0, -1);\n\t\t\t}\n\t\t\telse if (geom.getType() == Geometry.Type.Point) {\n\t\t\t\tmp.add((Point) geom);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new GeometryException(\"internal error\");\n\t\t\t}\n\t\t}\n\n\t\tGeometry resultGeom = null;\n\t\tif (!mp.isEmpty()) {\n\t\t\tresultGeom = OperatorConvexHull.local().execute(mp, null);\n\t\t}\n\n\t\tif (!polygon.isEmpty()) {\n\t\t\tif (resultGeom != null && !resultGeom.isEmpty()) {\n\t\t\t\tGeometry[] geoms = { resultGeom, polygon };\n\t\t\t\tresultGeom = OperatorConvexHull.local().execute(\n\t\t\t\t\t\tnew SimpleGeometryCursor(geoms), true, null).next();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresultGeom = OperatorConvexHull.local().execute(polygon, null);\n\t\t\t}\n\t\t}\n\n\t\tif (resultGeom == null) {\n\t\t\tPoint pt = new Point();\n\t\t\tif (vd != null)\n\t\t\t\tpt.assignVertexDescription(vd);\n\n\t\t\treturn new OGCPoint(pt, getEsriSpatialReference());\n\t\t}\n\n\t\treturn OGCGeometry.createFromEsriGeometry(resultGeom, getEsriSpatialReference(), false);\n\t}"
    },
    "62": {
        "buggy_function": "    @Override\n    public Y apply(final X input) throws Exception {\n        Y result = null;\n        for (int idx = 0; idx < this.times; ++idx) {\n            result = this.func.apply(input);\n        }\n        if (result == null) {\n            throw new IllegalArgumentException(\n                new FormattedText(\n                    \"Repeat counter is equal or less than zero: %d\",\n                    this.times\n                ).asString()\n            );\n        }\n        return result;\n    }\n",
        "patched_function": "    @Override\n    public Y apply(final X input) throws Exception {\n        if (this.times <= 0) {\n            throw new IllegalArgumentException(\n                \"The number of repetitions must be at least 1\"\n            );\n        }\n        Y result = null;\n        for (int idx = 0; idx < this.times; ++idx) {\n            result = this.func.apply(input);\n        }\n        return result;\n    }"
    },
    "64": {
        "buggy_function": "    private boolean parseField(DefaultJSONParser parser, String key, Object object, Type objectType,\n                              Map<String, Object> fieldValues) {\n        JSONLexer lexer = parser.lexer; // xxx\n\n        FieldDeserializer fieldDeserializer = getFieldDeserializer(key);\n\n        if (fieldDeserializer == null) {\n            long smartKeyHash = TypeUtils.fnv_64_lower(key);\n            if (this.smartMatchHashArray == null) {\n                long[] hashArray = new long[sortedFieldDeserializers.length];\n                for (int i = 0; i < sortedFieldDeserializers.length; i++) {\n                    hashArray[i] = TypeUtils.fnv_64_lower(sortedFieldDeserializers[i].fieldInfo.name);\n                }\n                Arrays.sort(hashArray);\n                this.smartMatchHashArray = hashArray;\n            }\n\n            // smartMatchHashArrayMapping\n\n            int pos = Arrays.binarySearch(smartMatchHashArray, smartKeyHash);\n            if (pos < 0 && key.startsWith(\"is\")) {\n                smartKeyHash = TypeUtils.fnv_64_lower(key.substring(2));\n                pos = Arrays.binarySearch(smartMatchHashArray, smartKeyHash);\n            }\n\n            if (pos >= 0) {\n                if (smartMatchHashArrayMapping == null) {\n                    int[] mapping = new int[smartMatchHashArray.length];\n                    Arrays.fill(mapping, -1);\n                    for (int i = 0; i < sortedFieldDeserializers.length; i++) {\n                        int p = Arrays.binarySearch(smartMatchHashArray\n                                , TypeUtils.fnv_64_lower(sortedFieldDeserializers[i].fieldInfo.name));\n                        if (p >= 0) {\n                            mapping[p] = i;\n                        }\n                    }\n                    smartMatchHashArrayMapping = mapping;\n                }\n\n                int deserIndex = smartMatchHashArrayMapping[pos];\n                if (deserIndex != -1) {\n                    fieldDeserializer = sortedFieldDeserializers[deserIndex];\n                }\n            }\n        }\n\n        final int mask = Feature.SupportNonPublicField.mask;\n        if (fieldDeserializer == null\n                && ((parser.lexer.features & mask) != 0\n                    || (this.beanInfo.parserFeatures & mask) != 0)) {\n            if (this.extraFieldDeserializers == null) {\n                ConcurrentHashMap extraFieldDeserializers = new ConcurrentHashMap<String, Object>(1, 0.75f, 1);\n                for (Class c = this.clazz; c != null && c != Object.class; c = c.getSuperclass()) {\n                    Field[] fields = c.getDeclaredFields();\n                    for (Field field : fields) {\n                        String fieldName = field.getName();\n                        if (this.getFieldDeserializer(fieldName) != null) {\n                            continue;\n                        }\n                        int fieldModifiers = field.getModifiers();\n                        if ((fieldModifiers & Modifier.FINAL) != 0 || (fieldModifiers & Modifier.STATIC) != 0) {\n                            continue;\n                        }\n                        extraFieldDeserializers.put(fieldName, field);\n                    }\n                }\n                this.extraFieldDeserializers = extraFieldDeserializers;\n            }\n\n            Object deserOrField = extraFieldDeserializers.get(key);\n            if (deserOrField != null) {\n                if (deserOrField instanceof FieldDeserializer) {\n                    fieldDeserializer = ((FieldDeserializer) deserOrField);\n                } else {\n                    Field field = (Field) deserOrField;\n                    field.setAccessible(true);\n                    FieldInfo fieldInfo = new FieldInfo(key, field.getDeclaringClass(), field.getType(), field.getGenericType(), field, 0, 0);\n                    fieldDeserializer = new DefaultFieldDeserializer(parser.config, clazz, fieldInfo);\n                    extraFieldDeserializers.put(key, fieldDeserializer);\n                }\n            }\n        }\n\n        if (fieldDeserializer == null) {\n            parseExtra(parser, object, key);\n\n            return false;\n        }\n\n        lexer.nextTokenWithChar(':');\n\n        fieldDeserializer.parseField(parser, object, objectType, fieldValues);\n\n        return true;\n    }\n",
        "patched_function": "    private boolean parseField(DefaultJSONParser parser, String key, Object object, Type objectType,\n                              Map<String, Object> fieldValues) {\n        JSONLexer lexer = parser.lexer; // xxx\n\n        FieldDeserializer fieldDeserializer = getFieldDeserializer(key);\n\n        if (fieldDeserializer == null) {\n            long smartKeyHash = TypeUtils.fnv_64_lower(key);\n            if (this.smartMatchHashArray == null) {\n                long[] hashArray = new long[sortedFieldDeserializers.length];\n                for (int i = 0; i < sortedFieldDeserializers.length; i++) {\n                    hashArray[i] = TypeUtils.fnv_64_lower(sortedFieldDeserializers[i].fieldInfo.name);\n                }\n                Arrays.sort(hashArray);\n                this.smartMatchHashArray = hashArray;\n            }\n\n            // smartMatchHashArrayMapping\n\n            int pos = Arrays.binarySearch(smartMatchHashArray, smartKeyHash);\n            boolean is = false;\n            if (pos < 0 && (is = key.startsWith(\"is\"))) {\n                smartKeyHash = TypeUtils.fnv_64_lower(key.substring(2));\n                pos = Arrays.binarySearch(smartMatchHashArray, smartKeyHash);\n            }\n\n            if (pos >= 0) {\n                if (smartMatchHashArrayMapping == null) {\n                    int[] mapping = new int[smartMatchHashArray.length];\n                    Arrays.fill(mapping, -1);\n                    for (int i = 0; i < sortedFieldDeserializers.length; i++) {\n                        int p = Arrays.binarySearch(smartMatchHashArray\n                                , TypeUtils.fnv_64_lower(sortedFieldDeserializers[i].fieldInfo.name));\n                        if (p >= 0) {\n                            mapping[p] = i;\n                        }\n                    }\n                    smartMatchHashArrayMapping = mapping;\n                }\n\n                int deserIndex = smartMatchHashArrayMapping[pos];\n                if (deserIndex != -1) {\n                    fieldDeserializer = sortedFieldDeserializers[deserIndex];\n                    Class fieldClass = fieldDeserializer.fieldInfo.fieldClass;\n                    if (is && (fieldClass != boolean.class && fieldClass != Boolean.class)) {\n                        fieldDeserializer = null;\n                    }\n                }\n            }\n        }\n\n        final int mask = Feature.SupportNonPublicField.mask;\n        if (fieldDeserializer == null\n                && ((parser.lexer.features & mask) != 0\n                    || (this.beanInfo.parserFeatures & mask) != 0)) {\n            if (this.extraFieldDeserializers == null) {\n                ConcurrentHashMap extraFieldDeserializers = new ConcurrentHashMap<String, Object>(1, 0.75f, 1);\n                for (Class c = this.clazz; c != null && c != Object.class; c = c.getSuperclass()) {\n                    Field[] fields = c.getDeclaredFields();\n                    for (Field field : fields) {\n                        String fieldName = field.getName();\n                        if (this.getFieldDeserializer(fieldName) != null) {\n                            continue;\n                        }\n                        int fieldModifiers = field.getModifiers();\n                        if ((fieldModifiers & Modifier.FINAL) != 0 || (fieldModifiers & Modifier.STATIC) != 0) {\n                            continue;\n                        }\n                        extraFieldDeserializers.put(fieldName, field);\n                    }\n                }\n                this.extraFieldDeserializers = extraFieldDeserializers;\n            }\n\n            Object deserOrField = extraFieldDeserializers.get(key);\n            if (deserOrField != null) {\n                if (deserOrField instanceof FieldDeserializer) {\n                    fieldDeserializer = ((FieldDeserializer) deserOrField);\n                } else {\n                    Field field = (Field) deserOrField;\n                    field.setAccessible(true);\n                    FieldInfo fieldInfo = new FieldInfo(key, field.getDeclaringClass(), field.getType(), field.getGenericType(), field, 0, 0);\n                    fieldDeserializer = new DefaultFieldDeserializer(parser.config, clazz, fieldInfo);\n                    extraFieldDeserializers.put(key, fieldDeserializer);\n                }\n            }\n        }\n\n        if (fieldDeserializer == null) {\n            parseExtra(parser, object, key);\n\n            return false;\n        }\n\n        lexer.nextTokenWithChar(':');\n\n        fieldDeserializer.parseField(parser, object, objectType, fieldValues);\n\n        return true;\n    }"
    },
    "69": {
        "buggy_function": "    public Object createInstance(Map<String, Object> map, ParserConfig config) //\n                                                                               throws IllegalArgumentException,\n                                                                               IllegalAccessException,\n                                                                               InvocationTargetException {\n        Object object = null;\n        \n        if (beanInfo.creatorConstructor == null && beanInfo.factoryMethod == null) {\n            object = createInstance(null, clazz);\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser == null) {\n                    continue;\n                }\n\n                final FieldInfo fieldInfo = fieldDeser.fieldInfo;\n                Field field = fieldDeser.fieldInfo.field;\n                Type paramType = fieldInfo.fieldType;\n\n                if (field != null) {\n                    if (paramType == boolean.class) {\n                        if (value == Boolean.FALSE) {\n                            field.setBoolean(object, false);\n                            continue;\n                        }\n\n                        if (value == Boolean.TRUE) {\n                            field.setBoolean(object, true);\n                            continue;\n                        }\n                    } else if (paramType == int.class) {\n                        if (value instanceof Number) {\n                            field.setInt(object, ((Number) value).intValue());\n                            continue;\n                        }\n                    } else if (paramType == long.class) {\n                        if (value instanceof Number) {\n                            field.setLong(object, ((Number) value).longValue());\n                            continue;\n                        }\n                    } else if (paramType == float.class) {\n                        if (value instanceof Number) {\n                            field.setFloat(object, ((Number) value).floatValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            float floatValue;\n                            if (strVal.length() <= 10) {\n                                floatValue = TypeUtils.parseFloat(strVal);\n                            } else {\n                                floatValue = Float.parseFloat(strVal);\n                            }\n\n                            field.setFloat(object, floatValue);\n                            continue;\n                        }\n                    } else if (paramType == double.class) {\n                        if (value instanceof Number) {\n                            field.setDouble(object, ((Number) value).doubleValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            double doubleValue;\n                            if (strVal.length() <= 10) {\n                                doubleValue = TypeUtils.parseDouble(strVal);\n                            } else {\n                                doubleValue = Double.parseDouble(strVal);\n                            }\n\n                            field.setDouble(object, doubleValue);\n                            continue;\n                        }\n                    } else if (value != null && paramType == value.getClass()) {\n                        field.set(object, value);\n                        continue;\n                    }\n                }\n\n                String format = fieldInfo.format;\n                if (format != null && paramType == java.util.Date.class) {\n                    value = TypeUtils.castToDate(value, format);\n                } else {\n                    if (paramType instanceof ParameterizedType) {\n                        value = TypeUtils.cast(value, (ParameterizedType) paramType, config);\n                    } else {\n                        value = TypeUtils.cast(value, paramType, config);\n                    }\n                }\n\n                fieldDeser.setValue(object, value);\n            }\n\n            if (beanInfo.buildMethod != null) {\n                Object builtObj;\n                try {\n                    builtObj = beanInfo.buildMethod.invoke(object);\n                } catch (Exception e) {\n                    throw new JSONException(\"build object error\", e);\n                }\n\n                return builtObj;\n            }\n\n            return object;\n        }\n\n        \n        FieldInfo[] fieldInfoList = beanInfo.fields;\n        int size = fieldInfoList.length;\n        Object[] params = new Object[size];\n        Map<String, Integer> missFields = null;\n        for (int i = 0; i < size; ++i) {\n            FieldInfo fieldInfo = fieldInfoList[i];\n            Object param = map.get(fieldInfo.name);\n\n            if (param == null) {\n                Class<?> fieldClass = fieldInfo.fieldClass;\n                if (fieldClass == int.class) {\n                    param = 0;\n                } else if (fieldClass == long.class) {\n                    param = 0L;\n                } else if (fieldClass == short.class) {\n                    param = Short.valueOf((short) 0);\n                } else if (fieldClass == byte.class) {\n                    param = Byte.valueOf((byte) 0);\n                } else if (fieldClass == float.class) {\n                    param = Float.valueOf(0);\n                } else if (fieldClass == double.class) {\n                    param = Double.valueOf(0);\n                } else if (fieldClass == char.class) {\n                    param = '0';\n                } else if (fieldClass == boolean.class) {\n                    param = false;\n                }\n                if (missFields == null) {\n                    missFields = new HashMap<String, Integer>();\n                }\n                missFields.put(fieldInfo.name, i);\n            }\n            params[i] = param;\n        }\n\n        if (missFields != null) {\n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser != null) {\n                    Integer index = missFields.get(fieldDeser.fieldInfo.name);\n                    if (index != null) {\n                        params[index] = value;\n                    }\n                }\n            }\n        }\n\n        if (beanInfo.creatorConstructor != null) {\n            boolean hasNull = false;\n            if (beanInfo.kotlin) {\n                for (int i = 0; i < params.length; i++) {\n                    if (params[i] == null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                        FieldInfo fieldInfo = beanInfo.fields[i];\n                        if (fieldInfo.fieldClass == String.class) {\n                            hasNull = true;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            if (hasNull && beanInfo.kotlinDefaultConstructor != null) {\n                try {\n                    object = beanInfo.kotlinDefaultConstructor.newInstance();\n\n                    for (int i = 0; i < params.length; i++) {\n                        final Object param = params[i];\n                        if (param != null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                            FieldInfo fieldInfo = beanInfo.fields[i];\n                            fieldInfo.set(object, param);\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            } else {\n                try {\n                    object = beanInfo.creatorConstructor.newInstance(params);\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            }\n        } else if (beanInfo.factoryMethod != null) {\n            try {\n                object = beanInfo.factoryMethod.invoke(null, params);\n            } catch (Exception e) {\n                throw new JSONException(\"create factory method error, \" + beanInfo.factoryMethod.toString(), e);\n            }\n        }\n        \n        return object;\n    }\n",
        "patched_function": "    public Object createInstance(Map<String, Object> map, ParserConfig config) //\n                                                                               throws IllegalArgumentException,\n                                                                               IllegalAccessException,\n                                                                               InvocationTargetException {\n        Object object = null;\n        \n        if (beanInfo.creatorConstructor == null && beanInfo.factoryMethod == null) {\n            object = createInstance(null, clazz);\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser == null) {\n                    continue;\n                }\n\n                final FieldInfo fieldInfo = fieldDeser.fieldInfo;\n                Field field = fieldDeser.fieldInfo.field;\n                Type paramType = fieldInfo.fieldType;\n\n                if (field != null) {\n                    Class fieldType = field.getType();\n                    if (fieldType == boolean.class) {\n                        if (value == Boolean.FALSE) {\n                            field.setBoolean(object, false);\n                            continue;\n                        }\n\n                        if (value == Boolean.TRUE) {\n                            field.setBoolean(object, true);\n                            continue;\n                        }\n                    } else if (fieldType == int.class) {\n                        if (value instanceof Number) {\n                            field.setInt(object, ((Number) value).intValue());\n                            continue;\n                        }\n                    } else if (fieldType == long.class) {\n                        if (value instanceof Number) {\n                            field.setLong(object, ((Number) value).longValue());\n                            continue;\n                        }\n                    } else if (fieldType == float.class) {\n                        if (value instanceof Number) {\n                            field.setFloat(object, ((Number) value).floatValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            float floatValue;\n                            if (strVal.length() <= 10) {\n                                floatValue = TypeUtils.parseFloat(strVal);\n                            } else {\n                                floatValue = Float.parseFloat(strVal);\n                            }\n\n                            field.setFloat(object, floatValue);\n                            continue;\n                        }\n                    } else if (fieldType == double.class) {\n                        if (value instanceof Number) {\n                            field.setDouble(object, ((Number) value).doubleValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            double doubleValue;\n                            if (strVal.length() <= 10) {\n                                doubleValue = TypeUtils.parseDouble(strVal);\n                            } else {\n                                doubleValue = Double.parseDouble(strVal);\n                            }\n\n                            field.setDouble(object, doubleValue);\n                            continue;\n                        }\n                    } else if (value != null && paramType == value.getClass()) {\n                        field.set(object, value);\n                        continue;\n                    }\n                }\n\n                String format = fieldInfo.format;\n                if (format != null && paramType == java.util.Date.class) {\n                    value = TypeUtils.castToDate(value, format);\n                } else {\n                    if (paramType instanceof ParameterizedType) {\n                        value = TypeUtils.cast(value, (ParameterizedType) paramType, config);\n                    } else {\n                        value = TypeUtils.cast(value, paramType, config);\n                    }\n                }\n\n                fieldDeser.setValue(object, value);\n            }\n\n            if (beanInfo.buildMethod != null) {\n                Object builtObj;\n                try {\n                    builtObj = beanInfo.buildMethod.invoke(object);\n                } catch (Exception e) {\n                    throw new JSONException(\"build object error\", e);\n                }\n\n                return builtObj;\n            }\n\n            return object;\n        }\n\n        \n        FieldInfo[] fieldInfoList = beanInfo.fields;\n        int size = fieldInfoList.length;\n        Object[] params = new Object[size];\n        Map<String, Integer> missFields = null;\n        for (int i = 0; i < size; ++i) {\n            FieldInfo fieldInfo = fieldInfoList[i];\n            Object param = map.get(fieldInfo.name);\n\n            if (param == null) {\n                Class<?> fieldClass = fieldInfo.fieldClass;\n                if (fieldClass == int.class) {\n                    param = 0;\n                } else if (fieldClass == long.class) {\n                    param = 0L;\n                } else if (fieldClass == short.class) {\n                    param = Short.valueOf((short) 0);\n                } else if (fieldClass == byte.class) {\n                    param = Byte.valueOf((byte) 0);\n                } else if (fieldClass == float.class) {\n                    param = Float.valueOf(0);\n                } else if (fieldClass == double.class) {\n                    param = Double.valueOf(0);\n                } else if (fieldClass == char.class) {\n                    param = '0';\n                } else if (fieldClass == boolean.class) {\n                    param = false;\n                }\n                if (missFields == null) {\n                    missFields = new HashMap<String, Integer>();\n                }\n                missFields.put(fieldInfo.name, i);\n            }\n            params[i] = param;\n        }\n\n        if (missFields != null) {\n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser != null) {\n                    Integer index = missFields.get(fieldDeser.fieldInfo.name);\n                    if (index != null) {\n                        params[index] = value;\n                    }\n                }\n            }\n        }\n\n        if (beanInfo.creatorConstructor != null) {\n            boolean hasNull = false;\n            if (beanInfo.kotlin) {\n                for (int i = 0; i < params.length; i++) {\n                    if (params[i] == null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                        FieldInfo fieldInfo = beanInfo.fields[i];\n                        if (fieldInfo.fieldClass == String.class) {\n                            hasNull = true;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            if (hasNull && beanInfo.kotlinDefaultConstructor != null) {\n                try {\n                    object = beanInfo.kotlinDefaultConstructor.newInstance();\n\n                    for (int i = 0; i < params.length; i++) {\n                        final Object param = params[i];\n                        if (param != null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                            FieldInfo fieldInfo = beanInfo.fields[i];\n                            fieldInfo.set(object, param);\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            } else {\n                try {\n                    object = beanInfo.creatorConstructor.newInstance(params);\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            }\n        } else if (beanInfo.factoryMethod != null) {\n            try {\n                object = beanInfo.factoryMethod.invoke(null, params);\n            } catch (Exception e) {\n                throw new JSONException(\"create factory method error, \" + beanInfo.factoryMethod.toString(), e);\n            }\n        }\n        \n        return object;\n    }"
    },
    "70": {
        "buggy_function": "    private static Type getInheritGenericType(Class<?> clazz, Type type, TypeVariable<?> tv) {\n        Class<?> gd = (Class<?>) tv.getGenericDeclaration();\n\n        Type[] arguments = null;\n        if (gd == clazz) {\n            if (type instanceof ParameterizedType) {\n                ParameterizedType ptype = (ParameterizedType) type;\n                arguments = ptype.getActualTypeArguments();\n            }\n        } else {\n            for (Class<?> c = clazz; c != null && c != Object.class && c != gd; c = c.getSuperclass()) {\n                Type superType = c.getGenericSuperclass();\n\n                if (superType instanceof ParameterizedType) {\n                    ParameterizedType p_superType = (ParameterizedType) superType;\n                    Type[] p_superType_args = p_superType.getActualTypeArguments();\n                    getArgument(p_superType_args, c.getTypeParameters(), arguments);\n                    arguments = p_superType_args;\n                }\n            }\n        }\n\n        if (arguments == null) {\n            return null;\n        }\n\n        Type actualType = null;\n        TypeVariable<?>[] typeVariables = gd.getTypeParameters();\n        for (int j = 0; j < typeVariables.length; ++j) {\n            if (tv.equals(typeVariables[j])) {\n                actualType = arguments[j];\n                break;\n            }\n        }\n\n        return actualType;\n    }\n",
        "patched_function": "    private static Type getInheritGenericType(Class<?> clazz, Type type, TypeVariable<?> tv) {\n        GenericDeclaration gd = tv.getGenericDeclaration();\n\n        Class<?> class_gd = null;\n        if (gd instanceof Class) {\n            class_gd = (Class<?>) tv.getGenericDeclaration();\n        }\n\n        Type[] arguments = null;\n        if (class_gd == clazz) {\n            if (type instanceof ParameterizedType) {\n                ParameterizedType ptype = (ParameterizedType) type;\n                arguments = ptype.getActualTypeArguments();\n            }\n        } else {\n            for (Class<?> c = clazz; c != null && c != Object.class && c != class_gd; c = c.getSuperclass()) {\n                Type superType = c.getGenericSuperclass();\n\n                if (superType instanceof ParameterizedType) {\n                    ParameterizedType p_superType = (ParameterizedType) superType;\n                    Type[] p_superType_args = p_superType.getActualTypeArguments();\n                    getArgument(p_superType_args, c.getTypeParameters(), arguments);\n                    arguments = p_superType_args;\n                }\n            }\n        }\n\n        if (arguments == null) {\n            return null;\n        }\n\n        Type actualType = null;\n        TypeVariable<?>[] typeVariables = class_gd.getTypeParameters();\n        for (int j = 0; j < typeVariables.length; ++j) {\n            if (tv.equals(typeVariables[j])) {\n                actualType = arguments[j];\n                break;\n            }\n        }\n\n        return actualType;\n    }"
    },
    "71": {
        "buggy_function": "    public boolean scanFieldBoolean(char[] fieldName) {\n        matchStat = UNKNOWN;\n\n        if (!charArrayCompare(text, bp, fieldName)) {\n            matchStat = NOT_MATCH_NAME;\n            return false;\n        }\n\n        int index = bp + fieldName.length;\n\n        char ch = charAt(index++);\n\n        final boolean quote = ch == '\"';\n        if (quote) {\n            ch = charAt(index++);\n        }\n\n        boolean value;\n        if (ch == 't') {\n            if (charAt(index++) != 'r') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'u') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'e') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            if (quote && charAt(index++) != '\"') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            bp = index;\n            ch = charAt(bp);\n            value = true;\n        } else if (ch == 'f') {\n            if (charAt(index++) != 'a') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'l') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 's') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'e') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            if (quote && charAt(index++) != '\"') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            bp = index;\n            ch = charAt(bp);\n            value = false;\n        } else if (ch == '1') {\n                if (quote && charAt(index++) != '\"') {\n                    matchStat = NOT_MATCH;\n                    return false;\n                }\n\n                bp = index;\n                ch = charAt(bp);\n                value = true;\n        } else if (ch == '0') {\n            if (quote && charAt(index++) != '\"') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            bp = index;\n            ch = charAt(bp);\n            value = false;\n        } else {\n            matchStat = NOT_MATCH;\n            return false;\n        }\n\n        for (;;) {\n            if (ch == ',') {\n                this.ch = charAt(++bp);\n                matchStat = VALUE;\n                token = JSONToken.COMMA;\n                break;\n            } else if (ch == '}') {\n                ch = charAt(++bp);\n                for (;;) {\n                    if (ch == ',') {\n                        token = JSONToken.COMMA;\n                        this.ch = charAt(++bp);\n                    } else if (ch == ']') {\n                        token = JSONToken.RBRACKET;\n                        this.ch = charAt(++bp);\n                    } else if (ch == '}') {\n                        token = JSONToken.RBRACE;\n                        this.ch = charAt(++bp);\n                    } else if (ch == EOI) {\n                        token = JSONToken.EOF;\n                    } else if (isWhitespace(ch)) {\n                        ch = charAt(++bp);\n                        continue;\n                    } else {\n                        matchStat = NOT_MATCH;\n                        return false;\n                    }\n                    break;\n                }\n                matchStat = END;\n                break;\n            } else if (isWhitespace(ch)) {\n                ch = charAt(++bp);\n            } else {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n        }\n\n        return value;\n    }\n",
        "patched_function": "    public boolean scanFieldBoolean(char[] fieldName) {\n        matchStat = UNKNOWN;\n\n        if (!charArrayCompare(text, bp, fieldName)) {\n            matchStat = NOT_MATCH_NAME;\n            return false;\n        }\n\n        int startPos = bp;\n        int index = bp + fieldName.length;\n\n        char ch = charAt(index++);\n\n        final boolean quote = ch == '\"';\n        if (quote) {\n            ch = charAt(index++);\n        }\n\n        boolean value;\n        if (ch == 't') {\n            if (charAt(index++) != 'r') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'u') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'e') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            if (quote && charAt(index++) != '\"') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            bp = index;\n            ch = charAt(bp);\n            value = true;\n        } else if (ch == 'f') {\n            if (charAt(index++) != 'a') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'l') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 's') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n            if (charAt(index++) != 'e') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            if (quote && charAt(index++) != '\"') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            bp = index;\n            ch = charAt(bp);\n            value = false;\n        } else if (ch == '1') {\n                if (quote && charAt(index++) != '\"') {\n                    matchStat = NOT_MATCH;\n                    return false;\n                }\n\n                bp = index;\n                ch = charAt(bp);\n                value = true;\n        } else if (ch == '0') {\n            if (quote && charAt(index++) != '\"') {\n                matchStat = NOT_MATCH;\n                return false;\n            }\n\n            bp = index;\n            ch = charAt(bp);\n            value = false;\n        } else {\n            matchStat = NOT_MATCH;\n            return false;\n        }\n\n        for (;;) {\n            if (ch == ',') {\n                this.ch = charAt(++bp);\n                matchStat = VALUE;\n                token = JSONToken.COMMA;\n                break;\n            } else if (ch == '}') {\n                ch = charAt(++bp);\n                for (;;) {\n                    if (ch == ',') {\n                        token = JSONToken.COMMA;\n                        this.ch = charAt(++bp);\n                    } else if (ch == ']') {\n                        token = JSONToken.RBRACKET;\n                        this.ch = charAt(++bp);\n                    } else if (ch == '}') {\n                        token = JSONToken.RBRACE;\n                        this.ch = charAt(++bp);\n                    } else if (ch == EOI) {\n                        token = JSONToken.EOF;\n                    } else if (isWhitespace(ch)) {\n                        ch = charAt(++bp);\n                        continue;\n                    } else {\n                        matchStat = NOT_MATCH;\n                        return false;\n                    }\n                    break;\n                }\n                matchStat = END;\n                break;\n            } else if (isWhitespace(ch)) {\n                ch = charAt(++bp);\n            } else {\n                bp = startPos;\n                ch = charAt(bp);\n                matchStat = NOT_MATCH;\n                return false;\n            }\n        }\n\n        return value;\n    }"
    },
    "78": {
        "buggy_function": "\t@SuppressWarnings(\"null\")\n\tprivate Supplier<ConversionService> getConversionService() {\n\n\t\treturn () -> {\n\n\t\t\tRequestAttributes attributes = RequestContextHolder.getRequestAttributes();\n\n\t\t\tif (!ServletRequestAttributes.class.isInstance(attributes)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tServletContext servletContext = ((ServletRequestAttributes) attributes).getRequest().getServletContext();\n\t\t\tWebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext);\n\n\t\t\treturn context == null || !context.containsBean(\"mvcConversionService\")\n\t\t\t\t\t? FALLBACK_CONVERSION_SERVICE\n\t\t\t\t\t: context.getBean(\"mvcConversionService\", ConversionService.class);\n\t\t};\n\t}\n",
        "patched_function": "\tprivate static Supplier<ConversionService> getConversionService() {\n\n\t\treturn () -> {\n\n\t\t\tRequestAttributes attributes = RequestContextHolder.getRequestAttributes();\n\n\t\t\tif (attributes == null || !ServletRequestAttributes.class.isInstance(attributes)) {\n\t\t\t\treturn FALLBACK_CONVERSION_SERVICE;\n\t\t\t}\n\n\t\t\tServletContext servletContext = ((ServletRequestAttributes) attributes).getRequest().getServletContext();\n\t\t\tWebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext);\n\n\t\t\treturn context == null || !context.containsBean(\"mvcConversionService\")\n\t\t\t\t\t? FALLBACK_CONVERSION_SERVICE\n\t\t\t\t\t: context.getBean(\"mvcConversionService\", ConversionService.class);\n\t\t};\n\t}"
    },
    "83": {
        "buggy_function": "  @SuppressWarnings(\"unchecked\")\n  private int mergeRange(ParentSoyNode<?> parent, int start, int lastNonEmptyRawTextNode, int end) {\n    checkArgument(start < end);\n    if (start == -1 || end == start + 1) {\n      return end;\n    }\n    // general case, there are N rawtextnodes to merge where n > 1\n    // merge all the nodes together, then drop all the raw text nodes from the end\n    RawTextNode newNode =\n        RawTextNode.concat(\n            (List<RawTextNode>) parent.getChildren().subList(start, lastNonEmptyRawTextNode + 1));\n    ((ParentSoyNode) parent).replaceChild(start, newNode);\n    for (int i = end - 1; i > start; i--) {\n      parent.removeChild(i);\n    }\n    return start + 1;\n  }\n",
        "patched_function": "  @SuppressWarnings(\"unchecked\")\n  private int mergeRange(ParentSoyNode<?> parent, int start, int lastNonEmptyRawTextNode, int end) {\n    checkArgument(start < end);\n    if (start == -1 || end == start + 1) {\n      return end;\n    }\n    // general case, there are N rawtextnodes to merge where n > 1\n    // merge all the nodes together, then drop all the raw text nodes from the end\n    if (start < lastNonEmptyRawTextNode) {\n      RawTextNode newNode =\n          RawTextNode.concat(\n              (List<RawTextNode>) parent.getChildren().subList(start, lastNonEmptyRawTextNode + 1));\n\n      ((ParentSoyNode) parent).replaceChild(start, newNode);\n    }\n\n    for (int i = end - 1; i > start; i--) {\n      parent.removeChild(i);\n    }\n    return start + 1;\n  }"
    },
    "85": {
        "buggy_function": "  @Override\n  protected Expression visitVeLiteralNode(VeLiteralNode node) {\n    ValidatedLoggableElement element = node.getLoggableElement();\n    Expression metadata;\n    if (element.hasMetadata()) {\n      metadata =\n          GoogRequire.create(element.getJsPackage())\n              .googModuleGet()\n              .dotAccess(element.getClassName())\n              .dotAccess(element.getGeneratedVeMetadataMethodName())\n              .call();\n    } else {\n      metadata = Expression.LITERAL_UNDEFINED;\n    }\n    return Expression.ifExpression(\n            GOOG_DEBUG,\n            construct(\n                SOY_VISUAL_ELEMENT,\n                Expression.number(node.getId()),\n                metadata,\n                Expression.stringLiteral(node.getName().identifier())))\n        .setElse(construct(SOY_VISUAL_ELEMENT, Expression.number(node.getId()), metadata))\n        .build(codeGenerator);\n  }\n",
        "patched_function": "  @Override\n  protected Expression visitVeLiteralNode(VeLiteralNode node) {\n    return Expression.ifExpression(\n            GOOG_DEBUG,\n            construct(\n                SOY_VISUAL_ELEMENT,\n                Expression.number(node.getId()),\n                Expression.stringLiteral(node.getName().identifier())))\n        .setElse(construct(SOY_VISUAL_ELEMENT, Expression.number(node.getId())))\n        .build(codeGenerator);\n  }"
    },
    "94": {
        "buggy_function": "    public boolean invokeHook(Signature routeSignature, Route hookRoute) throws Exception {\n        Method hookMethod = hookRoute.getAction();\n        Object target     = hookRoute.getTarget();\n        if (null == target) {\n            Class<?> clazz = hookRoute.getAction().getDeclaringClass();\n            target = ioc.getBean(clazz);\n            hookRoute.setTarget(target);\n        }\n\n        // execute\n        int len = hookMethod.getParameterTypes().length;\n        hookMethod.setAccessible(true);\n\n        Object returnParam;\n        if (len > 0) {\n            returnParam = ReflectKit.invokeMethod(target, hookMethod, routeSignature);\n        } else {\n            returnParam = ReflectKit.invokeMethod(target, hookMethod);\n        }\n\n        if (null == returnParam) return true;\n\n        Class<?> returnType = returnParam.getClass();\n        if (returnType == Boolean.class || returnType == boolean.class) {\n            return Boolean.valueOf(returnParam.toString());\n        }\n        return true;\n    }\n",
        "patched_function": "    public boolean invokeHook(Signature routeSignature, Route hookRoute) throws Exception {\n        Method hookMethod = hookRoute.getAction();\n        Object target     = hookRoute.getTarget();\n        if (null == target) {\n            Class<?> clazz = hookRoute.getAction().getDeclaringClass();\n            target = ioc.getBean(clazz);\n            hookRoute.setTarget(target);\n        }\n\n        // execute\n        int len = hookMethod.getParameterTypes().length;\n        hookMethod.setAccessible(true);\n\n        Object returnParam;\n        if (len > 0) {\n            if (len == 1) {\n                returnParam = ReflectKit.invokeMethod(target, hookMethod, routeSignature);\n            } else if (len == 2) {\n                returnParam = ReflectKit.invokeMethod(target, hookMethod, routeSignature.request(), routeSignature.response());\n            } else {\n                throw new InternalErrorException(\"Bad web hook structure\");\n            }\n        } else {\n            returnParam = ReflectKit.invokeMethod(target, hookMethod);\n        }\n\n        if (null == returnParam) return true;\n\n        Class<?> returnType = returnParam.getClass();\n        if (returnType == Boolean.class || returnType == boolean.class) {\n            return Boolean.valueOf(returnParam.toString());\n        }\n        return true;\n    }"
    },
    "99": {
        "buggy_function": "    public static void copyFile(final File srcFile, final File destFile, final boolean preserveFileDate, CopyOption... copyOptions) throws IOException {\n        Objects.requireNonNull(destFile, \"destination\");\n        checkFileExists(srcFile, \"srcFile\");\n        requireCanonicalPathsNotEquals(srcFile, destFile);\n        createParentDirectories(destFile);\n        if (destFile.exists()) {\n            checkFileExists(destFile, \"destFile\");\n            requireCanWrite(destFile, \"destFile\");\n        }\n\n        final Path srcPath = srcFile.toPath();\n        final boolean isSymLink = Files.isSymbolicLink(srcPath);\n        if (isSymLink && !Arrays.asList(copyOptions).contains(LinkOption.NOFOLLOW_LINKS)) {\n            final List<CopyOption> list = new ArrayList<>(Arrays.asList(copyOptions));\n            list.add(LinkOption.NOFOLLOW_LINKS);\n            copyOptions = list.toArray(PathUtils.EMPTY_COPY_OPTIONS);\n        }\n\n        Files.copy(srcPath, destFile.toPath(), copyOptions);\n\n        // On Windows, the last modified time is copied by default.\n        if (preserveFileDate && !isSymLink && !setTimes(srcFile, destFile)) {\n            throw new IOException(\"Cannot set the file time.\");\n        }\n    }\n",
        "patched_function": "    public static void copyFile(final File srcFile, final File destFile, final boolean preserveFileDate) throws IOException {\n        copyFile(srcFile, destFile, preserveFileDate, StandardCopyOption.REPLACE_EXISTING);\n    }"
    }
}