{
    "2": {
        "patched_method": "  private void readUntilEndOfEntry() throws IOException {\nif (localFileHeader.isDirectory() && localFileHeader.getCompressedSize() == 0) { \n      return;\n    }\n\n    if (endOfEntryBuffer == null) {\n      endOfEntryBuffer = new byte[512];\n    }\n\n    while (read(endOfEntryBuffer) != -1);\n  }\n",
        "diff": "if (localFileHeader.isDirectory() && localFileHeader.getCompressedSize() == 0) { \n"
    },
    "5": {
        "patched_method": "    public @Override String getName() {\n   \tif (testName == null || testName.isEmpty()) { \n    \t\treturn \"(?)\";\n    \t}\n        return testName;\n    }\n",
        "diff": "   \tif (testName == null || testName.isEmpty()) { \n"
    },
    "10": {
        "patched_method": "\tprivate static boolean isAssignableFrom(Class<?> target, KType source) {\n\n\t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n\nreturn ResolvableType.forClass(target).isAssignableFrom(ResolvableType.forType(parameterType).resolve()); \n\t}\n",
        "diff": "return ResolvableType.forClass(target).isAssignableFrom(ResolvableType.forType(parameterType).resolve()); \n"
    },
    "17": {
        "patched_method": "    protected Object getArrayItem(final Object currentObject, int index) {\n        if (currentObject == null) {\n            return null;\n        }\n\n        if (currentObject instanceof List) {\n            List list = (List) currentObject;\n\n            if (index >= 0) {\n                if (index < list.size()) {\n                    return list.get(index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= list.size()) {\n                    return list.get(list.size() + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject.getClass().isArray()) {\n            int arrayLenth = Array.getLength(currentObject);\n\n            if (index >= 0) {\n                if (index < arrayLenth) {\n                    return Array.get(currentObject, index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= arrayLenth) {\n                    return Array.get(currentObject, arrayLenth + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject instanceof Map) {\n            Map map = (Map) currentObject;\n            Object value = map.get(index);\n            if (value == null) {\n                value = map.get(Integer.toString(index));\n            }\n            return value;\n        }\n\n        if (currentObject instanceof Collection) {\n            Collection collection = (Collection) currentObject;\n            int i = 0;\n            for (Object item : collection) {\n                if (i == index) {\n                    return item;\n                }\n                i++;\n            }\n            return null;\n        }\n\n       if (index == 0) {             return currentObject;         } \n        throw new UnsupportedOperationException();\n    }\n",
        "diff": "       if (index == 0) {             return currentObject;         } \n"
    },
    "21": {
        "patched_method": "    public SQLExpr orRest(SQLExpr expr) {\n        for (;;) {\n            if (lexer.token == Token.OR) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                if (lexer.token == Token.OR\n                        && lexer.isEnabled(SQLParserFeature.EnableSQLBinaryOpExprGroup)) {\n\n                    SQLBinaryOpExprGroup group = new SQLBinaryOpExprGroup(SQLBinaryOperator.BooleanOr, dbType);\n                    group.add(expr);\n                    group.add(rightExp);\n\n                    if (lexer.isKeepComments() && lexer.hasComment()) {\n                        rightExp.addAfterComment(lexer.readAndResetComments());\n                    }\n\n                    for (;;) {\n                        lexer.nextToken();\n                       SQLExpr more = and(); \n                        group.add(more);\n                        if (lexer.token == Token.OR) {\n                            if (lexer.isKeepComments() && lexer.hasComment()) {\n                                more.addAfterComment(lexer.readAndResetComments());\n                            }\n\n                            continue;\n                        }\n                        break;\n                    }\n\n                    expr = group;\n                } else {\n                    expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, dbType);\n                }\n            } else  if (lexer.token == Token.BARBAR && JdbcConstants.MYSQL.equals(dbType)) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanOr, rightExp, dbType);\n            } else if (lexer.token == Token.XOR) {\n                lexer.nextToken();\n                SQLExpr rightExp = and();\n\n                expr = new SQLBinaryOpExpr(expr, SQLBinaryOperator.BooleanXor, rightExp, dbType);\n            } else {\n                break;\n            }\n        }\n\n        return expr;\n    }\n",
        "diff": "                       SQLExpr more = and(); \n"
    },
    "30": {
        "patched_method": "\tpublic String[] rowParsed() {\n\t\t// some values were parsed. Let's return them\n\t\tif (column > 0) {\n\t\t\t// identifies selected columns and headers (in the first non-empty row)\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t\t//skips the header row. We want to use the headers defined in the settings.\n\t\t\t\tif (settings.isHeaderExtractionEnabled()) {\n\t\t\t\t\tArrays.fill(parsedValues, null);\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tthis.appender = appenders[0];\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (!columnsReordered && selectedIndexes != null) {\n\t\t\t\t\tString[] out = new String[column];\n\t\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\t\tif (index < column) {\n\t\t\t\t\t\t\tout[index] = parsedValues[index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\treturn out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n\t\t\t\t\tcolumn = 0; \t\t\t\t\tthis.appender = appenders[0]; \n\t\t\t\t\t// column = 0;\n\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] reorderedValues = new String[selectedIndexes.length];\n\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\tif (index >= column || index == -1) {\n\t\t\t\t\t\treorderedValues[i] = nullValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treorderedValues[i] = parsedValues[index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn reorderedValues;\n\t\t\t} else {\n\t\t\t\tint last = columnReorderingEnabledSetting ? column : column < headers.length ? headers.length : column;\n\n\t\t\t\tString[] out = new String[last];\n\t\t\t\tSystem.arraycopy(parsedValues, 0, out, 0, column);\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn out;\n\t\t\t}\n\t\t} else if (!skipEmptyLines) { //no values were parsed, but we are not skipping empty lines\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] out = new String[selectedIndexes.length];\n\t\t\t\tArrays.fill(out, nullValue);\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t}\n\t\t// no values were parsed and we do not care about empty lines.\n\t\treturn null;\n\t}\n",
        "diff": "\t\t\t\t\tcolumn = 0; \t\t\t\t\tthis.appender = appenders[0]; \n"
    },
    "34": {
        "patched_method": "\tprivate <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n\t\ttry {\n\t\t\tIterator[] iterators = new Iterator[rowData.size()];\n\t\t\tObject[] keys = new Object[rowData.size()];\n\t\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<Object, Object>(rowData.size());\n\n\t\t\tif(headerMapping == null){ \n\t\t\t\tif(headerMapping != null){\n\t\t\t\t\tsetHeadersFromMap(headerMapping, true);\n\t\t\t\t} else {\n\t\t\t\t\tsetHeadersFromMap(rowData, true);\n\t\t\t\t}\n\t\t\t\tif(isHeaderWritingEnabled && recordCount == 0){\n\t\t\t\t\toutputList.add(writeHeadersToString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint length = 0;\n\t\t\tfor (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n\t\t\t\titerators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n\t\t\t\tkeys[length] = rowEntry.getKey();\n\t\t\t\trowValues.put(rowEntry.getKey(), null);\n\t\t\t\tlength++;\n\t\t\t}\n\t\t\tboolean nullsOnly;\n\n\t\t\tdo {\n\t\t\t\tnullsOnly = true;\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tIterator<?> iterator = iterators[i];\n\t\t\t\t\tboolean isNull = iterator == null || !iterator.hasNext();\n\t\t\t\t\tnullsOnly &= isNull;\n\t\t\t\t\tif (isNull) {\n\t\t\t\t\t\trowValues.put(keys[i], null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trowValues.put(keys[i], iterator.next());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!nullsOnly) {\n\t\t\t\t\tif (outputList == null) {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\tprocessRecord((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteRow((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\toutputList.add(processRecordToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toutputList.add(writeRowToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!nullsOnly);\n\t\t} catch (Throwable t) {\n\t\t\tthrow throwExceptionAndClose(\"Error processing input rows from map\", t);\n\t\t}\n\t}\n",
        "diff": "\t\t\tif(headerMapping == null){ \n"
    },
    "36": {
        "patched_method": "\tpublic void execute(char[] characters, int length) {\n\n\t\tSet<Character> allSymbols = new HashSet<Character>();\n\t\tMap<Character, Integer> symbols = new HashMap<Character, Integer>();\n\t\tMap<Character, Integer> escape = new HashMap<Character, Integer>();\n\t\tList<Map<Character, Integer>> symbolsPerRow = new ArrayList<Map<Character, Integer>>();\n\n\t\tint doubleQuoteCount = 0;\n\t\tint singleQuoteCount = 0;\n\n\t\tint i;\n\t\tchar inQuote = '\\0';\n\t\tboolean afterNewLine = true;\n\t\tfor (i = 0; i < length; i++) {\n\n\t\t\tchar ch = characters[i];\n\n\t\t\tif (afterNewLine && ch == comment) {\n\t\t\t\twhile (++i < length) {\n\t\t\t\t\tch = characters[i];\n\t\t\t\t\tif (ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ch == '\"' || ch == '\\'') {\n\t\t\t\tif (inQuote == ch) { //closing quotes (potentially)\n\t\t\t\t\tif (ch == '\"') {\n\t\t\t\t\t\tdoubleQuoteCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsingleQuoteCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\t\tchar next = characters[i + 1];\n\t\t\t\t\t\tif (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\\n' && next != '\\r')) { //no special characters after quote, might be escaping\n\t\t\t\t\t\t\t//special character before (potentially) closing quote, might be an escape\n\t\t\t\t\t\t\tchar prev = characters[i - 1];\n\t\t\t\t\t\t\tif (!Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\t\t\tincrement(escape, prev);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tinQuote = '\\0';\n\t\t\t\t} else if (inQuote == '\\0') {\n\t\t\t\t\tchar prev = '\\0';\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (prev <= ' ' && --j >= 0) {\n\t\t\t\t\t\tprev = characters[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j < 0 || !Character.isLetterOrDigit(prev)) {\n\t\t\t\t\t\tinQuote = ch;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inQuote != '\\0') { //keep looping until the quote is closed.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tafterNewLine = false;\n\n\t\t\tif (isSymbol(ch)) { //counts all symbols. Skips letters, digits and white spaces (except the tab character)\n\t\t\t\tallSymbols.add(ch);\n\t\t\t\tincrement(symbols, ch);\n\t\t\t} else if ((ch == '\\r' || ch == '\\n' || ch == normalizedNewLine) && symbols.size() > 0) { //got a newline and collected some symbols? Good!\n\t\t\t\tafterNewLine = true;\n\t\t\t\tsymbolsPerRow.add(symbols);\n\t\t\t\tif (symbolsPerRow.size() == MAX_ROW_SAMPLES) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsymbols = new HashMap<Character, Integer>();\n\t\t\t}\n\t\t}\n\n\t\tif (i >= length && symbolsPerRow.size() > 1) { // if got to the end of the buffer, discard last row. It's probably incomplete anyway.\n\t\t\tsymbolsPerRow.remove(symbolsPerRow.size() - 1);\n\t\t}\n\n\t\tMap<Character, Integer> totals = calculateTotals(symbolsPerRow);\n\n\t\tMap<Character, Integer> sums = new HashMap<Character, Integer>();\n\t\tSet<Character> toRemove = new HashSet<Character>();\n\n\t\t//combines the number of symbols found in each row and sums the difference.\n\t\tfor (Map<Character, Integer> previous : symbolsPerRow) {\n\t\t\tfor (Map<Character, Integer> current : symbolsPerRow) {\n\t\t\t\tfor (Character symbol : allSymbols) {\n\t\t\t\t\tInteger previousCount = previous.get(symbol);\n\t\t\t\t\tInteger currentCount = current.get(symbol);\n\n\t\t\t\t\tif (previousCount == null && currentCount == null) { // got a symbol that does not appear in all rows? Discard it.\n\t\t\t\t\t\ttoRemove.add(symbol);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (previousCount == null || currentCount == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tincrement(sums, symbol, Math.abs(previousCount - currentCount)); // we expect to always get 0 or close to 0 here, so the symbol occurs in all rows\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsums.keySet().removeAll(toRemove);\n\n\t\tchar delimiter = max(totals, sums, suggestedDelimiter); \n\t\tchar quote = doubleQuoteCount >= singleQuoteCount ? '\"' : '\\'';\n\n\t\tescape.remove(delimiter);\n\t\tchar quoteEscape = max(escape, totals, quote);\n\t\tapply(delimiter, quote, quoteEscape);\n\t}\n",
        "diff": "\t\tchar delimiter = max(totals, sums, suggestedDelimiter); \n"
    },
    "37": {
        "patched_method": "\tvoid mapValuesToFields(T instance, Object[] row, Context context) {\n\t\tif (row.length > lastFieldIndexMapped) {\n\t\t\tthis.lastFieldIndexMapped = row.length;\n\t\t\tmapFieldIndexes(context, row, context.headers(), context.extractedFieldIndexes(), context.columnsReordered());\n\t\t}\n\n\t\tint last = row.length < readOrder.length ? row.length : readOrder.length;\n\t\tint i = 0;\n\t\tfor (; i < last; i++) {\n\t\t\tFieldMapping field = readOrder[i];\n\t\t\tif (field != null) {\n\t\t\t\tObject value = row[i];\n\t\t\t\tfield.write(instance, value);\n\t\t\t}\n\t\t}\n\n\t\tif (row.length < readOrder.length && conversions != null) { \n\t\t\ti = last;\n\t\t\tfor (; i < readOrder.length; i++) {\n\t\t\t\tFieldMapping field = readOrder[i];\n\t\t\t\tif (field != null) {\n\t\t\t\t\tObject value = conversions.applyConversions(i, null, null);\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (missing != null) {\n\t\t\tfor (i = 0; i < missing.length; i++) {\n\t\t\t\tObject value = valuesForMissing[i];\n\t\t\t\tif (value != null) {\n\t\t\t\t\tFieldMapping field = missing[i];\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n",
        "diff": "\t\tif (row.length < readOrder.length && conversions != null) { \n"
    },
    "39": {
        "patched_method": "\tprivate void parseQuotedValue() {\n\t\tif (prev != '\\0' && parseUnescapedQuotesUntilDelimiter) {\n\t\t\tif (quoteHandling == SKIP_VALUE) {\n\t\t\t\tskipValue();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!keepQuotes) {\n\t\t\t\toutput.appender.prepend(quote);\n\t\t\t}\n\t\t\tch = input.nextChar();\n\t\t\toutput.trim = ignoreTrailingWhitespace;\n\t\t\tch = output.appender.appendUntil(ch, input, delimiter, newLine);\n\t\t} else {\n\t\t\tif (keepQuotes && prev == '\\0') {\n\t\t\t\toutput.appender.append(quote);\n\t\t\t}\n\t\t\tch = input.nextChar();\n\t\t\twhile (true) {\n\t\t\t\tif (prev == quote && (ch <= ' ' && whitespaceRangeStart < ch || ch == delimiter || ch == newLine)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ch != quote && ch != quoteEscape) {\n\t\t\t\t\tif (prev == quote) { //unescaped quote detected\n\t\t\t\t\t\tif (handleUnescapedQuote()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (prev == quoteEscape && quoteEscape != '\\0') {\n\t\t\t\t\t\toutput.appender.append(quoteEscape);\n\t\t\t\t\t}\n\t\t\t\t\tch = output.appender.appendUntil(ch, input, quote, quoteEscape, escapeEscape);\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t} else {\n\t\t\t\t\tprocessQuoteEscape();\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\tif(unescaped && (ch == delimiter || ch == newLine)){ \n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// handles whitespaces after quoted value: whitespaces are ignored. Content after whitespaces may be parsed if 'parseUnescapedQuotes' is enabled.\n\t\t\tif (ch != delimiter && ch != newLine && ch <= ' ' && whitespaceRangeStart < ch) {\n\t\t\t\twhitespaceAppender.reset();\n\t\t\t\tdo {\n\t\t\t\t\t//saves whitespaces after value\n\t\t\t\t\twhitespaceAppender.append(ch);\n\t\t\t\t\tch = input.nextChar();\n\t\t\t\t\t//found a new line, go to next record.\n\t\t\t\t\tif (ch == newLine) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} while (ch <= ' ' && whitespaceRangeStart < ch);\n\n\t\t\t\t//there's more stuff after the quoted value, not only empty spaces.\n\t\t\t\tif (ch != delimiter && parseUnescapedQuotes) {\n\t\t\t\t\tif (output.appender instanceof DefaultCharAppender) {\n\t\t\t\t\t\t//puts the quote before whitespaces back, then restores the whitespaces\n\t\t\t\t\t\toutput.appender.append(quote);\n\t\t\t\t\t\t((DefaultCharAppender) output.appender).append(whitespaceAppender);\n\t\t\t\t\t}\n\t\t\t\t\t//the next character is not the escape character, put it there\n\t\t\t\t\tif (parseUnescapedQuotesUntilDelimiter || ch != quote && ch != quoteEscape) {\n\t\t\t\t\t\toutput.appender.append(ch);\n\t\t\t\t\t}\n\n\t\t\t\t\t//sets this character as the previous character (may be escaping)\n\t\t\t\t\t//calls recursively to keep parsing potentially quoted content\n\t\t\t\t\tprev = ch;\n\t\t\t\t\tparseQuotedValue();\n\t\t\t\t} else if (keepQuotes) {\n\t\t\t\t\toutput.appender.append(quote);\n\t\t\t\t}\n\t\t\t} else if (keepQuotes) {\n\t\t\t\toutput.appender.append(quote);\n\t\t\t}\n\n\t\t\tif (ch != delimiter && ch != newLine) {\n\t\t\t\tthrow new TextParsingException(context, \"Unexpected character '\" + ch + \"' following quoted value of CSV field. Expecting '\" + delimiter + \"'. Cannot parse CSV input.\");\n\t\t\t}\n\t\t}\n\t}\n",
        "diff": "\t\t\t\t\tif(unescaped && (ch == delimiter || ch == newLine)){ \n"
    },
    "42": {
        "patched_method": "    public static boolean isInvisibleChar(int c) {\nreturn Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 173);        // zero width sp, zw non join, soft hyphen \n    }\n",
        "diff": "return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 173);        // zero width sp, zw non join, soft hyphen \n"
    },
    "43": {
        "patched_method": "    public String getValue() {\n       return val == null ? \"\" : val; \n    }\n",
        "diff": "       return val == null ? \"\" : val; \n"
    },
    "44": {
        "patched_method": "    public final float scanFieldFloat(char[] fieldName) {\n        matchStat = UNKNOWN;\n\n        if (!charArrayCompare(fieldName)) {\n            matchStat = NOT_MATCH_NAME;\n            return 0;\n        }\n\n        int offset = fieldName.length;\n        char chLocal = charAt(bp + (offset++));\n\n        final boolean quote = chLocal == '\"';\n        if (quote) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        boolean negative = chLocal == '-';\n        if (negative) {\n            chLocal = charAt(bp + (offset++));\n        }\n\n        float value;\n        if (chLocal >= '0' && chLocal <= '9') {\n            int intVal = chLocal - '0';\n            for (;;) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            int power = 1;\n            boolean small = (chLocal == '.');\n            if (small) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal >= '0' && chLocal <= '9') {\n                    intVal = intVal * 10 + (chLocal - '0');\n                    power = 10;\n                    for (;;) {\n                        chLocal = charAt(bp + (offset++));\n                        if (chLocal >= '0' && chLocal <= '9') {\n                            intVal = intVal * 10 + (chLocal - '0');\n                            power *= 10;\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                } else {\n                    matchStat = NOT_MATCH;\n                    return 0;\n                }\n            }\n\n            boolean exp = chLocal == 'e' || chLocal == 'E';\n            if (exp) {\n                chLocal = charAt(bp + (offset++));\n                if (chLocal == '+' || chLocal == '-') {\n                    chLocal = charAt(bp + (offset++));\n                }\n                for (;;) {\n                    if (chLocal >= '0' && chLocal <= '9') {\n                        chLocal = charAt(bp + (offset++));\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            int start, count;\n            if (quote) {\n                if (chLocal != '\"') {\n                    matchStat = NOT_MATCH;\n                    return 0;\n                } else {\n                    chLocal = charAt(bp + (offset++));\n                }\n                start = bp + fieldName.length + 1;\n                count = bp + offset - start - 2;\n            } else {\n                start = bp + fieldName.length;\n                count = bp + offset - start - 1;\n            }\n\n           if (!exp && count < 9) { \n                value = ((float) intVal) / power;\n                if (negative) {\n                    value = -value;\n                }\n            } else {\n                String text = this.subString(start, count);\n                value = Float.parseFloat(text);\n            }\n        } else if (chLocal == 'n' && charAt(bp + offset) == 'u' && charAt(bp + offset + 1) == 'l' && charAt(bp + offset + 2) == 'l') {\n            matchStat = VALUE_NULL;\n            value = 0;\n            offset += 3;\n            chLocal = charAt(bp + offset++);\n\n            if (quote && chLocal == '\"') {\n                chLocal = charAt(bp + offset++);\n            }\n\n            for (;;) {\n                if (chLocal == ',') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.COMMA;\n                    return value;\n                } else if (chLocal == '}') {\n                    bp += offset;\n                    this.ch = charAt(bp);\n                    matchStat = VALUE_NULL;\n                    token = JSONToken.RBRACE;\n                    return value;\n                } else if (isWhitespace(chLocal)) {\n                    chLocal = charAt(bp + offset++);\n                    continue;\n                }\n                break;\n            }\n            matchStat = NOT_MATCH;\n            return 0;\n        } else {\n            matchStat = NOT_MATCH;\n            return 0;\n        }\n\n        if (chLocal == ',') {\n            bp += offset;\n            this.ch = this.charAt(bp);\n            matchStat = VALUE;\n            token = JSONToken.COMMA;\n            return value;\n        }\n\n        if (chLocal == '}') {\n            chLocal = charAt(bp + (offset++));\n            if (chLocal == ',') {\n                token = JSONToken.COMMA;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == ']') {\n                token = JSONToken.RBRACKET;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == '}') {\n                token = JSONToken.RBRACE;\n                bp += offset;\n                this.ch = this.charAt(bp);\n            } else if (chLocal == EOI) {\n                bp += (offset - 1);\n                token = JSONToken.EOF;\n                ch = EOI;\n            } else {\n                matchStat = NOT_MATCH;\n                return 0;\n            }\n            matchStat = END;\n        } else {\n            matchStat = NOT_MATCH;\n            return 0;\n        }\n\n        return value;\n    }\n",
        "diff": "           if (!exp && count < 9) { \n"
    },
    "47": {
        "patched_method": "    public Object createInstance(Map<String, Object> map, ParserConfig config) //\n                                                                               throws IllegalArgumentException,\n                                                                               IllegalAccessException,\n                                                                               InvocationTargetException {\n        Object object = null;\n        \n        if (beanInfo.creatorConstructor == null && beanInfo.factoryMethod == null) {\n            object = createInstance(null, clazz);\n            \n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser == null) {\n                    continue;\n                }\n\n                final FieldInfo fieldInfo = fieldDeser.fieldInfo;\n                Field field = fieldDeser.fieldInfo.field;\n                Type paramType = fieldInfo.fieldType;\n\n                if (fieldInfo.declaringClass != null\n                        && fieldInfo.getAnnotation() != null\n                        && fieldInfo.getAnnotation().deserializeUsing() != Void.class\n                        && fieldInfo.fieldClass.isInstance(value)) {\n                    DefaultJSONParser parser = new DefaultJSONParser(JSON.toJSONString(value));\n                    fieldDeser.parseField(parser, object, paramType, null);\n                    continue;\n                }\n\n               if (field != null && field.getType().isPrimitive()) { \n                    Class fieldType = field.getType();\n                    if (fieldType == boolean.class) {\n                        if (value == Boolean.FALSE) {\n                            field.setBoolean(object, false);\n                            continue;\n                        }\n\n                        if (value == Boolean.TRUE) {\n                            field.setBoolean(object, true);\n                            continue;\n                        }\n                    } else if (fieldType == int.class) {\n                        if (value instanceof Number) {\n                            field.setInt(object, ((Number) value).intValue());\n                            continue;\n                        }\n                    } else if (fieldType == long.class) {\n                        if (value instanceof Number) {\n                            field.setLong(object, ((Number) value).longValue());\n                            continue;\n                        }\n                    } else if (fieldType == float.class) {\n                        if (value instanceof Number) {\n                            field.setFloat(object, ((Number) value).floatValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            float floatValue;\n                            if (strVal.length() <= 10) {\n                                floatValue = TypeUtils.parseFloat(strVal);\n                            } else {\n                                floatValue = Float.parseFloat(strVal);\n                            }\n\n                            field.setFloat(object, floatValue);\n                            continue;\n                        }\n                    } else if (fieldType == double.class) {\n                        if (value instanceof Number) {\n                            field.setDouble(object, ((Number) value).doubleValue());\n                            continue;\n                        } else if (value instanceof String) {\n                            String strVal = (String) value;\n                            double doubleValue;\n                            if (strVal.length() <= 10) {\n                                doubleValue = TypeUtils.parseDouble(strVal);\n                            } else {\n                                doubleValue = Double.parseDouble(strVal);\n                            }\n\n                            field.setDouble(object, doubleValue);\n                            continue;\n                        }\n                    } else if (value != null && paramType == value.getClass()) {\n                        field.set(object, value);\n                        continue;\n                    }\n                }\n\n                String format = fieldInfo.format;\n                if (format != null && paramType == Date.class) {\n                    value = TypeUtils.castToDate(value, format);\n                } else if (format != null && (paramType instanceof Class) && (((Class) paramType).getName().equals(\"java.time.LocalDateTime\"))) {\n                    value = TypeUtils.castToLocalDateTime(value, format);\n                } else {\n                    if (paramType instanceof ParameterizedType) {\n                        value = TypeUtils.cast(value, (ParameterizedType) paramType, config);\n                    } else {\n                        value = TypeUtils.cast(value, paramType, config);\n                    }\n                }\n\n                fieldDeser.setValue(object, value);\n            }\n\n            if (beanInfo.buildMethod != null) {\n                Object builtObj;\n                try {\n                    builtObj = beanInfo.buildMethod.invoke(object);\n                } catch (Exception e) {\n                    throw new JSONException(\"build object error\", e);\n                }\n\n                return builtObj;\n            }\n\n            return object;\n        }\n\n        \n        FieldInfo[] fieldInfoList = beanInfo.fields;\n        int size = fieldInfoList.length;\n        Object[] params = new Object[size];\n        Map<String, Integer> missFields = null;\n        for (int i = 0; i < size; ++i) {\n            FieldInfo fieldInfo = fieldInfoList[i];\n            Object param = map.get(fieldInfo.name);\n\n            if (param == null) {\n                Class<?> fieldClass = fieldInfo.fieldClass;\n                if (fieldClass == int.class) {\n                    param = 0;\n                } else if (fieldClass == long.class) {\n                    param = 0L;\n                } else if (fieldClass == short.class) {\n                    param = Short.valueOf((short) 0);\n                } else if (fieldClass == byte.class) {\n                    param = Byte.valueOf((byte) 0);\n                } else if (fieldClass == float.class) {\n                    param = Float.valueOf(0);\n                } else if (fieldClass == double.class) {\n                    param = Double.valueOf(0);\n                } else if (fieldClass == char.class) {\n                    param = '0';\n                } else if (fieldClass == boolean.class) {\n                    param = false;\n                }\n                if (missFields == null) {\n                    missFields = new HashMap<String, Integer>();\n                }\n                missFields.put(fieldInfo.name, i);\n            }\n            params[i] = param;\n        }\n\n        if (missFields != null) {\n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                Object value = entry.getValue();\n\n                FieldDeserializer fieldDeser = smartMatch(key);\n                if (fieldDeser != null) {\n                    Integer index = missFields.get(fieldDeser.fieldInfo.name);\n                    if (index != null) {\n                        params[index] = value;\n                    }\n                }\n            }\n        }\n\n        if (beanInfo.creatorConstructor != null) {\n            boolean hasNull = false;\n            if (beanInfo.kotlin) {\n                for (int i = 0; i < params.length; i++) {\n                    if (params[i] == null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                        FieldInfo fieldInfo = beanInfo.fields[i];\n                        if (fieldInfo.fieldClass == String.class) {\n                            hasNull = true;\n                        }\n                        break;\n                    }\n                }\n            }\n\n            if (hasNull && beanInfo.kotlinDefaultConstructor != null) {\n                try {\n                    object = beanInfo.kotlinDefaultConstructor.newInstance();\n\n                    for (int i = 0; i < params.length; i++) {\n                        final Object param = params[i];\n                        if (param != null && beanInfo.fields != null && i < beanInfo.fields.length) {\n                            FieldInfo fieldInfo = beanInfo.fields[i];\n                            fieldInfo.set(object, param);\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            } else {\n                try {\n                    object = beanInfo.creatorConstructor.newInstance(params);\n                } catch (Exception e) {\n                    throw new JSONException(\"create instance error, \"\n                            + beanInfo.creatorConstructor.toGenericString(), e);\n                }\n            }\n        } else if (beanInfo.factoryMethod != null) {\n            try {\n                object = beanInfo.factoryMethod.invoke(null, params);\n            } catch (Exception e) {\n                throw new JSONException(\"create factory method error, \" + beanInfo.factoryMethod.toString(), e);\n            }\n        }\n        \n        return object;\n    }\n",
        "diff": "               if (field != null && field.getType().isPrimitive()) { \n"
    },
    "48": {
        "patched_method": "    protected Object getVariable(Frame frame, LexicalScope block, ASTIdentifier identifier) {\n        int symbol = identifier.getSymbol();\n        // if we have a symbol, we have a scope thus a frame\n        if (options.isLexicalShade() && identifier.isShaded()) {\n            return undefinedVariable(identifier, identifier.getName());\n        }\n        if (symbol >= 0) {\n            if (frame.has(symbol)) {\n                Object value = frame.get(symbol);\n                if (value != Scope.UNDEFINED) {\n                    return value;\n                }\n            }\n        }\n        String name = identifier.getName();\n        Object value = context.get(name);\n        if (value == null\n            && !(identifier.jjtGetParent() instanceof ASTReference)\n            && !(context.has(name))) {\n           return isSafe()                    ? undefinedVariable(identifier, name) : unsolvableVariable(identifier, name, true); \n        }\n        return value;\n    }\n",
        "diff": "           return isSafe()                    ? undefinedVariable(identifier, name) : unsolvableVariable(identifier, name, true); \n"
    },
    "54": {
        "patched_method": "\tprivate <T> void fillOutputRow(T[] row) {\n\t\tif (!columnReorderingEnabled && row.length > outputRow.length) {\n\t\t\toutputRow = Arrays.copyOf(outputRow, row.length);\n\t\t}\n\t\tif (indexesToWrite.length < row.length) {\n\t\t\tfor (int i = 0; i < indexesToWrite.length; i++) {\n\t\t\t\toutputRow[i] = row[indexesToWrite[i]]; \n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < row.length && i < indexesToWrite.length; i++) {\n\t\t\t\tif (indexesToWrite[i] != -1) {\n\t\t\t\t\toutputRow[indexesToWrite[i]] = row[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
        "diff": "\t\t\t\toutputRow[i] = row[indexesToWrite[i]]; \n"
    },
    "66": {
        "patched_method": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n       if (count <= 0)             return \"\"; \n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n",
        "diff": "       if (count <= 0)             return \"\"; \n"
    },
    "95": {
        "patched_method": "    public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) throws IOException {\n        SerializeWriter out = serializer.out;\n\n        if (object == null) {\n            out.writeNull();\n            return;\n        }\n\n        Class<?> clazz = object.getClass();\n        if (clazz == java.sql.Date.class) {\n            long millis = ((java.sql.Date) object).getTime();\n            TimeZone timeZone = serializer.timeZone;\n            int offset = timeZone.getOffset(millis);\n            //\n            if ((millis + offset) % (24 * 1000 * 3600) == 0\n                    && !SerializerFeature.isEnabled(out.features, features, SerializerFeature.WriteClassName)) {\n                out.writeString(object.toString());\n                return;\n            }\n        }\n\n        if (clazz == java.sql.Time.class) {\n            long millis = ((java.sql.Time) object).getTime();\n            if (\"unixtime\".equals(serializer.getDateFormatPattern())) {\n                long seconds = millis / 1000;\n                out.writeLong(seconds);\n                return;\n            }\n\n            if (\"millis\".equals(serializer.getDateFormatPattern())) {\n                long seconds = millis;\n                out.writeLong(millis);\n                return;\n            }\n\n            if (millis < 24L * 60L * 60L * 1000L) {\n                out.writeString(object.toString());\n                return;\n            }\n        }\n\n        int nanos = 0;\n        if (clazz == java.sql.Timestamp.class) {\n            java.sql.Timestamp ts = (java.sql.Timestamp) object;\n            nanos = ts.getNanos();\n        }\n        \n        Date date;\n        if (object instanceof Date) {\n            date = (Date) object;\n        } else {\n            date = TypeUtils.castToDate(object);\n        }\n\n        if (\"unixtime\".equals(serializer.getDateFormatPattern())) {\n            long seconds = date.getTime() / 1000;\n            out.writeLong(seconds);\n            return;\n        }\n\n        if (\"millis\".equals(serializer.getDateFormatPattern())) {\n            long millis = date.getTime();\n            out.writeLong(millis);\n            return;\n        }\n\n        if (out.isEnabled(SerializerFeature.WriteDateUseDateFormat)) {\n            DateFormat format = serializer.getDateFormat();\n            if (format == null) {\n                format = new SimpleDateFormat(JSON.DEFFAULT_DATE_FORMAT, serializer.locale);\n                format.setTimeZone(serializer.timeZone);\n            }\n            String text = format.format(date);\n            out.writeString(text);\n            return;\n        }\n        \n        if (out.isEnabled(SerializerFeature.WriteClassName)) {\n            if (clazz != fieldType) {\n                if (clazz == java.util.Date.class) {\n                    out.write(\"new Date(\");\n                    out.writeLong(((Date) object).getTime());\n                    out.write(')');\n                } else {\n                    out.write('{');\n                    out.writeFieldName(JSON.DEFAULT_TYPE_KEY);\n                    serializer.write(clazz.getName());\n                    out.writeFieldValue(',', \"val\", ((Date) object).getTime());\n                    out.write('}');\n                }\n                return;\n            }\n        }\n\n        long time = date.getTime();\n        if (out.isEnabled(SerializerFeature.UseISO8601DateFormat)) {\n            char quote = out.isEnabled(SerializerFeature.UseSingleQuotes) ? '\\'' : '\\\"'; \n            out.write(quote);\n\n            Calendar calendar = Calendar.getInstance(serializer.timeZone, serializer.locale);\n            calendar.setTimeInMillis(time);\n\n            int year = calendar.get(Calendar.YEAR);\n            int month = calendar.get(Calendar.MONTH) + 1;\n            int day = calendar.get(Calendar.DAY_OF_MONTH);\n            int hour = calendar.get(Calendar.HOUR_OF_DAY);\n            int minute = calendar.get(Calendar.MINUTE);\n            int second = calendar.get(Calendar.SECOND);\n            int millis = calendar.get(Calendar.MILLISECOND);\n\n            char[] buf;\n            if (nanos > 0) {\n                buf = \"0000-00-00 00:00:00.000000000\".toCharArray();\n                int nanoSize = IOUtils.stringSize(nanos);\n               IOUtils.getChars(nanos, 29 - (9 - nanoSize), buf); \n                IOUtils.getChars(second, 19, buf);\n                IOUtils.getChars(minute, 16, buf);\n                IOUtils.getChars(hour, 13, buf);\n                IOUtils.getChars(day, 10, buf);\n                IOUtils.getChars(month, 7, buf);\n                IOUtils.getChars(year, 4, buf);\n            } else if (millis != 0) {\n                buf = \"0000-00-00T00:00:00.000\".toCharArray();\n                IOUtils.getChars(millis, 23, buf);\n                IOUtils.getChars(second, 19, buf);\n                IOUtils.getChars(minute, 16, buf);\n                IOUtils.getChars(hour, 13, buf);\n                IOUtils.getChars(day, 10, buf);\n                IOUtils.getChars(month, 7, buf);\n                IOUtils.getChars(year, 4, buf);\n\n            } else {\n                if (second == 0 && minute == 0 && hour == 0) {\n                    buf = \"0000-00-00\".toCharArray();\n                    IOUtils.getChars(day, 10, buf);\n                    IOUtils.getChars(month, 7, buf);\n                    IOUtils.getChars(year, 4, buf);\n                } else {\n                    buf = \"0000-00-00T00:00:00\".toCharArray();\n                    IOUtils.getChars(second, 19, buf);\n                    IOUtils.getChars(minute, 16, buf);\n                    IOUtils.getChars(hour, 13, buf);\n                    IOUtils.getChars(day, 10, buf);\n                    IOUtils.getChars(month, 7, buf);\n                    IOUtils.getChars(year, 4, buf);\n                }\n            }\n            \n            out.write(buf);\n            if (nanos > 0) { // java.sql.Timestamp\n                out.write(quote);\n                return;\n            }\n\n            float timeZoneF = calendar.getTimeZone().getOffset(calendar.getTimeInMillis()) / (3600.0f * 1000);\n            int timeZone = (int)timeZoneF;\n            if (timeZone == 0.0) {\n                out.write('Z');\n            } else {\n                if (timeZone > 9) {\n                    out.write('+');\n                    out.writeInt(timeZone);\n                } else if (timeZone > 0) {\n                    out.write('+');\n                    out.write('0');\n                    out.writeInt(timeZone);\n                } else if (timeZone < -9) {\n                    out.write('-');\n                    out.writeInt(-timeZone);\n                } else if (timeZone < 0) {\n                    out.write('-');\n                    out.write('0');\n                    out.writeInt(-timeZone);\n                }\n                out.write(':');\n                // handles uneven timeZones 30 mins, 45 mins\n                // this would always be less than 60\n                int offSet = (int)(Math.abs(timeZoneF - timeZone) * 60);\n                out.append(String.format(\"%02d\", offSet));\n            }\n\n            out.write(quote);\n        } else {\n            out.writeLong(time);\n        }\n    }\n",
        "diff": "               IOUtils.getChars(nanos, 29 - (9 - nanoSize), buf); \n"
    },
    "96": {
        "patched_method": "    public void finish() throws IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                if (this.runLength > 0) {\n                    writeRun();\n                }\n                this.currentChar = -1;\n                endBlock();\n                endCompression();\n            } finally {\n               this.out.close();                 this.out = null; \n                this.blockSorter = null;\n                this.data = null;\n            }\n        }\n    }\n",
        "diff": "               this.out.close();                 this.out = null; \n"
    }
}