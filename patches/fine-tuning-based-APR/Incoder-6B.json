{
    "2": {
        "patched_method": "  private void readUntilEndOfEntry() throws IOException {\n    if (localFileHeader.isDirectory()) { \n      return;\n    }\n\n    if (endOfEntryBuffer == null) {\n      endOfEntryBuffer = new byte[512];\n    }\n\n    while (read(endOfEntryBuffer) != -1);\n  }\n",
        "diff": "    if (localFileHeader.isDirectory()) { \n"
    },
    "5": {
        "patched_method": "    public @Override String getName() {\n    if (testName == null || testName.isEmpty()) { \n    \t\treturn \"(?)\";\n    \t}\n        return testName;\n    }\n",
        "diff": "    if (testName == null || testName.isEmpty()) { \n"
    },
    "10": {
        "patched_method": "\tprivate static boolean isAssignableFrom(Class<?> target, KType source) {\n\n\t\tType parameterType = ReflectJvmMapping.getJavaType(source);\n\nreturn ResolvableType.forClass(target).isAssignableFrom(ResolvableType.forType(parameterType)) || target.isInterface(); \n\t}\n",
        "diff": "return ResolvableType.forClass(target).isAssignableFrom(ResolvableType.forType(parameterType)) || target.isInterface(); \n"
    },
    "30": {
        "patched_method": "\tpublic String[] rowParsed() {\n\t\t// some values were parsed. Let's return them\n\t\tif (column > 0) {\n\t\t\t// identifies selected columns and headers (in the first non-empty row)\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t\t//skips the header row. We want to use the headers defined in the settings.\n\t\t\t\tif (settings.isHeaderExtractionEnabled()) {\n\t\t\t\t\tArrays.fill(parsedValues, null);\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tthis.appender = appenders[0];\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (!columnsReordered && selectedIndexes != null) {\n\t\t\t\t\tString[] out = new String[column];\n\t\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\t\tif (index < column) {\n\t\t\t\t\t\t\tout[index] = parsedValues[index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\treturn out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n\t\t\t\tcolumn = 0; \n\t\t\t\t\t// column = 0;\n\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] reorderedValues = new String[selectedIndexes.length];\n\t\t\t\tfor (int i = 0; i < selectedIndexes.length; i++) {\n\t\t\t\t\tint index = selectedIndexes[i];\n\t\t\t\t\tif (index >= column || index == -1) {\n\t\t\t\t\t\treorderedValues[i] = nullValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treorderedValues[i] = parsedValues[index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn reorderedValues;\n\t\t\t} else {\n\t\t\t\tint last = columnReorderingEnabledSetting ? column : column < headers.length ? headers.length : column;\n\n\t\t\t\tString[] out = new String[last];\n\t\t\t\tSystem.arraycopy(parsedValues, 0, out, 0, column);\n\t\t\t\tcolumn = 0;\n\t\t\t\tthis.appender = appenders[0];\n\t\t\t\treturn out;\n\t\t\t}\n\t\t} else if (!skipEmptyLines) { //no values were parsed, but we are not skipping empty lines\n\t\t\tif (!columnsToExtractInitialized) {\n\t\t\t\tinitializeHeaders();\n\t\t\t}\n\n\t\t\tcurrentRecord++;\n\n\t\t\tif (columnsReordered) {\n\t\t\t\tif(selectedIndexes.length == 0){\n\t\t\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t\t\t}\n\t\t\t\tString[] out = new String[selectedIndexes.length];\n\t\t\t\tArrays.fill(out, nullValue);\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\treturn ArgumentUtils.EMPTY_STRING_ARRAY;\n\t\t}\n\t\t// no values were parsed and we do not care about empty lines.\n\t\treturn null;\n\t}\n",
        "diff": "\t\t\t\tcolumn = 0; \n"
    },
    "34": {
        "patched_method": "\tprivate <K, I extends Iterable<?>> void writeRows(Map<K, String> headerMapping, Map<K, I> rowData, List<String> outputList, boolean useRowProcessor) {\n\t\ttry {\n\t\t\tIterator[] iterators = new Iterator[rowData.size()];\n\t\t\tObject[] keys = new Object[rowData.size()];\n\t\t\tfinal Map<Object, Object> rowValues = new LinkedHashMap<Object, Object>(rowData.size());\n\n\t\t\tif(headerMapping == null){ \n\t\t\t\tif(headerMapping != null){\n\t\t\t\t\tsetHeadersFromMap(headerMapping, true);\n\t\t\t\t} else {\n\t\t\t\t\tsetHeadersFromMap(rowData, true);\n\t\t\t\t}\n\t\t\t\tif(isHeaderWritingEnabled && recordCount == 0){\n\t\t\t\t\toutputList.add(writeHeadersToString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint length = 0;\n\t\t\tfor (Map.Entry<K, I> rowEntry : rowData.entrySet()) {\n\t\t\t\titerators[length] = rowEntry.getValue() == null ? null : rowEntry.getValue().iterator();\n\t\t\t\tkeys[length] = rowEntry.getKey();\n\t\t\t\trowValues.put(rowEntry.getKey(), null);\n\t\t\t\tlength++;\n\t\t\t}\n\t\t\tboolean nullsOnly;\n\n\t\t\tdo {\n\t\t\t\tnullsOnly = true;\n\t\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\t\tIterator<?> iterator = iterators[i];\n\t\t\t\t\tboolean isNull = iterator == null || !iterator.hasNext();\n\t\t\t\t\tnullsOnly &= isNull;\n\t\t\t\t\tif (isNull) {\n\t\t\t\t\t\trowValues.put(keys[i], null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trowValues.put(keys[i], iterator.next());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!nullsOnly) {\n\t\t\t\t\tif (outputList == null) {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\tprocessRecord((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteRow((Map) headerMapping, (Map) rowValues);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (useRowProcessor) {\n\t\t\t\t\t\t\toutputList.add(processRecordToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toutputList.add(writeRowToString((Map) headerMapping, (Map) rowValues));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!nullsOnly);\n\t\t} catch (Throwable t) {\n\t\t\tthrow throwExceptionAndClose(\"Error processing input rows from map\", t);\n\t\t}\n\t}\n",
        "diff": "\t\t\tif(headerMapping == null){ \n"
    },
    "37": {
        "patched_method": "\tvoid mapValuesToFields(T instance, Object[] row, Context context) {\n\t\tif (row.length > lastFieldIndexMapped) {\n\t\t\tthis.lastFieldIndexMapped = row.length;\n\t\t\tmapFieldIndexes(context, row, context.headers(), context.extractedFieldIndexes(), context.columnsReordered());\n\t\t}\n\n\t\tint last = row.length < readOrder.length ? row.length : readOrder.length;\n\t\tint i = 0;\n\t\tfor (; i < last; i++) {\n\t\t\tFieldMapping field = readOrder[i];\n\t\t\tif (field != null) {\n\t\t\t\tObject value = row[i];\n\t\t\t\tfield.write(instance, value);\n\t\t\t}\n\t\t}\n\nif (row.length > readOrder.length) { \n\t\t\ti = last;\n\t\t\tfor (; i < readOrder.length; i++) {\n\t\t\t\tFieldMapping field = readOrder[i];\n\t\t\t\tif (field != null) {\n\t\t\t\t\tObject value = conversions.applyConversions(i, null, null);\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (missing != null) {\n\t\t\tfor (i = 0; i < missing.length; i++) {\n\t\t\t\tObject value = valuesForMissing[i];\n\t\t\t\tif (value != null) {\n\t\t\t\t\tFieldMapping field = missing[i];\n\t\t\t\t\tfield.write(instance, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n",
        "diff": "if (row.length > readOrder.length) { \n"
    },
    "48": {
        "patched_method": "    protected Object getVariable(Frame frame, LexicalScope block, ASTIdentifier identifier) {\n        int symbol = identifier.getSymbol();\n        // if we have a symbol, we have a scope thus a frame\n        if (options.isLexicalShade() && identifier.isShaded()) {\n            return undefinedVariable(identifier, identifier.getName());\n        }\n        if (symbol >= 0) {\n            if (frame.has(symbol)) {\n                Object value = frame.get(symbol);\n                if (value != Scope.UNDEFINED) {\n                    return value;\n                }\n            }\n        }\n        String name = identifier.getName();\n        Object value = context.get(name);\n        if (value == null\n            && !(identifier.jjtGetParent() instanceof ASTReference)\n            && !(context.has(name))) {\n        return unsolvableVariable(identifier, name, true); \n        }\n        return value;\n    }\n",
        "diff": "        return unsolvableVariable(identifier, name, true); \n"
    },
    "81": {
        "patched_method": "  public RenderOnlySoyMsgBundleImpl(@Nullable String localeString, Iterable<SoyMsg> msgs) {\n\n    this.localeString = localeString;\n    this.locale = localeString == null ? null : new ULocale(localeString);\n    this.isRtl = BidiGlobalDir.forStaticLocale(localeString) == BidiGlobalDir.RTL;\n\n    // This creates the mask. Basically, take the high-bit and fill in the bits below it.\n    int maskHigh = Integer.highestOneBit(Iterables.size(msgs));\n    this.bucketMask = maskHigh >>> BUCKET_SHIFT; \n    int numBuckets = this.bucketMask + 1;\n\n    // Sorts by bucket (low bits within the mask) and breaks ties with the full ID.\n    Comparator<SoyMsg> bucketComparator =\n        Comparator.comparingInt((SoyMsg m) -> bucketOf(m.getId())).thenComparingLong(SoyMsg::getId);\n    ImmutableList<SoyMsg> sortedMsgs = ImmutableList.sortedCopyOf(bucketComparator, msgs);\n\n    // Scan the sorted list to discover bucket boundaries and place them into the boundaries array.\n    bucketBoundaries = new int[numBuckets + 1];\n    for (int bucket = 0, idx = 0; bucket < numBuckets; bucket++) {\n      bucketBoundaries[bucket] = idx;\n      for (;\n          (idx < sortedMsgs.size()) && (bucketOf(sortedMsgs.get(idx).getId()) == bucket);\n          idx++) {}\n    }\n    bucketBoundaries[numBuckets] = sortedMsgs.size();\n\n    ids = new long[sortedMsgs.size()];\n    ImmutableList.Builder<SoyMsgPart> partsBuilder = ImmutableList.builder();\n    partRanges = new int[sortedMsgs.size() + 1];\n    partRanges[0] = 0; // The first range always starts at the beginning of the list.\n    long priorId = sortedMsgs.isEmpty() ? -1L : sortedMsgs.get(0).getId() - 1L;\n    int runningPartCount = 0;\n    for (int i = 0, c = sortedMsgs.size(); i < c; i++) {\n      SoyMsg msg = sortedMsgs.get(i);\n      ImmutableList<SoyMsgPart> parts = msg.getParts();\n\n      checkArgument(\n          msg.getId() != priorId, \"Duplicate messages are not permitted in the render-only impl.\");\n      checkArgument(\n          MsgPartUtils.hasPlrselPart(parts) == msg.isPlrselMsg(),\n          \"Message's plural/select status is inconsistent -- internal compiler bug.\");\n\n      priorId = msg.getId();\n      ids[i] = msg.getId();\n      partsBuilder.addAll(parts);\n      runningPartCount += parts.size();\n      partRanges[i + 1] = runningPartCount; // runningPartCount is the end of range, hence +1\n    }\n\n    // This will build the collections in the same order as the sorted map.\n    values = partsBuilder.build();\n  }\n",
        "diff": "    this.bucketMask = maskHigh >>> BUCKET_SHIFT; \n"
    },
    "84": {
        "patched_method": "  public static Expression concatChunksForceString(List<? extends Expression> chunks) {\n    if (!chunks.isEmpty()\n        && chunks.get(0).isRepresentableAsSingleExpression()\n        && JsExprUtils.isStringLiteral(\n            chunks.get(0).assertExprAndCollectRequires(RequiresCollector.NULL))) {\n      return concatChunks(chunks);\n    } else if (chunks.size() > 1\n        && chunks.get(1).isRepresentableAsSingleExpression()\n        && JsExprUtils.isStringLiteral(\n            chunks.get(1).assertExprAndCollectRequires(RequiresCollector.NULL))) {\n      return concatChunks(chunks);\n    } else {\n      return concatChunks(\nImmutableList.of(LITERAL_EMPTY_STRING, concatChunks(chunks))); \n    }\n  }\n",
        "diff": "ImmutableList.of(LITERAL_EMPTY_STRING, concatChunks(chunks))); \n"
    },
    "96": {
        "patched_method": "    public void finish() throws IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                if (this.runLength > 0) {\n                    writeRun();\n                }\n                this.currentChar = -1;\n                endBlock();\n                endCompression();\n            } finally {\n                if (out!= null) {                     out.close();                 } \n                this.blockSorter = null;\n                this.data = null;\n            }\n        }\n    }\n",
        "diff": "                if (out!= null) {                     out.close();                 } \n"
    }
}